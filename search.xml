<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Two Pointer 问题总结</title>
      <link href="/2018/05/09/Two%20Pointer%20%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/09/Two%20Pointer%20%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="Two-Pointer-问题总结"><a href="#Two-Pointer-问题总结" class="headerlink" title="Two Pointer 问题总结"></a>Two Pointer 问题总结</h1><h2 id="基础热身题型（必会题型）："><a href="#基础热身题型（必会题型）：" class="headerlink" title="基础热身题型（必会题型）："></a>基础热身题型（必会题型）：</h2><ol><li>LeetCode283.  Move Zeroes</li><li>LeetCode 26:  Remove Duplicates from Sorted Array</li></ol><p><img src="/Users/Jiahui/Desktop/Screen Shot 2018-05-10 at 3.28.10 AM.png" alt="Screen Shot 2018-05-10 at 3.28.10 AM"></p><a id="more"></a> <p>Quick Select(QuickSort 中的partition部分)用到了two pointer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 在nums中的start 到end， 找到一个pivot，是的pivot左边大于pivot，左边小于pivot</span><br><span class="line">    //return pIndex;</span><br><span class="line">    public int partition(int[] nums, int start, int end)&#123;</span><br><span class="line"></span><br><span class="line">        int pivot = nums[end];</span><br><span class="line">        int pIndex = start;</span><br><span class="line"></span><br><span class="line">        for(int i = start; i &lt; end; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i] &gt;= pivot)&#123;</span><br><span class="line">                swap(nums, i, pIndex);</span><br><span class="line">                pIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(nums, pIndex, end);</span><br><span class="line"></span><br><span class="line">        return pIndex;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="经典题型：-2-Sum-3-Sum"><a href="#经典题型：-2-Sum-3-Sum" class="headerlink" title="经典题型： 2 Sum + 3 Sum"></a>经典题型： 2 Sum + 3 Sum</h2><h3 id="相似点：-对于求2个变量如何组合的问题，-可以循环其中一个变量，-然后研究另外一个变量如何变化"><a href="#相似点：-对于求2个变量如何组合的问题，-可以循环其中一个变量，-然后研究另外一个变量如何变化" class="headerlink" title="相似点： 对于求2个变量如何组合的问题， 可以循环其中一个变量， 然后研究另外一个变量如何变化"></a>相似点： 对于求2个变量如何组合的问题， 可以循环其中一个变量， 然后研究另外一个变量如何变化</h3><h4 id="Two-Sum-——Unsorted-array"><a href="#Two-Sum-——Unsorted-array" class="headerlink" title="Two Sum:——Unsorted array"></a>Two Sum:——Unsorted array</h4><h5 id="思路：-HashMap"><a href="#思路：-HashMap" class="headerlink" title="思路： HashMap"></a>思路： HashMap</h5><p>complexity:</p><p>time: O(n)</p><p>space: O(n)</p><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure><h5 id="代码：-C"><a href="#代码：-C" class="headerlink" title="代码： C++"></a>代码： C++</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; diffIndex;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i&lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            // map存diff，index； 在map中找当前nums[i]</span><br><span class="line">            if(diffIndex.find(nums[i]) != diffIndex.end())</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(diffIndex[nums[i]]);</span><br><span class="line">                result.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            diffIndex[target - nums[i]] = i;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Two-Sum—-sorted-array"><a href="#Two-Sum—-sorted-array" class="headerlink" title="Two Sum— sorted array"></a>Two Sum— sorted array</h4><p>#####思路： Two pointer </p><p>complexity:</p><ul><li>time: O(n)</li><li>space: O(1)</li></ul><p>Given an array of integers that is already <strong>sorted in ascending order</strong>, find two numbers such that they add up to a specific target number.</p><p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</p><p><strong>Note:</strong></p><ul><li>Your returned answers (both index1 and index2) are not zero-based.</li><li>You may assume that each input would have <em>exactly</em> one solution and you may not use the <em>same</em> element twice.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: numbers = [2,7,11,15], target = 9</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.</span><br></pre></td></tr></table></figure><h5 id="代码：-Java"><a href="#代码：-Java" class="headerlink" title="代码： Java"></a>代码： Java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] numbers, int target) &#123;</span><br><span class="line">        </span><br><span class="line">        int left = 0, right = numbers.length - 1;</span><br><span class="line">        int[] res = new int[2];</span><br><span class="line">        </span><br><span class="line">        while(left &lt; right)&#123;</span><br><span class="line">            int sum = numbers[left] + numbers[right];</span><br><span class="line">            </span><br><span class="line">            if(sum == target)&#123;</span><br><span class="line">                res[0] = left + 1;</span><br><span class="line">                res[1] = right + 1;</span><br><span class="line">                return res;</span><br><span class="line">            &#125;else if(sum &gt; target)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-sum："><a href="#3-sum：" class="headerlink" title="3 sum："></a>3 sum：</h4><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><ul><li>根据2sum思路： nums[i] + nums[j] + nums[k] = 0</li><li>默认nums[i] &lt;= nums[j] &lt;= nums[k]; 所以先Sort array</li><li>固定nums[i], 在i之后找到关于nums[j], nums[k]的所有组合可能性</li><li>难点： 注意i， j,  k都要去重： /<em>去重技巧， nums[i] == nums[i - 1] 往前</em>/</li></ul><h5 id="代码：-Java-1"><a href="#代码：-Java-1" class="headerlink" title="代码： Java"></a>代码： Java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        </span><br><span class="line">        //Sort nums</span><br><span class="line">        //nums[i] + nums[j] + nums[k] =0</span><br><span class="line">        //固定第一个数字，从i后面找剩下两个大一点的数字的组合可能性</span><br><span class="line">        //注意要多i，和j, k 都同时除重</span><br><span class="line">        </span><br><span class="line">        //time complexity： O(nlogn + n^2)</span><br><span class="line">        //space: O(1)</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; nums.length - 2; i++)&#123;</span><br><span class="line">            /*去重技巧， nums[i] == nums[i - 1] 往前*/</span><br><span class="line">            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) //skip same result</span><br><span class="line">                continue;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            int left = i + 1;</span><br><span class="line">            int right = nums.length - 1;</span><br><span class="line">            int target = 0 - nums[i];</span><br><span class="line">            while(left &lt; right)&#123;</span><br><span class="line">                int sum = nums[left] + nums[right];</span><br><span class="line">                </span><br><span class="line">                if(sum == target)&#123;</span><br><span class="line">                    list.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    left++; //继续往内侧压缩，找其他可能性</span><br><span class="line">                    right--;</span><br><span class="line">                    /*去重技巧， nums[i] == nums[i - 1] 往前*/</span><br><span class="line">                    while(left &lt; right &amp;&amp; nums[left] == nums[left - 1]) //skip same result</span><br><span class="line">                        left++;</span><br><span class="line">                    while(left &lt; right &amp;&amp; nums[right] == nums[right + 1]) //skip same result</span><br><span class="line">                        right--;</span><br><span class="line">                    </span><br><span class="line">                &#125;else if(sum &gt; target)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return list;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3Sum-Closest"><a href="#3Sum-Closest" class="headerlink" title="3Sum Closest"></a>3Sum Closest</h4><p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 2, 1, -4], and target = 1.</span><br><span class="line"></span><br><span class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>类似于3Sum</p><ol><li>nums[i] + nums[left] + nums[right] —&gt;target</li><li>sort array, 再固定nums[i]， 对i 之后的做2Sum， 并计算bestSum</li></ol><p>Complexity:</p><ol><li>time:  O(n^2)</li><li>space: O(1)</li></ol><h4 id="代码：-Java-2"><a href="#代码：-Java-2" class="headerlink" title="代码： Java"></a>代码： Java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int threeSumClosest(int[] nums, int target) &#123;</span><br><span class="line">        </span><br><span class="line">        //-1, 1, 2, -4</span><br><span class="line">        //-4 -1 1 2</span><br><span class="line">        //      0 0</span><br><span class="line">        </span><br><span class="line">        // if(nums == null || nums.length == 0 || nums.length &lt; 3)</span><br><span class="line">        //     return 0;</span><br><span class="line">        </span><br><span class="line">        //Time complexity: O(n^2)</span><br><span class="line">        //space complexity: O(1)</span><br><span class="line">        类似于3Sum</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        int bestSum = nums[0] + nums[1] + nums[2];</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.length - 2; i++)&#123;</span><br><span class="line">        </span><br><span class="line">            int left = i + 1;</span><br><span class="line">            int right = nums.length - 1;</span><br><span class="line">            </span><br><span class="line">            while( left &lt; right)&#123;</span><br><span class="line">                sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                if(Math.abs(target - sum) &lt; Math.abs(target - bestSum))</span><br><span class="line">                    bestSum = sum;</span><br><span class="line">                </span><br><span class="line">                if(sum &gt; target)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return bestSum;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4Sum"><a href="#4Sum" class="headerlink" title="4Sum"></a>4Sum</h4><p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = <code>target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>.</p><p><strong>Note:</strong></p><p>The solution set must not contain duplicate quadruplets.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h5><p>类似3Sum， </p><ol><li>nums[i] + nums[j] + nums[left] + nums[right] = target</li><li>fixed nums[i], then fixed nums[j], find the sum of two integer possibles, </li><li>注意点： 要对i， j, left, right 同时去重。 去重技巧/*i &gt; 0 &amp;&amp; nums[i] == nums[i - 1])/</li></ol><p>Complexity:</p><ol><li>time: O(n^3)</li><li>space: O(1)</li></ol><h5 id="代码：-Java-3"><a href="#代码：-Java-3" class="headerlink" title="代码： Java"></a>代码： Java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;</span><br><span class="line">        </span><br><span class="line">        if(nums == null || nums.length &lt; 4)</span><br><span class="line">            return new ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; nums.length - 3; i++)&#123;</span><br><span class="line">            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1])</span><br><span class="line">                continue;</span><br><span class="line">            for(int j = i + 1; j &lt; nums.length - 2; j++)&#123;</span><br><span class="line">                </span><br><span class="line">                /*去重技巧：j != i + 1 &amp;&amp;  nums[j] == nums[j - 1]*/</span><br><span class="line">                if(j != i + 1  &amp;&amp; nums[j] == nums[j - 1])</span><br><span class="line">                    continue;</span><br><span class="line">                </span><br><span class="line">                int left = j + 1;</span><br><span class="line">                int right = nums.length - 1;</span><br><span class="line">                while(left &lt; right)&#123;</span><br><span class="line">                    int sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    if(sum == target)&#123;</span><br><span class="line">                        list.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                        while(left &lt; right &amp;&amp; nums[left] == nums[left - 1])</span><br><span class="line">                            left++;</span><br><span class="line">                        while(left &lt; right &amp;&amp; nums[right] == nums[right + 1])</span><br><span class="line">                            right--;</span><br><span class="line">                        </span><br><span class="line">                    &#125;else if(sum &gt; target)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Two Pointer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java常用API+数据结构</title>
      <link href="/2018/05/09/Java%E5%B8%B8%E7%94%A8API+%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2018/05/09/Java%E5%B8%B8%E7%94%A8API+%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h1 id="Data-Type"><a href="#Data-Type" class="headerlink" title="Data Type"></a>Data Type</h1><h2 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h2><table><thead><tr><th style="text-align:center">return</th><th style="text-align:center">Method</th><th style="text-align:center">Usage</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">boolean</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Character.html#isLetter-char-" target="_blank" rel="noopener">isLetter</a>(char ch)</td><td style="text-align:center">Character.isLetter(‘a’)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">static char</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Character.html#toLowerCase-char-" target="_blank" rel="noopener">toLowerCase</a>(char ch)</td><td style="text-align:center">Character.toLowerCase(‘A’)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">static String</td><td style="text-align:center">toString(char c)</td><td style="text-align:center">Character.toString(‘a’)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">static boolean</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Character.html#isWhitespace-char-" target="_blank" rel="noopener">isWhitespace</a>(char ch)</td><td style="text-align:center">Character.isWhiteSpace(‘ ‘)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><a id="more"></a> <h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><table><thead><tr><th style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" target="_blank" rel="noopener">String</a>[]</th><th style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#split-java.lang.String-" target="_blank" rel="noopener">split</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" target="_blank" rel="noopener">String</a> regex)</th><th style="text-align:center">str.split(“ “)</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">int</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#indexOf-java.lang.String-" target="_blank" rel="noopener">indexOf</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" target="_blank" rel="noopener">String</a> str or char ch)</td><td style="text-align:center">str.indexOf(“ab”); str.indexOf(‘a’)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">int</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#lastIndexOf-int-" target="_blank" rel="noopener">lastIndexOf</a>(char);  <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#lastIndexOf-int-" target="_blank" rel="noopener">lastIndexOf</a>(String)</td><td style="text-align:center">str.lastIndexOf(‘a’);str.lastIndexOf(“ab”)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">String</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#trim--" target="_blank" rel="noopener">trim</a>()</td><td style="text-align:center">str.trim()</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><table><thead><tr><th>Return</th><th>Method</th><th>Usage</th><th></th></tr></thead><tbody><tr><td>String</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/StringBuilder.html#toString--" target="_blank" rel="noopener">toString</a>()</td><td>sb.toString()</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><table><thead><tr><th>Return</th><th>Method</th><th>Usage</th><th></th></tr></thead><tbody><tr><td>void</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Collections.html#swap-java.util.List-int-int-" target="_blank" rel="noopener">swap</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/util/List.html" target="_blank" rel="noopener">List</a>&lt;?&gt; list, int i, int j)</td><td>Collections.swap(list, i, j)</td><td></td></tr><tr><td>void</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Collections.html#reverse-java.util.List-" target="_blank" rel="noopener">reverse</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/util/List.html" target="_blank" rel="noopener">List</a>&lt;?&gt; list)</td><td>Collections.reverse(list)</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h1><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>Queue<integer> queue = new LinkedList&lt;&gt;();</integer></p><p>​                  |—&gt;不可以为primitive element， 必须是reference element</p><table><thead><tr><th></th><th>Method:  <em>Returns special value</em></th><th>Method:  <em>Throws exception</em></th><th>Descripttion</th></tr></thead><tbody><tr><td></td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html#offer-E-" target="_blank" rel="noopener">offer</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html" target="_blank" rel="noopener">E</a> e)</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html#add-E-" target="_blank" rel="noopener">add</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html" target="_blank" rel="noopener">E</a> e)</td><td></td></tr><tr><td></td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html#poll--" target="_blank" rel="noopener">poll</a>()</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html#remove--" target="_blank" rel="noopener">remove</a>()</td><td>Retrieves and removes the <strong>head of this queue.</strong></td></tr><tr><td></td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html#peek--" target="_blank" rel="noopener">peek</a>()</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html#element--" target="_blank" rel="noopener">element</a>()</td><td></td></tr><tr><td></td><td>isEmpty()</td><td>isEmpty()</td><td></td></tr><tr><td></td><td>size()</td><td>size()</td><td></td></tr><tr><td></td><td>addAll()</td><td>addAll()</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><table><thead><tr><th style="text-align:center">Return</th><th style="text-align:center">Method</th><th style="text-align:center">Usage</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">V</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/HashMap.html#get-java.lang.Object-" target="_blank" rel="noopener">get</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a> key)</td><td style="text-align:center">hashMap.get(key)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">value or default value</td><td style="text-align:center"><u>getOrDefault</u>(Object key, V defaultValue)</td><td style="text-align:center">hashMap.put(key, value)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">put(K key, V value)</td><td style="text-align:center">hashMap.put(key, value)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">containsKey(Object key)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Set&lt;Map.Entry&lt;K, V&gt;&gt;</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/HashMap.html#entrySet--" target="_blank" rel="noopener">entrySet</a>()</td><td style="text-align:center"></td><td style="text-align:center">Returns a <a href="https://docs.oracle.com/javase/9/docs/api/java/util/Set.html" target="_blank" rel="noopener"><code>Set</code></a> view of the mappings contained in this map.</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Sliding Window 总结</title>
      <link href="/2018/05/07/Sliding-Window-%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/07/Sliding-Window-%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="Slide-Window-滑动窗口-Hash"><a href="#Slide-Window-滑动窗口-Hash" class="headerlink" title="Slide Window 滑动窗口 + Hash"></a>Slide Window 滑动窗口 + Hash</h1><h3 id="什么样的题目适合用slide-window"><a href="#什么样的题目适合用slide-window" class="headerlink" title="什么样的题目适合用slide window"></a>什么样的题目适合用slide window</h3><ol><li>找符合某种condition 的subtring </li></ol><p>相似题目：</p><ol><li>Minimum window substring</li><li>Longest Substring without Repeating Characters</li><li>Longest Substring with at most 2 Distinct Characters</li><li>Longest Substring with at most k Distinct Characters</li></ol><a id="more"></a><h4 id="题型：找符合某种condition-的subtring"><a href="#题型：找符合某种condition-的subtring" class="headerlink" title="题型：找符合某种condition 的subtring"></a>题型：找符合某种condition 的subtring</h4><hr><h4 id="LeetCode-3-Longest-Substring-Without-Repeating-Characters"><a href="#LeetCode-3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="LeetCode 3. Longest Substring Without Repeating Characters"></a>LeetCode 3. Longest Substring Without Repeating Characters</h4><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><p><strong>Examples:</strong></p><p>Given <code>&quot;abcabcbb&quot;</code>, the answer is <code>&quot;abc&quot;</code>, which the length is 3.</p><p>Given <code>&quot;bbbbb&quot;</code>, the answer is <code>&quot;b&quot;</code>, with the length of 1.</p><p>Given <code>&quot;pwwkew&quot;</code>, the answer is <code>&quot;wke&quot;</code>, with the length of 3. Note that the answer must be a <strong>substring</strong>, <code>&quot;pwke&quot;</code> is a <em>subsequence</em>and not a substring.</p><p><strong>题目意思： 找符合“no repeat”条件的substring</strong></p><p>技巧摘要： </p><ol><li>Two Pointer （start， i）— 决定substring的长度 len = i - start + 1</li><li>HashMap: 存string中每个character的index， 持续保持更新</li><li>conditional variable： no repeat</li></ol><p>解法一：beat： 31% 用 hashMap： 存char, Latest updated char’s index </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        if(s == null || s.length() == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">        int start = 0; </span><br><span class="line">        int len = 0;</span><br><span class="line">        //hashMap: char, char&apos;s lastes updated index</span><br><span class="line">        </span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; s.length(); i++)&#123;</span><br><span class="line">            if(hashMap.containsKey(s.charAt(i)))&#123;</span><br><span class="line">            //start pointer只能往前走： case： pwwkewp</span><br><span class="line">                start = Math.max(start, hashMap.get(s.charAt(i)) + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新或增加hashMap中的index</span><br><span class="line">            hashMap.put(s.charAt(i), i);</span><br><span class="line">            len = Math.max(len, i - start + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 优化：beat 91% </p><p>与解法一思想一样，只是 用hashtable: </p><p>int[] hash = new int[256];  //最多有256个字符</p><p>initialize foreach hash[i] = -1;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        if(s == null || s.length() == 0)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        //p w e w k e p</span><br><span class="line">        //注意点： start, i 只能forward</span><br><span class="line">        //hash: char : char&apos;s lastest updated index        </span><br><span class="line">        int[] hash = new int[256];</span><br><span class="line">        for(int i = 0; i &lt; 256; i++)</span><br><span class="line">            hash[i] = -1;</span><br><span class="line">        </span><br><span class="line">        int start = 0;</span><br><span class="line">        int max = 0;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; s.length(); i++)&#123;</span><br><span class="line">            if(hash[s.charAt(i)] != -1)&#123;</span><br><span class="line">                start = Math.max(start, hash[s.charAt(i)] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            hash[s.charAt(i)] = i;</span><br><span class="line">            max = Math.max(max, i - start + 1); //i 每往前forward一次, 都要从新计算maxLength</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="159-Longest-Substring-with-At-Most-Two-Distinct-Characters"><a href="#159-Longest-Substring-with-At-Most-Two-Distinct-Characters" class="headerlink" title="159. Longest Substring with At Most Two Distinct Characters"></a>159. Longest Substring with At Most Two Distinct Characters</h4><p>Given a string <strong>s</strong> , find the length of the longest substring <strong>t</strong>  that contains <strong>at most</strong> 2 distinct characters.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;eceba&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: t is &quot;ece&quot; which its length is 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;ccaabbb&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: t is &quot;aabbb&quot; which its length is 5.</span><br></pre></td></tr></table></figure><p>题目意思： 找到符合“at most 2 distinct character” 的Substring</p><p> 和LeetCode 3 类似，难点在于怎么处理contidition variable = “at most 2 distinct character”</p><p>技巧摘要： </p><ol><li>Two Pointer （start， i）— 决定substring的长度 len = i - start + 1</li><li>HashMap: 存string中每个character的index， 持续保持更新</li><li>conditional variable： at most 2 distinct character</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstringTwoDistinct(String s) &#123;</span><br><span class="line">        </span><br><span class="line">        if(s == null || s.length() == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        int start = 0;</span><br><span class="line">        int max = 0;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; s.length(); i++)&#123;</span><br><span class="line">            //处理conditional： at most 2 distinct character</span><br><span class="line">            if(hashMap.size() &lt; 2)&#123;</span><br><span class="line">                hashMap.put(s.charAt(i), i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if(hashMap.size() == 2)&#123;</span><br><span class="line">                if(hashMap.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                    hashMap.put(s.charAt(i), i);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    int leftMost = s.length();</span><br><span class="line">                    for(int num: hashMap.values())&#123;</span><br><span class="line">                        leftMost = Math.min(leftMost, num);</span><br><span class="line">                    &#125;</span><br><span class="line">                    //保证hashMap中元素最多两个</span><br><span class="line">                    hashMap.remove(s.charAt(leftMost));</span><br><span class="line">                    start = leftMost + 1;</span><br><span class="line">                    hashMap.put(s.charAt(i), i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            max = Math.max(max, i - start + 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        return max;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> String </tag>
            
            <tag> Two Pointer </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DFS 模板 + 相关问题</title>
      <link href="/2018/05/07/DFS%E6%A8%A1%E6%9D%BF+%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2018/05/07/DFS%E6%A8%A1%E6%9D%BF+%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="DFS-模板-相关问题"><a href="#DFS-模板-相关问题" class="headerlink" title="DFS 模板 + 相关问题"></a>DFS 模板 + 相关问题</h1><a id="more"></a><h2 id="DFS-BackTracking"><a href="#DFS-BackTracking" class="headerlink" title="DFS + BackTracking"></a>DFS + BackTracking</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void dfs(...) </span><br><span class="line">&#123;</span><br><span class="line">    // Step 1： 结束递归的条件</span><br><span class="line">    if (...) &#123;</span><br><span class="line">        ..... // 把“当前结果” 加入 “结果集容器” 中</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Step 2: 继续递归，里面可能有回溯，也可能没有</span><br><span class="line">    //---used for backtracking： 如果需要回溯， 先保存当前状态</span><br><span class="line">    if (...) &#123;</span><br><span class="line"></span><br><span class="line">        ... // 在容器中保存当前数据</span><br><span class="line">        dfs() </span><br><span class="line">        ... // 在容器中删除上面保存的数据（注：这种情况下就称为回溯，很明显它是dfs的一个步骤）</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //----backtracking如果需要回溯， reset</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###难点</p><ol><li>寻找dfs结束条件</li><li>继续dfs的条件</li></ol><h4 id="79-Word-Search"><a href="#79-Word-Search" class="headerlink" title="79. Word Search"></a>79. Word Search</h4><p>Given a 2D board and a word, find if the word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given word = &quot;ABCCED&quot;, return true.</span><br><span class="line">Given word = &quot;SEE&quot;, return true.</span><br><span class="line">Given word = &quot;ABCB&quot;, return false.</span><br></pre></td></tr></table></figure><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><ol><li><p>遍历board所有cell，因为每个cell都可以作为起点</p></li><li><p>DFS中： 寻找DFS终止条件</p><p>2.1 越界： 该起点不行—&gt;return false</p><p>2.2 当前cell不是我要找的Character： 该起点不行—&gt; return false</p><p>2.3 避开了以上出口条件： 没越界，起点是要找单字， 且是<strong>最后一个单字</strong> —&gt;该起点整句找到， return true</p></li><li><p>如果避开以上， 说明没找到整句，以该坐标为起点， 继续四个方向找Index + 1的单字</p><p>3.1 注意去重：方法一： Mark board； 方法二： 另用一个visited二维数组</p><p>​    3.1.1  尝试4个方向前， mark  该坐标为visited， 记得保存当前状态，作为reset</p></li><li><p>explore 4 direction</p></li><li><p>reset board （backtracking）</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">        </span><br><span class="line">        if(board == null || board.length == 0 || board[0].length == 0 || word == null || word.length() == 0)</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        //尝试所有的cell，记得reset board</span><br><span class="line">        for(int i = 0; i &lt; board.length; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; board[0].length; j++)&#123;</span><br><span class="line">                if(dfsExist(board, word, 0, i, j))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return false;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public boolean dfsExist(char[][] board, String word, int index, int x, int y)&#123;</span><br><span class="line">        if(x &lt; 0 || y &lt; 0 | x &gt;= board.length || y &gt;= board[0].length)</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        if(word.charAt(index) != board[x][y])</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        if(index == word.length() - 1)</span><br><span class="line">            return true;</span><br><span class="line">        </span><br><span class="line">        char tmp = board[x][y]; //保存当前状态，用作以后reset</span><br><span class="line">        board[x][y] = &apos;#&apos;; //mark as visited</span><br><span class="line">        </span><br><span class="line">        boolean res = dfsExist(board, word, index + 1, x, y + 1) || dfsExist(board, word, index + 1, x, y - 1) </span><br><span class="line">            || dfsExist(board, word, index + 1, x + 1,  y ) || dfsExist(board, word, index + 1, x - 1,  y );</span><br><span class="line">        </span><br><span class="line">        board[x][y] = tmp; //backtracking： reset board</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java基础知识总结----集合，框架</title>
      <link href="/2018/05/05/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93----%E9%9B%86%E5%90%88%EF%BC%8C%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/05/05/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93----%E9%9B%86%E5%90%88%EF%BC%8C%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<h1 id="Java基础知识总结—集合，框架"><a href="#Java基础知识总结—集合，框架" class="headerlink" title="Java基础知识总结—集合，框架"></a>Java基础知识总结—集合，框架</h1><p><img src="https://i1.wp.com/javabydeveloper.com/wp-content/uploads/2016/06/Collection-Framework-hierarchy.png" alt="集合，框架"></p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection:"></a>Collection:</h2><h4 id="—List-有序-元素存入集合的顺序和取出的顺序一致-，元素都有索引。元素可以重复。"><a href="#—List-有序-元素存入集合的顺序和取出的顺序一致-，元素都有索引。元素可以重复。" class="headerlink" title="—List: 有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。"></a>—List: 有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。</h4><h4 id="—Set-无序-存入和取出顺序有可能不一致-，不可以存储重复元素。必须保证元素唯一性。"><a href="#—Set-无序-存入和取出顺序有可能不一致-，不可以存储重复元素。必须保证元素唯一性。" class="headerlink" title="—Set: 无序(存入和取出顺序有可能不一致)，不可以存储重复元素。必须保证元素唯一性。"></a>—Set: 无序(存入和取出顺序有可能不一致)，不可以存储重复元素。必须保证元素唯一性。</h4><a id="more"></a><h3 id="常用方法：（增查删改）"><a href="#常用方法：（增查删改）" class="headerlink" title="常用方法：（增查删改）"></a>常用方法：（增查删改）</h3><ul><li>添加：<ul><li>add(object)：添加一个元素</li><li>addAll(Collection) ：添加一个集合中的所有元素。</li></ul></li><li>删除<ul><li>clear()：将集合中的元素全删除，清空集合。</li><li>remove(obj) ：删除集合中指定的对象。注意：删除成功，集合的长度会改变。</li><li>removeAll(collection) ：删除部分元素。部分元素和传入Collection一致。</li></ul></li><li>判断：<ul><li>boolean contains(obj) ：集合中是否包含指定元素 。</li><li>boolean containsAll(Collection) ：集合中是否包含指定的多个元素。</li><li>boolean containsAll(Collection) ：集合中是否包含指定的多个元素。</li></ul></li><li>获取：<ul><li>int size()：集合中有几个元素。</li></ul></li><li>取交集<ul><li>boolean  retainAll(Collection) ：对当前集合中保留和指定集合中的相同的元素。如果两个集合元素相同，返回flase；如果retainAll修改了当前集合，返回true。</li></ul></li><li>获取集合中所有元素<ul><li>Iterator  iterator()：迭代器 </li></ul></li><li>将集合变成数组：<ul><li>toArray(); </li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = coll.iterator();//获取容器中的迭代器对象，至于这个对象是是什么不重要。这对象肯定符合一个规则Iterator接口。</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Collection coll = new ArrayList();</span><br><span class="line"></span><br><span class="line">coll.add(&quot;abc0&quot;);</span><br><span class="line"></span><br><span class="line">coll.add(&quot;abc1&quot;);</span><br><span class="line"></span><br><span class="line">coll.add(&quot;abc2&quot;);</span><br><span class="line"></span><br><span class="line">//--------------方式1----------------------</span><br><span class="line"></span><br><span class="line">Iterator it = coll.iterator();</span><br><span class="line"></span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(it.next());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//---------------方式2用此种----------------------</span><br><span class="line"></span><br><span class="line">for(Iterator it = coll.iterator();it.hasNext(); )&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(it.next());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h4 id="Collection-接口之—-List接口："><a href="#Collection-接口之—-List接口：" class="headerlink" title="Collection 接口之— List接口："></a>Collection 接口之— List接口：</h4><h4 id="List本身是Collection接口的子接口，具备了Collection的所有方法。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。"><a href="#List本身是Collection接口的子接口，具备了Collection的所有方法。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。" class="headerlink" title="List本身是Collection接口的子接口，具备了Collection的所有方法。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。"></a><strong>List本身是Collection接口的子接口，具备了Collection的所有方法</strong>。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。</h4><h4 id="List：有序-元素存入集合的顺序和取出的顺序一致-，元素都有索引。元素可以重复。"><a href="#List：有序-元素存入集合的顺序和取出的顺序一致-，元素都有索引。元素可以重复。" class="headerlink" title="List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。"></a>List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。</h4><p>|–ArrayList：底层的数据结构是数组,线程不同步，ArrayList替代了Vector，查询元素的速度非常快。</p><p>|–LinkedList：底层的数据结构是链表，线程不同步，增删元素的速度非常快。</p><p>|–Vector：底层的数据结构就是数组，线程同步的，Vector无论查询和增删都巨慢。</p><p>1，添加：</p><p>add(index,element) ：在指定的索引位插入元素。</p><p>addAll(index,collection) ：在指定的索引位插入一堆元素。</p><p>2，删除：</p><p>remove(index) ：删除指定索引位的元素。 返回被删的元素。</p><p>3，获取：</p><p>Object get(index) ：通过索引获取指定元素。</p><p><strong>int indexOf(obj) ：</strong>获取指定元素第一次出现的索引位，如果该元素不存在返回-1；</p><p> 所以，通过-1，可以判断一个元素是否存在。</p><p>int lastIndexOf(Object o) ：反向索引指定元素的位置。</p><p>List subList(start,end) ：获取子列表。</p><p>4，修改：</p><p>Object set(index,element) ：对指定索引位进行元素的修改。</p><p>5，获取所有元素：</p><p>ListIterator listIterator()：list集合特有的迭代器。</p><p>List集合支持对元素的增、删、改、查。</p><h4 id="Collection接口之—LinkedList-接口"><a href="#Collection接口之—LinkedList-接口" class="headerlink" title="Collection接口之—LinkedList 接口"></a>Collection接口之—LinkedList 接口</h4><p><strong>LinkedList</strong>：<strong>的特有方法。</strong></p><p>addFirst();</p><p>addLast();</p><p>在jdk1.6以后。</p><p><strong>offerFirst();</strong></p><p><strong>offerLast();</strong></p><p>getFirst():获取链表中的第一个元素。如果链表为空，抛出NoSuchElementException;</p><p>getLast();</p><p>在jdk1.6以后。</p><p><strong>peekFirst();</strong>获取链表中的第一个元素。如果链表为空，返回null。</p><p><strong>peekLast();</strong></p><p>removeFirst()：获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，抛出NoSuchElementException</p><p>removeLast();</p><p>在jdk1.6以后。</p><p><strong>pollFirst();</strong>获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，返回null。</p><p><strong>pollLast();</strong></p><h4 id="Collection接口之—Set接口"><a href="#Collection接口之—Set接口" class="headerlink" title="Collection接口之—Set接口"></a>Collection接口之—Set接口</h4><p>Set接口中的方法和Collection中方法一致的。<strong>Set接口取出方式只有一种，迭代器。</strong></p><p>|–HashSet：底层数据结构是哈希表，线程是不同步的。无序，高效；</p><p>HashSet集合保证元素唯一性：通过元素的hashCode方法，和equals方法完成的。</p><p>当元素的hashCode值相同时，才继续判断元素的equals是否为true。</p><p>如果为true，那么视为相同元素，不存。如果为false，那么存储。</p><p>如果hashCode值不同，那么不判断equals，从而提高对象比较的速度。</p><p>​      |–LinkedHashSet：有序，hashset的子类。</p><p>|–TreeSet：对Set集合中的元素的进行指定顺序的排序。不同步。TreeSet底层的数据结构就是二叉树</p><p>TreeSet:</p><p>用于对Set集合进行元素的指定顺序排序，排序需要依据元素自身具备的比较性。</p><p>如果元素不具备比较性，在运行时会发生ClassCastException异常。</p><p>所以需要元素实现Comparable接口，强制让元素具备比较性，复写compareTo方法。</p><p>依据compareTo方法的返回值，确定元素在TreeSet数据结构中的位置。</p><p>TreeSet方法保证元素唯一性的方式：就是参考比较方法的结果是否为0，如果return 0，视为两个对象重复，不存。</p><p>注意：在进行比较时，如果判断元素不唯一，比如，同姓名，同年龄，才视为同一个人。</p><p>在判断时，需要分主要条件和次要条件，当主要条件相同时，再判断次要条件，按照次要条件排序。</p><p>TreeSet集合排序有两种方式，Comparable和Comparator区别：</p><p>1：让元素自身具备比较性，需要元素对象实现Comparable接口，覆盖compareTo方法。</p><p>2：让集合自身具备比较性，需要定义一个实现了Comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给TreeSet集合的构造函数。</p><p>第二种方式较为灵活。</p><h2 id="Map集合："><a href="#Map集合：" class="headerlink" title="Map集合："></a>Map集合：</h2><h5 id="–Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。"><a href="#–Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。" class="headerlink" title="|–Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。"></a>|–Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。</h5><h4 id="–HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable"><a href="#–HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable" class="headerlink" title="|–HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable."></a>|–HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable.</h4><h4 id="–TreeMap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。"><a href="#–TreeMap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。" class="headerlink" title="|–TreeMap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。"></a>|–TreeMap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。</h4><p>Map集合存储和Collection有着很大不同：</p><p>Collection一次存一个元素；Map一次存一对元素。</p><p>Collection是单列集合；Map是双列集合。</p><p>Map中的存储的一对元素：一个是键，一个是值，键与值之间有对应(映射)关系。</p><p>特点：要保证map集合中键的唯一性。</p><p>1，添加。</p><p> <strong>put</strong>(key,value)：当存储的键相同时，新的值会替换老的值，并将老值返回。如果键没有重复，返回null。</p><p>void putAll(Map);</p><p>2，删除。</p><p>void clear()：清空</p><p>value remove(key) ：删除指定键。</p><p>3，判断。</p><p>boolean <strong>isEmpty</strong>()：</p><p>boolean <strong>containsKey</strong>(key)：是否包含key</p><p>boolean <strong>containsValue</strong>(value) ：是否包含value</p><p>4，取出。</p><p>int size()：返回长度</p><p>value <strong>get</strong>(key) ：通过指定键获取对应的值。如果返回null，可以判断该键不存在。当然有特殊情况，就是在hashmap集合中，是可以存储null键null值的。</p><p>Collection <strong>values</strong>()：获取map集合中的所有的值。</p><p>5，想要获取map中的所有元素：</p><p>原理：map中是没有迭代器的，collection具备迭代器，只要将map集合转成Set集合，可以使用迭代器了。之所以转成set，是因为map集合具备着键的唯一性，其实set集合就来自于map，set集合底层其实用的就是map的方法。</p><p>把map集合转成set的方法：</p><p>Set <strong>keySet</strong>();</p><p>Set <strong>entrySet</strong>();//取的是键和值的映射关系</p><p>Entry就是Map接口中的内部接口；</p><p>为什么要定义在map内部呢？entry是访问键值关系的入口，是map的入口，访问的是map中的键值对。</p><hr><p>取出map集合中所有元素的方式一：keySet()方法。</p><p>可以将map集合中的键都取出存放到set集合中。对set集合进行迭代。迭代完成，再通过get方法对获取到的键进行值的获取。</p><h4 id="使用Collection，-Map的技巧："><a href="#使用Collection，-Map的技巧：" class="headerlink" title="使用Collection， Map的技巧："></a>使用Collection， Map的技巧：</h4><p>看到Array就是数组结构，有角标，查询速度很快。</p><p>看到link就是链表结构：增删速度快，而且有特有方法。addFirst； addLast； removeFirst()； removeLast()； getFirst()；getLast()；</p><p>看到hash就是哈希表，就要想要哈希值，就要想到唯一性，就要想到存入到该结构的中的元素必须覆盖hashCode，equals方法。</p><p>看到tree就是二叉树，就要想到<strong>排序</strong>，就想要用到比较。</p><p>比较的两种方式：</p><p>一个是Comparable：覆盖compareTo方法；</p><p>一个是Comparator：覆盖compare方法。</p><p>LinkedHashSet，LinkedHashMap:这两个集合可以保证哈希表有存入顺序和取出顺序一致，保证哈希表有序</p><p>####集合什么时候用？</p><p>当存储的是一个元素时，就用Collection。当存储对象之间存在着映射关系时，就使用Map集合。</p><p><u>保证唯一，就用Set</u>。不保证唯一，就用List。</p><p>#####Collections：它的出现给集合操作提供了更多的功能。这个类不需要创建对象，内部提供的都是静态方法。</p><p>####Collection 和 Collections的区别：</p><p>Collections是个java.util下的类，是针对集合类的一个<strong>工具类</strong>,提供一系列静态方法,实现对集合的查找、排序、替换、线程安全化（将非同步的集合转换成同步的）等操作。</p><p>Collection是个java.util下的接口，它是各种集合结构的父接口，继承于它的接口主要有Set和List,提供了关于集合的一些操作,如插入、删除、判断一个元素是否其成员、遍历等。</p><p>文章转载自： <a href="http://www.cnblogs.com/bigorangehasc/p/8646091.html" target="_blank" rel="noopener">http://www.cnblogs.com/bigorangehasc/p/8646091.html</a></p>]]></content>
      
      <categories>
          
          <category> LearnJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Typora</title>
      <link href="/2018/05/05/Typora%E9%94%AE%E7%9B%98%E4%BE%A0/"/>
      <url>/2018/05/05/Typora%E9%94%AE%E7%9B%98%E4%BE%A0/</url>
      <content type="html"><![CDATA[<h1 id="Typora-从此请叫我键盘侠"><a href="#Typora-从此请叫我键盘侠" class="headerlink" title="Typora:从此请叫我键盘侠"></a>Typora:从此请叫我键盘侠</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. cd hexoFolder</span><br><span class="line">2. $ hexo new &quot;My New Post&quot;</span><br><span class="line">3. 修改tags和categories</span><br><span class="line">4. 在本地服务器上检测： hexo s --debug</span><br><span class="line">5. 传到GitHub：</span><br><span class="line"></span><br><span class="line"> $hexo g</span><br><span class="line"> $hexo d</span><br><span class="line"> </span><br><span class="line">快捷键大全：</span><br><span class="line"></span><br><span class="line">http://joehill.me/2015/07/27/2015-07-27-Markdown-Typora/</span><br><span class="line"></span><br><span class="line">http://www.flypeom.site/documentation/2017/09/02/Typora%E7%AE%80%E4%BB%8B%E5%8F%8AMarkdown%E8%AF%AD%E6%B3%95%E7%B2%BE%E8%AE%B2/</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LearnJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java</title>
      <link href="/2018/05/05/Java/"/>
      <url>/2018/05/05/Java/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> LearnJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Learn to build personal web</title>
      <link href="/2018/05/05/LeetCode/"/>
      <url>/2018/05/05/LeetCode/</url>
      <content type="html"><![CDATA[<p>我就想随便写点啥</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p></blockquote><figure class="highlight plain"><figcaption><span>_.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="noopener">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.compact([0, 1, false, 2, &apos;&apos;, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LearnJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/05/05/hello-world/"/>
      <url>/2018/05/05/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
