<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Bit Manipulation知识总结</title>
      <link href="/2018/06/12/Bit-Manipulation%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/2018/06/12/Bit-Manipulation%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IBM 面试+ OA</title>
      <link href="/2018/05/29/IBM-%E9%9D%A2%E8%AF%95-OA/"/>
      <url>/2018/05/29/IBM-%E9%9D%A2%E8%AF%95-OA/</url>
      <content type="html"><![CDATA[<h1 id="1-OA-1"><a href="#1-OA-1" class="headerlink" title="1. OA 1"></a>1. OA 1</h1><p>题意： </p><p>Input： String ipt1 = “Frank-&gt;Mary,Mary-&gt;Sam,Mary-&gt;Bob,Sam-&gt;Katie,Sam-&gt;Pete,Bob-&gt;John,Bob,Katie”;</p><p>找到Bob, Katie lowest common Ancestor </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public String getAncestor(String input)&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        String[] strSet = input.split(&quot;,&quot;);</span><br><span class="line">        String target1 = strSet[strSet.length - 2];</span><br><span class="line">        String target2 = strSet[strSet.length - 1];</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; strSet.length - 2; i++)&#123;</span><br><span class="line">            String[] item = strSet[i].split(&quot;-&gt;&quot;);</span><br><span class="line">            String employee = item[1];</span><br><span class="line">            String manager = item[0];</span><br><span class="line">            hashMap.put(employee, manager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        String p1Manager = target1;</span><br><span class="line">        String p2Manager = target2;</span><br><span class="line">        while(hashMap.containsKey(p1Manager) || hashMap.containsKey(p2Manager))&#123;</span><br><span class="line">            if(hashMap.containsKey(p1Manager))&#123;</span><br><span class="line">                p1Manager = hashMap.get(p1Manager);</span><br><span class="line">                if(!hashSet.add(p1Manager)) return p1Manager;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(hashMap.containsKey((p2Manager)))&#123;</span><br><span class="line">                p2Manager = hashMap.get(p2Manager);</span><br><span class="line">                if(!hashSet.add(p2Manager)) return p2Manager;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return &quot;&quot;;//</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>各种sort总结</title>
      <link href="/2018/05/29/%E5%90%84%E7%A7%8Dsort%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/29/%E5%90%84%E7%A7%8Dsort%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="1-Merge-sort"><a href="#1-Merge-sort" class="headerlink" title="1. Merge sort"></a>1. Merge sort</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public int[] mergeSort(int[] nums)&#123;</span><br><span class="line">        //int[] res = &#123;&#125;;</span><br><span class="line">        if(nums == null || nums.length &lt; 2)&#123;</span><br><span class="line">            return nums;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mergeSortHelper(nums, 0, nums.length - 1);</span><br><span class="line"></span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void mergeSortHelper(int[] nums, int i, int j)&#123;</span><br><span class="line"></span><br><span class="line">        if(i &gt;= j) //recursion: 什么时候停止</span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        int left = i;</span><br><span class="line">        int right = j;</span><br><span class="line">        int mid = left + (right - left)/2;</span><br><span class="line">        mergeSortHelper(nums, left, mid);</span><br><span class="line">        mergeSortHelper(nums, mid + 1, right);</span><br><span class="line">        merge(nums, left, mid + 1, right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void merge(int[] nums, int start1, int start2, int end)&#123;</span><br><span class="line">        int[] res = new int[end - start1 + 1]; //踩坑点！！</span><br><span class="line"></span><br><span class="line">        int p1 = start1, p2 = start2;</span><br><span class="line">        int i = 0;</span><br><span class="line">        while(p1 &lt; start2 &amp;&amp; p2 &lt;= end)&#123;</span><br><span class="line">            if(nums[p1] &lt; nums[p2])&#123;</span><br><span class="line">                res[i] = nums[p1];</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res[i] = nums[p2];</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        //post processing</span><br><span class="line">        while(p1 &lt; start2)&#123;</span><br><span class="line">            res[i++] = nums[p1++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(p2 &lt;= end)&#123;</span><br><span class="line">            res[i++] = nums[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int num: res)&#123;</span><br><span class="line">            nums[start1++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>TIme : O(nlogn)</p><p>space: O(n)</p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>String 类型题目总结</title>
      <link href="/2018/05/27/String-%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/27/String-%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="1-remove-one-character-from-string"><a href="#1-remove-one-character-from-string" class="headerlink" title="1. remove one character from string"></a>1. remove one character from string</h2><p>###题目： 删除一个string中u 和 n, 返回一个string？</p><p>常见错误： Java中转化为char[]之后直接调用remove 之类的function， time complexity: O(n), 因为每remove一次，后面的items 都要往前shift</p><h3 id="正确做法："><a href="#正确做法：" class="headerlink" title="正确做法："></a>正确做法：</h3><p>转化成char[]: （挡板思想）使用slow &amp; fast pointers:</p><p><strong>两个挡板， 三个区域，同向而行</strong></p><ul><li>slow: 所有不是’u’ or ‘n’的letter放在slow左边—最后我想return的结果</li><li>fast: 一个遍历器， 碰到非‘u’ or ‘ n’的就copy到i上去—疯狂往前跑的pointer</li></ul><p><img src="http://server.myspace-shack.com/d23/80215e16-54e3-4395-8fe4-00c9126a6da0.png" alt=""></p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public String removeUorN(String str)&#123;</span><br><span class="line">    </span><br><span class="line">    int slow = 0;</span><br><span class="line">    int fast = 0;</span><br><span class="line">    </span><br><span class="line">    char[] chars = str.toCharArray();</span><br><span class="line">    while(j &lt; str.length() &amp;&amp; i &lt; str.length())&#123;</span><br><span class="line">        if(chars[j] == &apos;u&apos; || chars[j] == &apos;n&apos;)</span><br><span class="line">        j++;</span><br><span class="line">        </span><br><span class="line">        swap(chars, i, j);</span><br><span class="line">        i++;</span><br><span class="line">      j++; //一句话： swap(chars, i++, j++);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //!!resize char array to size i</span><br><span class="line">    </span><br><span class="line">    return new String(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p><img src="http://server.myspace-shack.com/d23/70c42c15-8366-47b9-9453-dd9e40ede726.png" alt=""></p><h3 id="2-重点-Char-Removal-Remove-all-leading-trailing-and-duplicate-empty-space-onlu-leave-one-empty-space-if-duplicated-spaces-happen-from-the-input-string"><a href="#2-重点-Char-Removal-Remove-all-leading-trailing-and-duplicate-empty-space-onlu-leave-one-empty-space-if-duplicated-spaces-happen-from-the-input-string" class="headerlink" title="2.重点(Char Removal) Remove all leading/trailing and duplicate empty space (onlu leave one empty space if duplicated spaces happen) from the input string."></a>2.重点(Char Removal) Remove all leading/trailing and duplicate empty space (onlu leave one empty space if duplicated spaces happen) from the input string.</h3><p>input = “_ _ _ abc _ _ ed _ _ ef _ _”;</p><p>output = “abc_ed_ef”;</p><p><strong>思想： （W1) (_ W2) (_ W3) … (_ Wn)</strong></p><p>除了第一个word, 其他的前面都加一个‘空格’</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public String removalSpace(String str)&#123;</span><br><span class="line">    </span><br><span class="line">    char[] chars = str.toCharArray();</span><br><span class="line">    </span><br><span class="line">    int slow = 0;</span><br><span class="line">    int fast = 0;</span><br><span class="line">    int wordCount = 0;//special case for 1st word</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        //1. 处理leading space</span><br><span class="line">        while(fast &lt; str.length()/*重点*/ &amp;&amp; chars[fast] == &apos; &apos;)&#123;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //检查fast有没有越界， or这时候是不是全是space</span><br><span class="line">        if(fast == str.length()) //stop点：删除了头尾space</span><br><span class="line">        break;</span><br><span class="line">        </span><br><span class="line">        //2. 有word：wordCount &gt; 0, 加‘_’</span><br><span class="line">        if(wordCound &gt; 0)</span><br><span class="line">        chars[slow++] = &apos; &apos;;</span><br><span class="line">        </span><br><span class="line">        //3. copy word. 把word 拷贝到i部分</span><br><span class="line">        while(fast &lt; str.length() &amp;&amp; chars[fast] != &apos; &apos;)&#123;</span><br><span class="line">            chars[slow++] = chars[fast++]；</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        wordCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //char array resize to i;</span><br><span class="line">    </span><br><span class="line">    return new String(chars, 0, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Char-De-Duplication"><a href="#2-Char-De-Duplication" class="headerlink" title="2. Char De-Duplication"></a>2. Char De-Duplication</h2><h3 id="2-1-Char-de-duplicaiton"><a href="#2-1-Char-de-duplicaiton" class="headerlink" title="2.1 (Char de-duplicaiton)"></a>2.1 (Char de-duplicaiton)</h3><p>删除重复数字和相邻letter(不同的letter只保留一个)</p><p>E.g:</p><p>String s = “ a a b b _ _ c c” —&gt; “ab_ c”</p><p>​                           s</p><p>​                               f</p><p>还是slow, scanning pointer</p><p><strong>重点是： 什么时候slow pointer 要移动， 每次都和返回值区域slow部分最后一个char比</strong></p><p>s: is the slow/index all letters to the left of s (<strong>including</strong>(excluding) s) should be in final answer</p><p>f: is the fast/current index to scan the string( from left to right)</p><p>代码：</p><ol><li>slow 是<strong>including s</strong>的写法 : 不相等， 先右移s,再赋值</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public String deDuplicate(char[] str)&#123;</span><br><span class="line">    </span><br><span class="line">    int s = 0, f = 0; //重点1</span><br><span class="line">    while(f &lt; str.length)&#123;</span><br><span class="line">        if(str[s] != str[f])&#123; //重点2</span><br><span class="line">            s++; //重点3</span><br><span class="line">            str[s] = str[f];</span><br><span class="line">            f++;</span><br><span class="line">        &#125;else</span><br><span class="line">        f++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return new String(str, 0, s + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>slow 是<strong>excluding s</strong>的写法 （prefer）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public String deDuplicate(char[] str)&#123;</span><br><span class="line">    if(str == null || str.length &lt; 2)</span><br><span class="line">    return new String(str);</span><br><span class="line">    </span><br><span class="line">    int s = 1, f = 1; //重点1.</span><br><span class="line">    while(f &lt; str.length)&#123;</span><br><span class="line">    if(str[s - 1] != str[f])&#123; //重点2</span><br><span class="line">            str[s] = str[f];</span><br><span class="line">            s++;</span><br><span class="line">            f++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            f++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return new String(str, 0, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-（char-de-duplicate-ajacent-letter-Repeatly"><a href="#2-2-（char-de-duplicate-ajacent-letter-Repeatly" class="headerlink" title="2.2 （char de-duplicate ajacent letter Repeatly)"></a>2.2 （char de-duplicate ajacent letter <u>Repeatly</u>)</h3><p>E.g:</p><p>abbbbbaz —&gt; a1-a2z —&gt;z</p><p><strong>用什么样的数据结构可以随时帮助我们找到历史最新的元素</strong>？ stack</p><p><strong>Method 1:</strong>  <strong>显示的</strong>用一个stack —stack 最后保留的return</p><p>类似于以上slow， scanning 思想：</p><ul><li>碰到于Stack顶相同元素： while loop过掉相同元素 + pop栈顶元素 </li><li>不相同： push入栈， scanning++</li></ul><p>—coding trick: 可以用一个动态ArrayList 去模拟一个Stack， 可以利于最后random access 读取</p><p><strong>Method 2:</strong> 通过slow pointer<strong>隐示的</strong>体现一个栈的功能</p><p>主题思想还是类似于slow, scanning 思想 + 用slow pointer 隐示的维护一个Stack</p><p>通过slow–后退（左移）一格来体现Stack pop（）</p><p>​     a b b b b b a z</p><p>​     s</p><p>​                              f</p><h2 id="3-Substring"><a href="#3-Substring" class="headerlink" title="3. Substring"></a>3. Substring</h2><p>Q3: Substring problem: how to determine whether a string is a substring of another string.</p><p>Example:</p><p>​         0 1 2 3 4</p><p>s1 = “a b c d e”     s2 = “c d”</p><p>return index of s2, if not return -1.</p><p>Method 1: 暴力法</p><p>Time Complexity: O(n*m)</p><p>index 0 1 2 3 4</p><p>s1       a b c d e</p><p>​           |</p><p>​            c d</p><p>​                c  d</p><p>​                     c  d</p><p>​                          c  d</p><p>主要思想：以s1中的每一个char为起点， 再和 s2逐字检查， 只要有一个char不match–&gt;跳出，以下一个char为起点再逐字比较，直到和s2完全match为止。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int indexOf(String s1, String s2)&#123;</span><br><span class="line">if(s1 == null || s2 == null)</span><br><span class="line">return -1;</span><br><span class="line"></span><br><span class="line">//比到倒数第二个， 防止越界</span><br><span class="line">//1个letter debug</span><br><span class="line">//for every possible start index of s2</span><br><span class="line">for(int i = 0; i &lt;= s1.length() - s2.length(); i++)&#123;</span><br><span class="line">int j = 0;</span><br><span class="line">for(; j &lt; s2.length(); j++)&#123; //以是s1[i]为起点和s2逐字比较</span><br><span class="line">            if(s1.charAt(i + j) != s2.charAt(j))</span><br><span class="line">            break;</span><br><span class="line">&#125;</span><br><span class="line">if(j == s2.length())</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Method 2: Robin-Karp</p><p>$\textcolor{Red}{自己再做一遍!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!} $ </p><h2 id="4-String-Reversal"><a href="#4-String-Reversal" class="headerlink" title="4. String Reversal"></a>4. String Reversal</h2><h4 id="4-1-String-Reversal"><a href="#4-1-String-Reversal" class="headerlink" title="4.1 String Reversal"></a>4.1 String Reversal</h4><p>apple –&gt; elppa</p><p>i        j</p><p>解法一： iterative</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解法二： Recursion:</p><p><strong>Base Case: 子问题从两边想中间变小， 到只有1个或0个character时。</strong></p><p><strong>Recursion rule: reverseStr(str, i + 1, j - 1);</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//usage: reverseStr(str, 0, length - 1);</span><br><span class="line"></span><br><span class="line">public void reverseStr(String str, int i, int j)&#123;</span><br><span class="line">//base case</span><br><span class="line">if(i &gt;= j)</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">swap(str, i, j);</span><br><span class="line">reverseStr(str, i + 1, j - 1); //recursion rule</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-reverse-string"><a href="#4-2-reverse-string" class="headerlink" title="4.2 reverse string"></a>4.2 reverse string</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I love yahoo ---&gt; yahoo love I</span><br></pre></td></tr></table></figure><p>Method 1: 用Stack</p><p><strong>Method 2： Trick重点！</strong>！</p><ul><li><p>先reverse整个string</p></li><li><p>再按空格reverse每个Word</p></li></ul><h4 id="4-3-Shift-the-string-with-k-steps"><a href="#4-3-Shift-the-string-with-k-steps" class="headerlink" title="4.3 Shift the string with k steps"></a>4.3 Shift the string with k steps</h4><p><strong>abcd ef –&gt; ef abcd</strong> shift the whole string to the right-hand size by two position</p><p><strong>类似I love yahoo的方法reverse 3次</strong></p><ul><li>整个sentence reverse</li><li>按word1 reverse</li><li>按Word2 reverse</li></ul><h3 id="Discussion-4："><a href="#Discussion-4：" class="headerlink" title="Discussion 4："></a>Discussion 4：</h3><ol><li>什么时候回用到“I Love Yahoo” 翻转思想</li></ol><p><strong>一个chunk word不变，只是位置对调了： 翻转2次： 1. 整个翻转，2. 按chunk Word翻转</strong></p><ol><li>“I Love Yahoo” 翻转思想可以用到更多复杂的题目上： eg: String(array) shifting by X chars to the right</li></ol><h3 id="4-Char-Replacement"><a href="#4-Char-Replacement" class="headerlink" title="4. Char Replacement"></a>4. Char Replacement</h3><p>题目：</p><p>String str: stu<strong>den</strong>t </p><p>pattern: den–&gt; <strong>XX</strong></p><p>​        s1         s2</p><p>return: stu<strong>XX</strong>t</p><p>基本思路都是two pointers: slow and scanning</p><p>####<strong>Case 1: if s1.length() &gt;= s2.length()</strong></p><p>step1: find the single occurrence of s1 in the original string,  and jsut replace s1 with s2, until we are done</p><p>####<strong>Case 2: if s1.length() &lt; s2.length()</strong></p><p>“stu<strong>de</strong>nt<strong>de</strong>tstu<strong>de</strong>nt” –&gt; “stu<strong>XXX</strong>nt<strong>XXX</strong>t”</p><p>patthern: de –&gt; XXX</p><p>​                  s1          s2</p><p>how many extra spaces should we get?</p><p>Step1: count how many times s1 show up in original string. for example, 3 times</p><p>step2: extra space:  <strong>3*(s2.length() - s1.length())</strong></p><p>Step3: slow, scanning pointers. (<strong>特殊点： slow, scanning是从后往前)</strong></p><p>s t u d e n t d e t s t u d e n t _ _ _</p><p>​                                                         s</p><p>​                                                          f</p><p><strong>slow(s): all letter to the right side of slow pointers are the results we want to return</strong></p><h1 id="Advanced-Topic-String"><a href="#Advanced-Topic-String" class="headerlink" title="Advanced Topic(String)"></a>Advanced Topic(String)</h1><p>##常见题型及变种： </p><h3 id="1-Shuffling-e-g-ABCD1234-–-gt-A1B2C3D4"><a href="#1-Shuffling-e-g-ABCD1234-–-gt-A1B2C3D4" class="headerlink" title="1. Shuffling e.g: ABCD1234 –&gt; A1B2C3D4"></a>1. Shuffling e.g: ABCD1234 –&gt; A1B2C3D4</h3><h3 id="2-Permutation-use-DFS"><a href="#2-Permutation-use-DFS" class="headerlink" title="2. Permutation(use DFS)"></a>2. Permutation(use DFS)</h3><h3 id="3-Decoding-encoding-aaaabcc-–-gt-a4b1c2-Run-length-encode"><a href="#3-Decoding-encoding-aaaabcc-–-gt-a4b1c2-Run-length-encode" class="headerlink" title="3. Decoding/encoding aaaabcc –&gt; a4b1c2 (Run length encode)"></a>3. Decoding/encoding aaaabcc –&gt; a4b1c2 (Run length encode)</h3><h3 id="4-Sliding-windows-using-slow-fast-pointers"><a href="#4-Sliding-windows-using-slow-fast-pointers" class="headerlink" title="4. Sliding windows using slow/fast pointers"></a>4. Sliding windows using slow/fast pointers</h3><h4 id="4-1-Longest-substring-that-contains-only-unique-chars-abcda"><a href="#4-1-Longest-substring-that-contains-only-unique-chars-abcda" class="headerlink" title="4.1 Longest substring that contains only unique chars:  abcda"></a>4.1 Longest substring that contains only unique chars:  <u>abcd</u>a</h4><h2 id="题型1：-String-Shuffling"><a href="#题型1：-String-Shuffling" class="headerlink" title="题型1： String Shuffling"></a>题型1： String Shuffling</h2><h4 id="1-1-First-Direction-“A1B2C3D4E5”-—-gt-“ABCDE12345”-小—-gt-大"><a href="#1-1-First-Direction-“A1B2C3D4E5”-—-gt-“ABCDE12345”-小—-gt-大" class="headerlink" title="1.1 First Direction: “A1B2C3D4E5” —&gt; “ABCDE12345”  小—&gt;大"></a>1.1 First Direction: “A1B2C3D4E5” —&gt; “ABCDE12345”  小—&gt;大</h4><p>类似<strong>Merge Sort</strong></p><p>​                      l                              r</p><p>​                        A1B2C       3D4E5</p><p>​                   /          \          /         \                              Divide array into two subarray</p><p>​                 A1B       2C     3D4      E5</p><p>​                 /        \     /   \     /  \      /  \</p><p>​              A1       B   2    C  3  D4   E    5</p><p>​          /        \        /      /    /    /   /\    /     /      unitl cannot divide</p><p>​        A          1    B       2   C   3  D  4  E  5</p><p>=====================================</p><p>​             A1         B2      C3    D4        E5</p><p>​                 AB12        CD34        E5</p><p>​                       ABCD1234          E5                         merge <strong>two sorted arrays</strong></p><p>​                               ABCDE12345</p><p>merge 的时候需要写一下<strong>comparator</strong>: 字母比数字小， 字母和字母比按alphabetic 顺序， 数字按从小到大顺序</p><h4 id="1-2-Second-Direction-“ABCD12345”-—-gt-“A1B2C3D4E5”"><a href="#1-2-Second-Direction-“ABCD12345”-—-gt-“A1B2C3D4E5”" class="headerlink" title="1.2 Second Direction: “ABCD12345” —&gt; “A1B2C3D4E5”"></a>1.2 Second Direction: “ABCD12345” —&gt; “A1B2C3D4E5”</h4><p>类似reverse merge Sort的思想：</p><p>​         A1       B2        C3      D4</p><p>​            AB12          CD34</p><p>​             AB|CD|12|34</p><p>​     <u>chunk 1  2     3     4</u></p><p><strong>重点： guarantee size of chunk 1 == chunk 3</strong></p><p>​                A B C| <strong>D E F G</strong> |1 2 3| <strong>4 5 6 7</strong></p><p>index      0 1 2 |3  4 5 6 |7 8  9  |0 1 2 3</p><p>​                            <strong>lm</strong>           <strong>m</strong>          <strong>rm</strong> </p><p><strong>关键问题：注意n/2 == 7 == 奇数情况</strong></p><p><img src="http://server.myspace-shack.com/d23/52f789b9-3f02-4eea-83b7-6722d14cf90c.png" alt=""></p><p>重点公式！！！！</p><blockquote><p>size = 14</p><p>mid = left + size/2 = 7</p><p>leftmid = left + (1/4)*size = 3</p><p>rightmid = left + (3/4)*size = 10</p></blockquote><h4 id="代码很重要！！："><a href="#代码很重要！！：" class="headerlink" title="代码很重要！！："></a>代码很重要！！：</h4><p><img src="http://server.myspace-shack.com/d23/4c1b5d3f-00ca-4c6f-8221-7996fe08aa59.png" alt=""></p><h2 id="题型二：-String-Permutation-（DFS经典例题"><a href="#题型二：-String-Permutation-（DFS经典例题" class="headerlink" title="题型二： String Permutation （DFS经典例题)"></a>题型二： String Permutation （DFS经典例题)</h2><h4 id="2-1-no-duplicate-letters-in-input-string-LeetCode-46-Permutaiton"><a href="#2-1-no-duplicate-letters-in-input-string-LeetCode-46-Permutaiton" class="headerlink" title="2.1 no duplicate letters in input string (LeetCode 46 Permutaiton)"></a>2.1 no duplicate letters in input string (LeetCode 46 Permutaiton)</h4><p>E.g. </p><p><strong>input</strong>: “abc”</p><p><strong>output</strong>: </p><p>[ “aab”,</p><p>   “aba”,</p><p>   “baa”]</p><p>####2.1 Input string with duplicate (LeetCode 47 Permutation II)</p><h2 id="题型三：-String-En-Decoding"><a href="#题型三：-String-En-Decoding" class="headerlink" title="题型三： String En/Decoding"></a>题型三： String En/Decoding</h2><p>E.g. </p><p>“aaaabccaaaaa” ——&gt; “a4b1c2a5”  <strong>Restriciton: In-Place</strong></p><p>思路： Two Pointers: slow, fast</p><p>两种情况：</p><p>case 1: input.length &gt; output.length </p><p>case 2: input.length &lt; output.length</p><p>怎么样去综合处理？</p><p>分两步走：</p><p>Step1: </p><p>Step 2:</p><p>?????????没懂one more time  </p><p>$\textcolor{Red}{没懂啊没懂啊!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!} $ </p><p>//1: 30</p><h2 id="题型四：-Sliding-Window-in-a-String-slow-fast-indices"><a href="#题型四：-Sliding-Window-in-a-String-slow-fast-indices" class="headerlink" title="题型四： Sliding Window in a String (slow + fast indices)"></a>题型四： Sliding Window in a String (slow + fast indices)</h2><p>XXXXX<strong>XXXXXXXXXXX</strong>XXXXXXXXXXXXXXXXX</p><p>​           =============</p><p>​            L                         R</p><p>​                       ‘A ‘           counter(滑动窗口内‘A’ 的个数)</p><p>  hashMap&lt;Character, Integer&gt;</p><p>普及： <strong>Sliding Window  + 配套hashMap</strong>(count 窗口内每个char出现几次) + global-mx:</p><ul><li>定长</li><li>不定长</li></ul><h4 id="4-1-Longest-Substring-that-contains-only-unique-char"><a href="#4-1-Longest-Substring-that-contains-only-unique-char" class="headerlink" title="4.1 Longest Substring that contains only unique char"></a>4.1 Longest Substring that contains only unique char</h4><p>Given a string, return the length of the <strong>longest substring</strong> <strong>wihtout dupilcate character</strong>. </p><p>For Example, the longest substring wihtout repeating charater for “<strong>BDEFGA</strong>DE” is “<strong>BDEFGA</strong>“, whose size is 6.</p><p><strong>此类型题目有各种变种： (Follow-Up: that with duplicate characters at most k times. eg k = 5)</strong></p><p>分析该题： without repeating letters———&gt; <strong>k = 1</strong></p><ul><li>sliding window 中的每个character不会超过k 次</li></ul><p>idx: 0  1  2 3 4  5 6  7</p><p>E.g: <strong>B D’ E F G A </strong>D’ E                          k = 1</p><p>​                    ========</p><p>​                    L</p><p>​                                    R</p><p><strong>hashMap&lt;char</strong>, int&gt;</p><p>​                     B       0     </p><p>​                     D       1      <strong>&gt;k</strong>      <strong>开始移动L， 直到D == 1</strong> ;–&gt; D == K—&gt;R开始滑动</p><p>​             E        2     没&gt; k  —&gt; &gt; k <strong>开始移动L， 直到E == 1</strong>  –&gt;  D ==k —&gt;R开始滑动</p><p>​                     F        1      <strong>没&gt; k</strong></p><p>​             G        1    没 &gt; k</p><pre><code>A         1   没 &gt; k</code></pre><p><strong>global_max</strong> = l - r + 1 = 6</p><blockquote><p><strong>Move R</strong>: add更新hashMap + 检查当前‘A’&lt;= k  –&gt; 更新global_max</p><p>​                                                            ‘A’ &gt;k     —&gt;移动L</p><p><strong>Move L:</strong> delete更新hashMap， 直到‘A’ == k —&gt; 移动R</p></blockquote><p>####<strong>Critical points</strong> for review:</p><blockquote><p>We must maintain a hash_table that reflects the <strong>real-time</strong> information about the elements within the sliding window:</p><p>When we <strong>move the R border</strong>, we <strong>add</strong> the information to the hash_table, </p><p>When we <strong>move the L border</strong>, we <strong>delete</strong> information from the hash_table</p></blockquote><p>什么时候可以移动R？只要当前hashMap内当前‘A’‘’s counter &gt;k</p><h3 id="代码：重点！重点！重点！"><a href="#代码：重点！重点！重点！" class="headerlink" title="代码：重点！重点！重点！"></a>代码：重点！重点！重点！</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">String LongestSubstrW/oDup(String input)&#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">    int left = 0, right = 0;   //sliding window</span><br><span class="line">    int global_max = 0;</span><br><span class="line">    int start = 0, end = 0; //record the start and end index of the solution</span><br><span class="line">    </span><br><span class="line">    char[] chars = input.toCharArray();</span><br><span class="line">    while(right &lt; chars.length())&#123;//Move R: add更新当前’A‘to hash_table</span><br><span class="line">        hashMap.put(chars[right], hashMap.getOrDefault(chars[fast], 0) + 1);</span><br><span class="line">        </span><br><span class="line">        //检查当前’A‘是否 &gt; k</span><br><span class="line">        if(hashMap.get(chars[fast]) &gt; 1)&#123;</span><br><span class="line">        //move L: delete 更新hashMap, until &apos;A&apos; == k</span><br><span class="line">        while(hashMap.get(chars[fast]) &gt; 1)&#123;</span><br><span class="line">                hashMap.put(chars[left], hashMap.get(chars[left]) - 1);</span><br><span class="line">                left++;</span><br><span class="line">        &#125;   </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //移动R没有造成duplicate---&gt; update global_max</span><br><span class="line">            //global_max = Math.max(global_max, (right - left) + 1);</span><br><span class="line">            if(right - left + 1&gt; global_max)&#123;</span><br><span class="line">                global_max = right - left + 1;</span><br><span class="line">                start = slow;</span><br><span class="line">                end = fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right++; //第一步就要记得写</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return input.substring(start, end + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####LeetCode 340. Longest Substring with At Most K Distinct Characters</p><h4 id="substring-问题经典模板："><a href="#substring-问题经典模板：" class="headerlink" title="- substring 问题经典模板："></a>- substring 问题经典模板：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstringKDistinct(String s, int k) &#123;</span><br><span class="line">        </span><br><span class="line">        /*</span><br><span class="line">        sliding window: left, right pointers</span><br><span class="line">        hashMap&lt;character, integer&gt;: char, counter of the char</span><br><span class="line">        什么时候更新counter是重点哦， 根据题意</span><br><span class="line">        counter（状态条件）: # of distinct characters in sliding window--&gt; map[right] == 1 counter++; update + map[left] == 0 counter--</span><br><span class="line">        global_max: result</span><br><span class="line">        </span><br><span class="line">        */</span><br><span class="line">        </span><br><span class="line">        if(s ==  null || s.length() == 0 || k == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">        int left = 0, right = 0, counter = 0, global_max = 0;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        while(right &lt; s.length())&#123;</span><br><span class="line">            //move right until counter &gt; k</span><br><span class="line">            char ch = s.charAt(right);</span><br><span class="line">            hashMap.put(ch, hashMap.getOrDefault(ch, 0) + 1);</span><br><span class="line">            if(hashMap.get(ch) == 1)</span><br><span class="line">                counter++; //new char</span><br><span class="line">            </span><br><span class="line">            //move left when counter &gt; k</span><br><span class="line">            while(counter &gt; k)&#123;</span><br><span class="line">                char c = s.charAt(left);</span><br><span class="line">                hashMap.put(c, hashMap.get(c) - 1);</span><br><span class="line">                if(hashMap.get(c) == 0)</span><br><span class="line">                    counter--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //re-cal global_max</span><br><span class="line">            global_max = Math.max(global_max, right - left + 1);</span><br><span class="line">            </span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return global_max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有substring 问题的总结：</p><p><a href="https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/49708/Sliding-Window-algorithm-template-to-solve-all-the-Leetcode-substring-search-problem" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/49708/Sliding-Window-algorithm-template-to-solve-all-the-Leetcode-substring-search-problem</a>.</p><ol><li>LeetCode 3. Longest Substring Without Repeating Characters</li><li>Leetcode 159. Longest Substring with At Most Two Distinct Characters</li><li>LeetCode 340. Longest Substring with At Most K Distinct Characters</li><li>LeetCode 424. Longest Repeating Character Replacement (4.1的马甲题)</li></ol><h4 id="4-2-Find-all-Anagrams-of-a-substring-S2-in-a-long-string-S1"><a href="#4-2-Find-all-Anagrams-of-a-substring-S2-in-a-long-string-S1" class="headerlink" title="4.2 Find all Anagrams of a substring S2 in a long string S1"></a>4.2 Find all <u>Anagrams</u> of a substring S2 in a long string S1</h4><p>anagram: 同形异构</p><p>String s2 = “aabc”;</p><p>​            s1 = “zzzzcde<strong>bcaa</strong>bcyywwww”</p><p>思考过程： 要在s1中找到s2的anagram， 我们需要分析一下anagram的定义—solution 需要和pattern s2有相同的长度， 在这个段长度内且每个character的数量要一样——&gt; hash_table代表每次loop到的区间， <strong>这个区间还需要</strong>match到的character types数量和每个character’s count数量</p><ul><li><strong>我们只关注在hashMap中pattern要match的characters</strong></li><li>Sliding window 定长， window每次移动都是出一个，再进一个</li><li>window的每一次（进/出）移动都要判断(L/R) character 是否在hash_table中</li></ul><p>E.g:</p><p>   a a b c</p><p>   z z z z c d e <strong>b c a a </strong>b c y y w w w w</p><p>​                                            =====</p><p>​                                            l  </p><p>​                                                       r</p><p>HashMap&lt;char, int&gt; <strong>hashMap</strong>  real-time 更新window 内还需要match information</p><p>​                     <strong>a</strong>       2 - 1 = 1 - 1 = 0 + 1 + 1 = 2 -&gt; update unmatched </p><p>​                     <strong>b</strong>       1-1 = 0 - 1 + 1 = 0  + 1 = 1–&gt; update unmatched </p><p>​                     <strong>c</strong>        1- 1 = 0 + 1 - 1 = 0 + 1-&gt; update unmatched                 </p><p>​           <strong>types_of_letter_still_need_to_balance</strong> = 3 - 1 = 2 - 1 = 1 - 1 = 0 –&gt; one solution (l, r)</p><p>​                                c from 1 to 0                                                    –.&gt; 0 second solution (l’, r’)</p><p>​                                a from 1 to 0                              —&gt; 0 third solution (l’’, r’’)</p><p>​                                a from 0 to 1                                                    = 1</p><pre><code>b from 0 to 1                               = 1+ 1</code></pre><p>​                                c from 0 to 1                                        = 1 + 1 +1</p><p>Time: O(N)</p><p>以上是初始化pattern.length() —L = 0, R = pattern.length() - 1</p><p>写法二： left = 0, right = 0;</p><p>   a a b c</p><p>   z z z z c d e <strong>b c a a </strong>b c y y w w w w</p><p>​                           ====</p><p>​                           L</p><p>​                                  R</p><p>HashMap&lt;Character, Integer&gt;</p><p>​            a             2 -1 -1= 0</p><p>​                        b          1 - 1= 0 + 1 = 1</p><p>​            c         1 - 1= 0 - 1= -1+ 1 = 0</p><p>​                         unmatched_counter = 3 - 1= 2 - 1 = 1 - 1= 0 + 1</p><p>####Anagrams of Substring 第一次总结</p><ol><li><p>思路还是substring固有的sliding window(L, R pointers)解法</p></li><li><p>Anagrams(同形异构)： 保证result’s length = pattern’s length &amp;&amp; result’s elements = pattern’s elements</p><ul><li><u><strong>定长</strong>的Sliding window</u>: intialize 为 pattern’s length</li><li><strong>hashMap&lt;</strong>char, int&gt;: pattern’s character: how many # of the character does the window need to match?</li><li><strong>global_counter:</strong> how many types of characters do we still need to match?</li></ul></li><li><p>window 的每次定长移动都伴随着L, R的character的进出， 要在hash_table 里的character要做相应的增/减</p></li></ol><p>   $\textcolor{Red}{没懂啊没懂啊!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!} $ </p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><p>###4.3 Given a 0-1 array, you can flip at most k ‘0’s to ‘1’s. Please find the longest subarray that consists of all ‘1’s; </p><p>题型转化：</p><p>我们最终要找到一个<strong><u>longest subarray</u> with at most k ‘0’</strong> , 就变成了sliding window 的变种</p><p><strong>4.1 的变形题！！！</strong></p><p>！！！！做题时必须明白的重点：</p><ul><li>when to move R border:  when ‘0’ in sliding window &lt;=4</li><li>when to move L border:  when ‘0’ in sliding window &gt; 4</li></ul><h4 id="LeetCode-424-Longest-Repeating-Character-Replacement"><a href="#LeetCode-424-Longest-Repeating-Character-Replacement" class="headerlink" title="LeetCode 424. Longest Repeating Character Replacement"></a>LeetCode 424. Longest Repeating Character Replacement</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public int characterReplacement(String s, int k) &#123;</span><br><span class="line">        </span><br><span class="line">        if(s == null || s.length() == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">        int left = 0, right = 0, maxOcInWindow = 0, max_len = 0;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        while(right &lt; s.length())&#123;</span><br><span class="line">            </span><br><span class="line">            //moving right pointer forward and re-cal mostOC in sliding window(max = Math.max(max, hashMap[right]))</span><br><span class="line">            char ch = s.charAt(right);</span><br><span class="line">            hashMap.put(ch, hashMap.getOrDefault(ch, 0) + 1);</span><br><span class="line">            maxOcInWindow = Math.max(maxOcInWindow, hashMap.get(ch));  //重点哦！</span><br><span class="line">            </span><br><span class="line">            //moving left as (right - left + 1 - maxOC &gt; k)    --&gt; get possible answers</span><br><span class="line">            while(right - left + 1 - maxOcInWindow &gt; k)&#123;  //什么时候移动left？ 重点哦</span><br><span class="line">                char c = s.charAt(left);</span><br><span class="line">                hashMap.put(c, hashMap.get(c) - 1);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            //3. re-cal max_len</span><br><span class="line">            max_len = Math.max(max_len, right - left + 1);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return max_len;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="String-第一次题型总结："><a href="#String-第一次题型总结：" class="headerlink" title="String 第一次题型总结："></a>String 第一次题型总结：</h1><h3 id="常见技巧："><a href="#常见技巧：" class="headerlink" title="常见技巧："></a><strong>常见技巧</strong>：</h3><ol><li><p><strong>Two pointers</strong>: slow, fast(scanning)</p><p><strong>主要思想： slow左边或右边所有元素就是我们要return result</strong></p><ul><li>同向而行 from left to right ——&gt;s    ——&gt;f</li><li>同向 from right to left:  f&lt;———    s&lt;———-</li><li>相向而行： ———&gt; l       r &lt;———–</li></ul><p><strong>coding 注意点：</strong> 记得检查是否要做post processing!</p></li><li><p><strong>“I LOVE YAHOO” 翻转</strong>2次题型： <u>“W1|W2|W3”—&gt; “W3|W2|W1”</u></p><p>主要思想： input和output 的 chunk Word一样， 相对位置不一样时， 可以用</p></li><li><p><strong>顺序Merge Sort</strong>， 和 <strong>Reverse Merge Sort</strong>类似思想</p><p>Merge Sort回顾</p><ul><li><p>先不断二分下去</p></li><li><p>在以某种方式merge</p></li></ul></li></ol><p>   3.1 顺序merge sort (A1B2C3D4   ——&gt;  ABCD1234 (sorted))</p><p>   和Merge Sort基本一样, merge时候需要改变一下comparator 的方式</p><p>   3.2 Reverse Merge Sort  (ABCD1234(sorted)  ——&gt; A1B2C3D4)</p><ul><li>先画画 merge sort recursion tree的下半部分， 找规律</li><li>分成4个chunks时， 保证size of chunk 1 == size of chunk2</li><li>—“I LOVE YAHOO” 翻转思想</li><li>解决更小的子问题 recursion rule</li></ul><ol start="4"><li><p><strong>DFS</strong> （找到<strong>所有的</strong>String permutation）</p></li><li><p>String Compression 的问题（注意压缩后的str可能比原string长）—&gt;$\textcolor{Red}{有一个通用解法！还不会!!}$</p></li><li><p><strong>Sliding Window</strong> （解决substring 一类的问题及变种问题）重点哦^_^</p><ul><li><p>配套设施：(按照题意： sliding window 有 <strong>定长/不定长</strong> 之分)</p><ul><li>Two Pointers (L, R) —— Sliding Window</li><li>Hash_table —— record <strong><u>real-time</u> information <u>that we care</u></strong> in sliding window</li><li>global_max/global_min</li></ul></li><li><p>做Sliding Window题， 心中要问自己：</p><ul><li>sliding window 定长/不定长？</li><li>sliding window (L/R) 起点？</li><li><strong>hash_table 中存的什么数据以及它们的物理意义？</strong></li><li><strong>什么时候移动 L pointer?</strong></li><li><strong>什么时候移动 R pointer?</strong></li><li>根据题意counter（状态条件）是什么？</li></ul></li><li><p>记住两个？经典模板！！！(LeetCode 340. Longest Substring with At Most K Distinct Characters)</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//LeetCode 340. Longest Substring with At Most K Distinct Characters</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstringKDistinct(String s, int k) &#123;</span><br><span class="line">        </span><br><span class="line">        /*</span><br><span class="line">        sliding window: left, right pointers</span><br><span class="line">        hashMap&lt;character, integer&gt;: char, counter of the char</span><br><span class="line">        什么时候更新counter是重点哦， 根据题意</span><br><span class="line">        counter（状态条件）: # of distinct characters in sliding window--&gt; map[right] == 1 counter++; update + map[left] == 0 counter--</span><br><span class="line">        global_max: result</span><br><span class="line">        </span><br><span class="line">        */</span><br><span class="line">        </span><br><span class="line">        if(s ==  null || s.length() == 0 || k == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">        int left = 0, right = 0, counter = 0, global_max = 0;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        while(right &lt; s.length())&#123;</span><br><span class="line">            //move right until counter &gt; k</span><br><span class="line">            char ch = s.charAt(right);</span><br><span class="line">            hashMap.put(ch, hashMap.getOrDefault(ch, 0) + 1);</span><br><span class="line">            if(hashMap.get(ch) == 1)</span><br><span class="line">                counter++; //new char</span><br><span class="line">            </span><br><span class="line">            //move left when counter &gt; k</span><br><span class="line">            while(counter &gt; k)&#123;</span><br><span class="line">                char c = s.charAt(left);</span><br><span class="line">                hashMap.put(c, hashMap.get(c) - 1);</span><br><span class="line">                if(hashMap.get(c) == 0)</span><br><span class="line">                    counter--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //计算结果： re-cal global_max</span><br><span class="line">            global_max = Math.max(global_max, right - left + 1);</span><br><span class="line">            </span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return global_max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://blog.csdn.net/yy254117440/article/details/53025142" target="_blank" rel="noopener">https://blog.csdn.net/yy254117440/article/details/53025142</a></p></li><li><p>sliding window 中match Pattern 的题型（hashMap存的是P, counter 是window需要match P中还需要字符种类）</p><ul><li>LeetCode 76. Minimum Window Substring （H)经典题目</li><li>LeetCode 438. Find All Anagrams in a String （E)难难难！和上题结合看</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public String minWindow(String s, String t) &#123;</span><br><span class="line">        </span><br><span class="line">        if(s == null || s.length() == 0)</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        </span><br><span class="line">        if(t.length() &gt; s.length()) //Corner case 1: t.length() &gt; s.length()</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        </span><br><span class="line">        int left = 0, right = 0;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        int counter = 0;</span><br><span class="line">        int min_len = Integer.MAX_VALUE; //这里又错了！！！</span><br><span class="line">        int minStart = 0, minEnd = 0;</span><br><span class="line">        </span><br><span class="line">        //1. 初始化 hashMap by Pattern</span><br><span class="line">        char[] chars = t.toCharArray();</span><br><span class="line">        for(char c: chars)&#123;</span><br><span class="line">            hashMap.put(c, hashMap.getOrDefault(c, 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //counter: window还要match pattern中的字符种类数</span><br><span class="line">        counter = hashMap.size();</span><br><span class="line">        </span><br><span class="line">        //scan S to match the requirement in hashMap about T</span><br><span class="line">        while(right &lt; s.length())&#123;</span><br><span class="line">            char ch = s.charAt(right);</span><br><span class="line">            if(hashMap.containsKey(ch))&#123;</span><br><span class="line">                hashMap.put(ch, hashMap.get(ch) - 1);</span><br><span class="line">                if(hashMap.get(ch) == 0)&#123;</span><br><span class="line">                    counter--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //moving left</span><br><span class="line">            while(counter == 0)&#123; //可能出现结果的地方</span><br><span class="line">                //计算结果： min/max or add new result or re-cal min-window</span><br><span class="line">                char lchar = s.charAt(left);</span><br><span class="line">                if(right - left + 1 &lt; min_len)&#123;</span><br><span class="line">                    min_len = right - left + 1;</span><br><span class="line">                    minStart = left;</span><br><span class="line">                    minEnd = right;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                //check the condional variable, # of types requires</span><br><span class="line">                if(hashMap.containsKey(lchar))&#123;  //只有在T hashMap中的才需要更新</span><br><span class="line">                    if(hashMap.get(lchar) == 0)</span><br><span class="line">                        counter++;</span><br><span class="line">                    //update hashMap</span><br><span class="line">                    hashMap.put(lchar, hashMap.get(lchar) + 1);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(min_len == Integer.MAX_VALUE)  //Corner case 2: s = &quot;abcd&quot; t = &quot;mmm&quot; 踩坑点！！！！！！又错了</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        else</span><br><span class="line">            return s.substring(minStart, minEnd + 1);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>常见题型：</p><p>LeetCode 443. String Compression (In-place, Two Pointers, copy char + copy count)</p><p>LeetCode 38. Count and Say (非In-Place 模板： i == str.length - 1 || str[i] != str[i + 1] )</p><hr><p>Map Reduce基本原理：以某种方式把jobs尽量均衡平衡的分布到每个mapper（slaves)机器上去。</p><p>reducer: intergation/aggregation:把最后的结果集成下来且保证正确性</p><p>什么时候用到map reduce: 一台机器搞不定运算， assume 1000 pcs to solve this problems.</p><ol><li><p>you need to understand the <strong>Distribution of data</strong> by performing <strong>Sampling</strong> to the data.</p></li><li><p>Mapper: relatively independently to solve the problem</p></li></ol><ol start="2"><li>Reducer:</li></ol><h1 id="Substring-问题的模板？？？"><a href="#Substring-问题的模板？？？" class="headerlink" title="Substring 问题的模板？？？"></a>Substring 问题的模板？？？</h1><p>XOR问题？？？</p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图的搜索</title>
      <link href="/2018/05/22/%E5%9B%BE%E7%9A%84%E6%90%9C%E7%B4%A2/"/>
      <url>/2018/05/22/%E5%9B%BE%E7%9A%84%E6%90%9C%E7%B4%A2/</url>
      <content type="html"><![CDATA[<h1 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h1><h2 id="Graph-representation"><a href="#Graph-representation" class="headerlink" title="Graph representation"></a>Graph representation</h2><h3 id="1-Ajacent-Matrix"><a href="#1-Ajacent-Matrix" class="headerlink" title="1. Ajacent Matrix"></a>1. Ajacent Matrix</h3><h3 id="2-Ajacent-List"><a href="#2-Ajacent-List" class="headerlink" title="2. Ajacent List"></a>2. Ajacent List</h3><h3 id="3-Ajacent-HashTable-hashMap-hashSet-重点"><a href="#3-Ajacent-HashTable-hashMap-hashSet-重点" class="headerlink" title="3. Ajacent HashTable(hashMap, hashSet)重点"></a>3. Ajacent HashTable(hashMap, hashSet)重点</h3><h2 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS-1"></a>BFS-1</h2><p><strong>按照start node(nodes), 按照一步以外的一圈走完之后，再以两步以外的一圈走完。。。一步一步往外走，直到queue为空</strong></p><h2 id="BFS-1-1"><a href="#BFS-1-1" class="headerlink" title="BFS-1"></a>BFS-1</h2><p>###BFS-1代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void bfs1(Node root)&#123;</span><br><span class="line">    if(root == null)</span><br><span class="line">    return;</span><br><span class="line">    </span><br><span class="line">    Queue&lt;Node&gt; q = new LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    while(!q.isEmpty())&#123;</span><br><span class="line">    //重点： 分层遍历， 在所有操作前， 记录size</span><br><span class="line">        int size = q.size();</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; size; i++)&#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            if(cur.left != null)</span><br><span class="line">            q.offer(cur.left);</span><br><span class="line">            if(cur.right != null)</span><br><span class="line">            q.offer(cur.right);</span><br><span class="line">            </span><br><span class="line">            Sysytem.out.print(cut.val + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常考题型"><a href="#常考题型" class="headerlink" title="常考题型"></a>常考题型</h3><ol><li><p>分层遍历： int size = queue.size()</p></li><li><p>Bipartile: 分组(u, v)， 如果同一个结点既背分到u group，后来又被分到v group，肯定不是bipartile</p><p>1(u) —— 2(v)</p><p>​    \     /</p><p>​    3(v != u)</p></li><li><p>determine a binary tree is a <strong>complete binary tree</strong>: 判断同层是否有气泡</p></li></ol><h3 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h3><h4 id="1-什么时候用BFS-1"><a href="#1-什么时候用BFS-1" class="headerlink" title="1. 什么时候用BFS-1"></a>1. 什么时候用BFS-1</h4><p>Tree Problem + <strong>考虑到<u><em>同层关系</em></u>时</strong>。</p><h2 id="Best-First-Search-BFS-2"><a href="#Best-First-Search-BFS-2" class="headerlink" title="Best First Search(BFS-2)"></a>Best First Search(BFS-2)</h2><p><strong>使用minHeap, 按照最小的key先出来</strong></p><h3 id="经典算法：-Dijkstra’s-Algorithm"><a href="#经典算法：-Dijkstra’s-Algorithm" class="headerlink" title="经典算法： Dijkstra’s Algorithm"></a>经典算法： Dijkstra’s Algorithm</h3><h4 id="1-Usage-点到面（-所有点）的最短距离算法"><a href="#1-Usage-点到面（-所有点）的最短距离算法" class="headerlink" title="1. Usage: 点到面（==所有点）的最短距离算法"></a>1. Usage: 点到面（==所有点）的最短距离算法</h4><h4 id="2-Example-Problem-从北京到中国其他所有主要城市的最短距离是多少"><a href="#2-Example-Problem-从北京到中国其他所有主要城市的最短距离是多少" class="headerlink" title="2. Example Problem: 从北京到中国其他所有主要城市的最短距离是多少"></a>2. Example Problem: 从北京到中国其他所有主要城市的最短距离是多少</h4><h4 id="3-Data-Structure-PriorityQueue-minHeap"><a href="#3-Data-Structure-PriorityQueue-minHeap" class="headerlink" title="3. Data Structure: PriorityQueue(minHeap)"></a>3. Data Structure: PriorityQueue(minHeap)</h4><h4 id="4-解题思路："><a href="#4-解题思路：" class="headerlink" title="4. 解题思路："></a>4. 解题思路：</h4><h5 id="4-1-initial-state-start-node"><a href="#4-1-initial-state-start-node" class="headerlink" title="4.1 initial state(start node)"></a>4.1 initial state(start node)</h5><h5 id="4-2-Node-expansion-Genration-rule"><a href="#4-2-Node-expansion-Genration-rule" class="headerlink" title="4.2 Node expansion/Genration rule:"></a>4.2 Node expansion/Genration rule:</h5><h5 id="4-3-Terminations-Condition-所有点都计算完毕才停止，也就是minHeap为空时"><a href="#4-3-Terminations-Condition-所有点都计算完毕才停止，也就是minHeap为空时" class="headerlink" title="4.3 Terminations Condition: 所有点都计算完毕才停止，也就是minHeap为空时"></a>4.3 Terminations Condition: 所有点都计算完毕才停止，也就是minHeap为空时</h5><p>####BFS应用—Topological sort</p><p>不同于BFS-1从一个start node 从上往下层层搜索； </p><p><strong>Topological sort是从外（<u>从所有leaves出发</u>）往里一层一层的缩小，直到Queue为空</strong></p><ol><li>LeetCode 207. Course Schedule</li><li>LeetCode 210. Course Schedule II</li><li>LeetCode 310. Minimum Height Trees 总结未做</li><li>LeetCode 444: Sequence Reconstruction ?</li><li>LeetCode 269: Alien Dictionary ?</li></ol><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><ol><li>粉红色路径，一头扎到底，（backtracking）是扎到底之后返回它上一层</li><li>有些问题不能使用BFS-1,是因为随着搜索范围的增大，层数的增大，queue的size也会随着exponetially 增大</li></ol><ul><li>Recall “using pre-order to traverse a tree”</li><li>实现方法： easy to use <strong>recursion</strong></li><li>常见考题：<ol><li>DFS 例题1： print all subsets of a set</li><li>DFS 例题2： print all valid permutation of () () ()</li><li>DFS 例题3： e.g.凑硬币金额99分<ul><li>有1分， 5分， 10 分， 25分coins, 给定金额99cents, 有多少种组成方式，并打印出所有可能组合</li></ul></li><li>DFS一类的题目</li></ol></li></ul><h3 id="1-DFS-类型1：0-or-1"><a href="#1-DFS-类型1：0-or-1" class="headerlink" title="1. DFS 类型1：0 or 1"></a>1. DFS 类型1：0 or 1</h3><p>####例题1. LeetCode 78. Subsets</p><p>题意： Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets (the power set).</p><p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p><p><img src="http://server.myspace-shack.com/d23/f0ae1fd5-fe37-47f6-9fe2-47f68aa58869.png" alt=""></p><p><img src="http://server.myspace-shack.com/d23/1ebef5ec-c5a2-440b-90e1-1ddb415109f2.png" alt=""></p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       //解法一： 对每个数字选 or 不选</span><br><span class="line">       //no duplicate</span><br><span class="line">       //dfs recusion tree</span><br><span class="line">       //有多少layer： n个数字，所有对n个数字做选 or 不选， ---n layer</span><br><span class="line">       //有多少个分叉： two, ---选 or 不选</span><br><span class="line">       </span><br><span class="line">       if(nums == null || nums.length == 0)</span><br><span class="line">           return new ArrayList&lt;&gt;();</span><br><span class="line">       </span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">       List&lt;Integer&gt; subset = new ArrayList&lt;&gt;();</span><br><span class="line">       </span><br><span class="line">       dfs(nums, 0, subset, res);</span><br><span class="line">       </span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void dfs(int[] nums, int index, List&lt;Integer&gt; subset, List&lt;List&lt;Integer&gt;&gt; res)&#123;</span><br><span class="line">       if(index == nums.length)&#123;</span><br><span class="line">           res.add(new ArrayList&lt;&gt;(subset));</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       if(index &lt; nums.length)&#123;</span><br><span class="line">           //case 1: chose nums[i]</span><br><span class="line">           subset.add(nums[index]);</span><br><span class="line">           dfs(nums, index + 1, subset, res);</span><br><span class="line">           subset.remove(subset.size() - 1);</span><br><span class="line"></span><br><span class="line">           //case 2: not choose nums[i]</span><br><span class="line">           dfs(nums, index + 1, subset, res);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="例题2：-LeetCode-22-Generate-Parentheses"><a href="#例题2：-LeetCode-22-Generate-Parentheses" class="headerlink" title="例题2： LeetCode 22: Generate Parentheses"></a>例题2： LeetCode 22: Generate Parentheses</h4><p>#####类似subset-I: 选‘（ ’ or 选‘ ）’ + 特定的<strong>剪枝</strong>—即：什么时候可以加（， 什么时候可以加）</p><p>题意：</p><p>Given <em>n</em> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>For example, given <em>n</em> = 3, a solution set is:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>思路：</p><p><img src="http://server.myspace-shack.com/d23/5f1594d6-3eff-48be-835b-5a0a66f2d7d1.png" alt=""></p><h5 id="Recursion-Tree"><a href="#Recursion-Tree" class="headerlink" title="Recursion Tree"></a>Recursion Tree</h5><p><img src="http://server.myspace-shack.com/d23/e55a1cf9-6641-46fe-82d7-a800c4bb5001.png" alt=""></p><p>虚线的state代表的是剪枝（<strong>Restrictions</strong>）</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        </span><br><span class="line">        //左右括号都必须得匹配</span><br><span class="line">        //n pairs of parentheses, then we have 2*n position to put &apos;(&apos; or &apos;)&apos;</span><br><span class="line">        //for each positon , we can either put &apos;(&apos; or &apos;)&apos;, 但是我们有一些constraints</span><br><span class="line">        //类似subset问题中每个数字，选or不选的关系</span><br><span class="line">        //constraints:</span><br><span class="line">        //1. 什么时候可以加&apos;(&apos;? --- numL # of &apos;(&apos; &lt; n</span><br><span class="line">        //2. 什么时候可以加&apos;)&apos;? --- numR # of &apos;(&apos; &gt; # of &apos;)&apos;</span><br><span class="line">        //3. base case: 什么时候跳出？ --- numL == n &amp;&amp; numR == n</span><br><span class="line">        List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        if(n == 0)</span><br><span class="line">            return res;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        </span><br><span class="line">        chooseLOrRhelper(n, 0 , 0, sb, res);</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //DFS: </span><br><span class="line">    public void chooseLOrRhelper(int n, int numL, int numR, StringBuilder sb, List&lt;String&gt; res)&#123;</span><br><span class="line">        </span><br><span class="line">        if(numL == n &amp;&amp; numR == n)&#123;</span><br><span class="line">            res.add(new StringBuilder(sb).toString());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //case 1: add &apos;(&apos;, 左子树</span><br><span class="line">        if(numL &lt; n)&#123;</span><br><span class="line">            sb.append(&apos;(&apos;);</span><br><span class="line">            chooseLOrRhelper(n, numL + 1, numR, sb, res);</span><br><span class="line">            sb.deleteCharAt(sb.length() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //case 2: add &apos;)&apos;, 右子树</span><br><span class="line">        if(numL &gt; numR)&#123;</span><br><span class="line">            sb.append(&apos;)&apos;);</span><br><span class="line">            chooseLOrRhelper(n, numL, numR + 1, sb, res);</span><br><span class="line">            sb.deleteCharAt(sb.length() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####例题4：LeetCode 46. Permutations </p><p>题意：</p><p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>#####方法一： with extra space: <strong>used[] 去记录某个数字是否使用过</strong></p><p><img src="http://i67.tinypic.com/2yx1a9u.png" alt=""></p><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">        </span><br><span class="line">        if(nums == null || nums.length == 0)</span><br><span class="line">            return new ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; item = new ArrayList&lt;&gt;();</span><br><span class="line">        int[] visited = new int[nums.length];</span><br><span class="line">        </span><br><span class="line">        dfs(nums, 0, item, res, visited);</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void dfs(int[] nums, int level, List&lt;Integer&gt; item, List&lt;List&lt;Integer&gt;&gt; res, int[] visited)&#123;</span><br><span class="line">        if(level == nums.length)&#123;</span><br><span class="line">            res.add(new ArrayList(item));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(level &lt; nums.length)&#123;</span><br><span class="line">            </span><br><span class="line">            //how many cases on each state on each level?</span><br><span class="line">            //i = 0----n, need to check visited</span><br><span class="line">            for(int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">                </span><br><span class="line">                if(visited[i] == 0)&#123;</span><br><span class="line">                    item.add(nums[i]);</span><br><span class="line">                    visited[i] = 1;</span><br><span class="line">                    dfs(nums, level + 1, item, res, visited);</span><br><span class="line">                    item.remove(item.size() - 1);</span><br><span class="line">                    visited[i] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二： in-place: 不需要used[] 去记录某个数字是否使用过</p><p>####<u>permutation —In-place 方法之swap-swap</u></p><p><img src="http://i68.tinypic.com/27xr0o5.png" alt=""></p><p>注意点：</p><ol><li>for循环中0 改为<strong>index</strong> </li><li>每次swap(input, <strong>index</strong>, i);</li></ol><p><img src="http://i65.tinypic.com/j58jk6.png" alt=""></p><h2 id="再次总结："><a href="#再次总结：" class="headerlink" title="再次总结："></a>再次总结：</h2><p>###关于<strong>Recursion</strong>一些自己的误区及纠正：</p><p>E.g. Recursion Tree:</p><p><img src="http://i68.tinypic.com/27xr0o5.png" alt=""></p><ol><li><p>关于Recursion中的global, 和local（局部）变量的理解</p><p>public void <strong>dfs(char[] str, int index, List<character> tmp, List&lt;List<string>&gt; res, int[] used)</string></character></strong></p><ul><li>recursion function中的argument都是global的—对于reference type data(tmp, res, used), 都是全局可变的，<strong>即—随着recursion tree traverse， recursion funciton 有时需要做内部更改（如：tmp, res, used）</strong> <strong>就像每个结点上的一个随身记事本</strong></li><li>在recursion function 内部定义的变量是local（局部）变量。<strong>只记录当前层上同一个父节点下children结点的状态</strong></li></ul><p>在recursion tree上的体现为：</p><p>—–如处理duplicate character时：需要定义一个hashSet, 去记录<strong>当前level(index)在同一个父节点</strong>下是否visited过某个character</p><p>例如：在L1层， 用一个hashSet 记录在<strong>该level上</strong>用到过的character b1</p><p><img src="http://server.myspace-shack.com/d23/b53e18df-71d1-4602-a691-17bb0601b51c.png" alt=""></p></li></ol><p>### </p><hr><table><thead><tr><th>ID</th><th>Name</th><th>Difficulty</th><th>P/F</th><th>Data Structure</th><th>Skills</th><th>Sepcial</th></tr></thead><tbody><tr><td>46</td><td>Permutations</td><td>M</td><td>1/1</td><td></td><td>(DFS) -Way1. <strong>In-place: index-swap-swap.</strong> -Way2. Extra Space: List&lt;&gt; tmp + int[] used</td><td>经典</td></tr><tr><td>47</td><td>PermutationII</td><td>M</td><td>1/1</td><td></td><td>如上Way 1: sort. Way2: hashset去重复</td><td>de-dup</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Greedy 总结</title>
      <link href="/2018/05/16/Greedy-%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/16/Greedy-%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="Greedy-总结"><a href="#Greedy-总结" class="headerlink" title="Greedy 总结"></a>Greedy 总结</h1><p>题目中一般带有最小的，最少的。。。hint keyword</p><p>Greedy 对interval overlapping 问题</p><p>对起点sorting，找overlapping</p><ol start="56"><li><p>Merge Intervals</p></li><li><p>Meeting Rooms</p></li></ol><p>##LeetCode 253. Meeting Rooms II</p><p>Given an array of meeting time intervals consisting of start and end times <code>[[s1,e1],[s2,e2],...]</code> (si &lt; ei), find the minimum number of conference rooms required.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0, 30],[5, 10],[15, 20]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[7,10],[2,4]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p>time: O(nlogn)<br> space: O(n)</p><p>###问题分析：</p><ul><li>把每一个interval 按照start time 排序</li><li>把第一个interval加入minHeap, 代表我至少需要一个room with meeting ending at e1</li><li>遍历排序后的intervals：</li></ul><p>​        之后没遍历到的一个interval i，</p><ol><li>如果i’s start time &lt; 最早结束的room’s ending time, 那么它一定与其他room’s ending time 发生冲突， 所以要新开一个room with i’s ending time</li><li>如果i’s start time &gt; 最早结束的room’s ending time, 那么i meeting 可以用最早结束meeting的room，只需要update最早结束room的ending time to i’s ending time.</li></ol><p>​        </p><pre><code>//分析所需数据结构：//每次我们比较，我们都需要cur&apos;s meeting 和最早结束的room&apos;s ending time//用minHeap， O(1)得到最小ending time//注意： 我们每次真正在意的是之前heap中room&apos;s ending time, 所以只需要存ending time 就可以了//# of minimum room = minHeap.size()</code></pre><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minMeetingRooms(Interval[] intervals) &#123;</span><br><span class="line">        </span><br><span class="line">        if(intervals == null || intervals.length == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; a.start - b.start);</span><br><span class="line">        </span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; a - b);</span><br><span class="line">        </span><br><span class="line">        minHeap.offer(intervals[0].end);</span><br><span class="line">        </span><br><span class="line">        for(int i = 1; i &lt; intervals.length; i++)&#123;</span><br><span class="line">            if(intervals[i].start &lt; minHeap.peek())&#123; //overlaping, new room with i&apos;s ending time</span><br><span class="line">                minHeap.offer(intervals[i].end);</span><br><span class="line">            &#125;else&#123;//not conflict, just use this room, update room&apos;s ending time wiht i&apos;s ending time</span><br><span class="line">                Integer minEnd = minHeap.poll();</span><br><span class="line">                minHeap.offer(intervals[i].end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return minHeap.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Greedy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Heap 总结</title>
      <link href="/2018/05/14/Heap-%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/14/Heap-%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>什么时候最好用到PriorityQueue：</p><p>求最大值/最小值时： O(1)</p><p>待总结！！！</p><p>Leetcode </p><ol start="347"><li><p>Top K Frequent Elements</p></li><li><p>Merge k Sorted Lists</p></li><li><p>Kth Smallest Element in a Sorted Matrix （23题的马甲题）！！注意变形</p></li><li><p>Ugly Number II</p></li></ol><p>经典题：两个Heap去找输入流，array的median</p><ol start="295"><li>Find Median from Data Stream</li></ol>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>复习Cards</title>
      <link href="/2018/05/12/%E5%A4%8D%E4%B9%A0Cards/"/>
      <url>/2018/05/12/%E5%A4%8D%E4%B9%A0Cards/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> 复习1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 复习1 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Stack, Queue, Heap题型总结</title>
      <link href="/2018/05/10/Stack-Queue-Heap%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/10/Stack-Queue-Heap%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="Stack-Queue-Heap-题型总结"><a href="#Stack-Queue-Heap-题型总结" class="headerlink" title="Stack, Queue, Heap 题型总结"></a>Stack, Queue, Heap 题型总结</h1><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><h3 id="基础题："><a href="#基础题：" class="headerlink" title="基础题："></a>基础题：</h3><p>####LeetCode 232. Implement Queue using Stacks </p><p>题目意思： 用两个Stacks 实现Queue的功能： push(x), pop(), peek(), empty()</p><p>思路： stack1用作push(), </p><p>stack2 用作pop()时把Stack1中正序过来，然后 stack2.pop()</p><p>主要是pop的实现：</p><ol><li><p>if Stack2 is empty： transfer all stack1’s elements to stack2</p></li><li><p>endif; return stack2.pop()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class MyQueue &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    public MyQueue() &#123;</span><br><span class="line">        stack1 = new Stack&lt;&gt;();</span><br><span class="line">        stack2 = new Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Push element x to the back of queue. */</span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Removes the element from in front of queue and returns that element. */</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        if(stack2.isEmpty())&#123;</span><br><span class="line">            while(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Get the front element. */</span><br><span class="line">    public int peek() &#123;</span><br><span class="line">        if(stack2.isEmpty())&#123;</span><br><span class="line">            while(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns whether the queue is empty. */</span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        </span><br><span class="line">        return stack1.isEmpty() &amp;&amp; stack2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="题型二：Iterator类型"><a href="#题型二：Iterator类型" class="headerlink" title="题型二：Iterator类型"></a>题型二：Iterator类型</h3><h4 id="注意点：-主程序应该在hasNext还是在next-中实现？"><a href="#注意点：-主程序应该在hasNext还是在next-中实现？" class="headerlink" title="注意点： 主程序应该在hasNext还是在next 中实现？"></a>注意点： 主程序应该在hasNext还是在next 中实现？</h4><p>答案是： 最好是hasNext中实现</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h4 id="LeetCode-225-Implement-Stack-using-Queues"><a href="#LeetCode-225-Implement-Stack-using-Queues" class="headerlink" title="LeetCode 225. Implement Stack using Queues"></a>LeetCode 225. Implement Stack using Queues</h4><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>用Queue实现Stack的<strong>LIFO</strong>操作： push(x), pop(), peek(), empty()</p><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><ol><li>方法一： Deque: 双向队列 offerLast(x), pollLast(), peekLast()</li><li>方法二： Queue: 单向出口队列： push(x): queue.offer(x)之后，记得把x前面的挪到queue后面去</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//方法二</span><br><span class="line">class MyStack &#123;</span><br><span class="line">    </span><br><span class="line">    //单向队列</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    public MyStack() &#123;</span><br><span class="line">        queue = new LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Push element x onto stack. */</span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        for(int i = 0; i &lt; queue.size() - 1; i++)</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Removes the element on top of the stack and returns that element. */</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        return queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Get the top element. */</span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns whether the stack is empty. */</span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Heap </tag>
            
            <tag> Stack </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Two Pointer 问题总结</title>
      <link href="/2018/05/09/Two%20Pointer%20%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/09/Two%20Pointer%20%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="Two-Pointer-问题总结"><a href="#Two-Pointer-问题总结" class="headerlink" title="Two Pointer 问题总结"></a>Two Pointer 问题总结</h1><h2 id="基础热身题型（必会题型）："><a href="#基础热身题型（必会题型）：" class="headerlink" title="基础热身题型（必会题型）："></a>基础热身题型（必会题型）：</h2><ol><li>LeetCode283.  Move Zeroes</li><li>LeetCode 26:  Remove Duplicates from Sorted Array</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a>Two Sum</h4><ul><li>= target </li><li>&lt;= target</li><li>>target</li><li>unique pairs</li><li>closest to target</li><li>difference = target </li></ul><h3 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h3><ul><li>Quick Select </li><li>分成两个部分 </li><li>分成三个部分 </li></ul><h3 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h3><ul><li>排序</li><li>烙饼排序</li><li>(还有前面学的拓扑排序 ）</li></ul><hr><a id="more"></a> <p>Quick Select(QuickSort 中的partition部分)用到了two pointer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 在nums中的start 到end， 找到一个pivot，是的pivot左边大于pivot，左边小于pivot</span><br><span class="line">    //return pIndex;</span><br><span class="line">    public int partition(int[] nums, int start, int end)&#123;</span><br><span class="line"></span><br><span class="line">        int pivot = nums[end];</span><br><span class="line">        int pIndex = start;</span><br><span class="line"></span><br><span class="line">        for(int i = start; i &lt; end; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i] &gt;= pivot)&#123;</span><br><span class="line">                swap(nums, i, pIndex);</span><br><span class="line">                pIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(nums, pIndex, end);</span><br><span class="line"></span><br><span class="line">        return pIndex;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="1-Array中的Two-Pointer"><a href="#1-Array中的Two-Pointer" class="headerlink" title="1. Array中的Two Pointer"></a>1. Array中的Two Pointer</h1><h2 id="经典题型：-2-Sum-3-Sum"><a href="#经典题型：-2-Sum-3-Sum" class="headerlink" title="经典题型： 2 Sum + 3 Sum"></a>经典题型： 2 Sum + 3 Sum</h2><h3 id="相似点：-对于求2个变量如何组合的问题，-可以循环其中一个变量，-然后研究另外一个变量如何变化"><a href="#相似点：-对于求2个变量如何组合的问题，-可以循环其中一个变量，-然后研究另外一个变量如何变化" class="headerlink" title="相似点： 对于求2个变量如何组合的问题， 可以循环其中一个变量， 然后研究另外一个变量如何变化"></a>相似点： 对于求2个变量如何组合的问题， 可以循环其中一个变量， 然后研究另外一个变量如何变化</h3><h4 id="Two-Sum-——Unsorted-array"><a href="#Two-Sum-——Unsorted-array" class="headerlink" title="Two Sum:——Unsorted array"></a>Two Sum:——Unsorted array</h4><h5 id="思路：-HashMap"><a href="#思路：-HashMap" class="headerlink" title="思路： HashMap"></a>思路： HashMap</h5><p>complexity:</p><p>time: O(n)</p><p>space: O(n)</p><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure><h5 id="代码：-C"><a href="#代码：-C" class="headerlink" title="代码： C++"></a>代码： C++</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; diffIndex;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i&lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            // map存diff，index； 在map中找当前nums[i]</span><br><span class="line">            if(diffIndex.find(nums[i]) != diffIndex.end())</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(diffIndex[nums[i]]);</span><br><span class="line">                result.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            diffIndex[target - nums[i]] = i;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Two-Sum—-sorted-array"><a href="#Two-Sum—-sorted-array" class="headerlink" title="Two Sum— sorted array"></a>Two Sum— sorted array</h4><p>#####思路： Two pointer </p><p>complexity:</p><ul><li>time: O(n)</li><li>space: O(1)</li></ul><p>Given an array of integers that is already <strong>sorted in ascending order</strong>, find two numbers such that they add up to a specific target number.</p><p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</p><p><strong>Note:</strong></p><ul><li>Your returned answers (both index1 and index2) are not zero-based.</li><li>You may assume that each input would have <em>exactly</em> one solution and you may not use the <em>same</em> element twice.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: numbers = [2,7,11,15], target = 9</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.</span><br></pre></td></tr></table></figure><h5 id="代码：-Java"><a href="#代码：-Java" class="headerlink" title="代码： Java"></a>代码： Java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] numbers, int target) &#123;</span><br><span class="line">        </span><br><span class="line">        int left = 0, right = numbers.length - 1;</span><br><span class="line">        int[] res = new int[2];</span><br><span class="line">        </span><br><span class="line">        while(left &lt; right)&#123;</span><br><span class="line">            int sum = numbers[left] + numbers[right];</span><br><span class="line">            </span><br><span class="line">            if(sum == target)&#123;</span><br><span class="line">                res[0] = left + 1;</span><br><span class="line">                res[1] = right + 1;</span><br><span class="line">                return res;</span><br><span class="line">            &#125;else if(sum &gt; target)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-sum："><a href="#3-sum：" class="headerlink" title="3 sum："></a>3 sum：</h4><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><ul><li>根据2sum思路： nums[i] + nums[j] + nums[k] = 0</li><li>默认nums[i] &lt;= nums[j] &lt;= nums[k]; 所以先Sort array</li><li>固定nums[i], 在i之后找到关于nums[j], nums[k]的所有组合可能性</li><li>难点： 注意i， j,  k都要去重： /<em>去重技巧， nums[i] == nums[i - 1] 往前</em>/</li></ul><h5 id="代码：-Java-1"><a href="#代码：-Java-1" class="headerlink" title="代码： Java"></a>代码： Java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        </span><br><span class="line">        //Sort nums</span><br><span class="line">        //nums[i] + nums[j] + nums[k] =0</span><br><span class="line">        //固定第一个数字，从i后面找剩下两个大一点的数字的组合可能性</span><br><span class="line">        //注意要多i，和j, k 都同时除重</span><br><span class="line">        </span><br><span class="line">        //time complexity： O(nlogn + n^2)</span><br><span class="line">        //space: O(1)</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; nums.length - 2; i++)&#123;</span><br><span class="line">            /*去重技巧， nums[i] == nums[i - 1] 往前*/</span><br><span class="line">            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) //skip same result</span><br><span class="line">                continue;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            int left = i + 1;</span><br><span class="line">            int right = nums.length - 1;</span><br><span class="line">            int target = 0 - nums[i];</span><br><span class="line">            while(left &lt; right)&#123;</span><br><span class="line">                int sum = nums[left] + nums[right];</span><br><span class="line">                </span><br><span class="line">                if(sum == target)&#123;</span><br><span class="line">                    list.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    left++; //继续往内侧压缩，找其他可能性</span><br><span class="line">                    right--;</span><br><span class="line">                    /*去重技巧， nums[i] == nums[i - 1] 往前*/</span><br><span class="line">                    while(left &lt; right &amp;&amp; nums[left] == nums[left - 1]) //skip same result</span><br><span class="line">                        left++;</span><br><span class="line">                    while(left &lt; right &amp;&amp; nums[right] == nums[right + 1]) //skip same result</span><br><span class="line">                        right--;</span><br><span class="line">                    </span><br><span class="line">                &#125;else if(sum &gt; target)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return list;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3Sum-Closest"><a href="#3Sum-Closest" class="headerlink" title="3Sum Closest"></a>3Sum Closest</h4><p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 2, 1, -4], and target = 1.</span><br><span class="line"></span><br><span class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>类似于3Sum</p><ol><li>nums[i] + nums[left] + nums[right] —&gt;target</li><li>sort array, 再固定nums[i]， 对i 之后的做2Sum， 并计算bestSum</li></ol><p>Complexity:</p><ol><li>time:  O(n^2)</li><li>space: O(1)</li></ol><h4 id="代码：-Java-2"><a href="#代码：-Java-2" class="headerlink" title="代码： Java"></a>代码： Java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int threeSumClosest(int[] nums, int target) &#123;</span><br><span class="line">        </span><br><span class="line">        //-1, 1, 2, -4</span><br><span class="line">        //-4 -1 1 2</span><br><span class="line">        //      0 0</span><br><span class="line">        </span><br><span class="line">        // if(nums == null || nums.length == 0 || nums.length &lt; 3)</span><br><span class="line">        //     return 0;</span><br><span class="line">        </span><br><span class="line">        //Time complexity: O(n^2)</span><br><span class="line">        //space complexity: O(1)</span><br><span class="line">        类似于3Sum</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        int bestSum = nums[0] + nums[1] + nums[2];</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.length - 2; i++)&#123;</span><br><span class="line">        </span><br><span class="line">            int left = i + 1;</span><br><span class="line">            int right = nums.length - 1;</span><br><span class="line">            </span><br><span class="line">            while( left &lt; right)&#123;</span><br><span class="line">                sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                if(Math.abs(target - sum) &lt; Math.abs(target - bestSum))</span><br><span class="line">                    bestSum = sum;</span><br><span class="line">                </span><br><span class="line">                if(sum &gt; target)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return bestSum;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4Sum"><a href="#4Sum" class="headerlink" title="4Sum"></a>4Sum</h4><p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = <code>target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>.</p><p><strong>Note:</strong></p><p>The solution set must not contain duplicate quadruplets.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h5><p>类似3Sum， </p><ol><li>nums[i] + nums[j] + nums[left] + nums[right] = target</li><li>fixed nums[i], then fixed nums[j], find the sum of two integer possibles, </li><li>注意点： 要对i， j, left, right 同时去重。 去重技巧/*i &gt; 0 &amp;&amp; nums[i] == nums[i - 1])/</li></ol><p>Complexity:</p><ol><li>time: O(n^3)</li><li>space: O(1)</li></ol><h5 id="代码：-Java-3"><a href="#代码：-Java-3" class="headerlink" title="代码： Java"></a>代码： Java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;</span><br><span class="line">        </span><br><span class="line">        if(nums == null || nums.length &lt; 4)</span><br><span class="line">            return new ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; nums.length - 3; i++)&#123;</span><br><span class="line">            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1])</span><br><span class="line">                continue;</span><br><span class="line">            for(int j = i + 1; j &lt; nums.length - 2; j++)&#123;</span><br><span class="line">                </span><br><span class="line">                /*去重技巧：j != i + 1 &amp;&amp;  nums[j] == nums[j - 1]*/</span><br><span class="line">                if(j != i + 1  &amp;&amp; nums[j] == nums[j - 1])</span><br><span class="line">                    continue;</span><br><span class="line">                </span><br><span class="line">                int left = j + 1;</span><br><span class="line">                int right = nums.length - 1;</span><br><span class="line">                while(left &lt; right)&#123;</span><br><span class="line">                    int sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    if(sum == target)&#123;</span><br><span class="line">                        list.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                        while(left &lt; right &amp;&amp; nums[left] == nums[left - 1])</span><br><span class="line">                            left++;</span><br><span class="line">                        while(left &lt; right &amp;&amp; nums[right] == nums[right + 1])</span><br><span class="line">                            right--;</span><br><span class="line">                        </span><br><span class="line">                    &#125;else if(sum &gt; target)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-Linked-List上的Two-Pointer"><a href="#2-Linked-List上的Two-Pointer" class="headerlink" title="2. Linked List上的Two Pointer"></a>2. Linked List上的Two Pointer</h1><h2 id="1-slow-fast-指针"><a href="#1-slow-fast-指针" class="headerlink" title="1. slow, fast 指针"></a>1. slow, fast 指针</h2><p>特点： slow 走一步， fast走两步</p><p>用处： </p><ol><li>检测LinkedList 上有没有环</li></ol><h3 id="LeetCode-141-Linked-List-Cycle"><a href="#LeetCode-141-Linked-List-Cycle" class="headerlink" title="LeetCode 141. Linked List Cycle"></a>LeetCode 141. Linked List Cycle</h3><p> 题目意思： 检测Linked List是否有环</p><p>Follow Up: 只用O(1) space </p><p><img src="http://i65.tinypic.com/1z2ltav.png" alt="Screen Shot 2018-05-11 at 3.36.28 PM"></p><p><strong>有环， slow, fast一定在环上某一点相遇</strong></p><p>####要点： slow = head; fast = head; while loop直到找到slow == fast为止， while loop 结束，代表没找到，return false;</p><p><strong>注意点： while loop中的<u>入口条件</u>： slow != null &amp;&amp; fast != null &amp;&amp; fast.next != null</strong></p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        </span><br><span class="line">        //slow 指针走一步，fast指针走两步，如果有环，slow和fast一定会在环上相遇</span><br><span class="line">        </span><br><span class="line">        if(head == null)</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;  </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        //注意点： 如果涉及到fast.next.next一定要先判断fast.next != null</span><br><span class="line">         while(fast != null &amp;&amp; fast.next != null)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            if(slow == fast)</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-142-Linked-List-Cycle-II"><a href="#LeetCode-142-Linked-List-Cycle-II" class="headerlink" title="LeetCode 142: Linked List Cycle II"></a>LeetCode 142: Linked List Cycle II</h3><p>题目意思： 找到Linked List中环的<strong>起点</strong></p><p>要点： <strong>fast的速度是slow两倍， 所以fast走的距离是slow的两倍。</strong> 如果slow, fast 相遇在z点， 那么slow走的路程： a + b; 而fast走的路程是a + b + c + b。所以： 2*（a + b) = a + b + c + b, —&gt;很重要的结论：  <strong>a = c</strong>.</p><p>根据以上结论， 只需要在相遇点z处再设置一个slow2 = head, 那么下次slow == slow2的时候，就是环的起点。</p><p><img src="http://i68.tinypic.com/2po7hy0.png" alt=""></p><p>代码；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode detectCycle(ListNode head) &#123;</span><br><span class="line">        </span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        </span><br><span class="line">        while(fast != null &amp;&amp; fast.next != null)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            if(slow == fast)&#123;//一定有环</span><br><span class="line">                ListNode slow2 = head;</span><br><span class="line">                while(slow != slow2)&#123;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    slow2 = slow2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                return slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //没有环</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Two Pointer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java常用API+数据结构</title>
      <link href="/2018/05/09/Java%E5%B8%B8%E7%94%A8API+%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2018/05/09/Java%E5%B8%B8%E7%94%A8API+%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h1 id="根据Input-Size-V-S-Time-Complexity"><a href="#根据Input-Size-V-S-Time-Complexity" class="headerlink" title="根据Input Size V.S. Time Complexity"></a>根据Input Size V.S. Time Complexity</h1><p><img src="http://i65.tinypic.com/2zs49qv.png" alt=""></p><h1 id="Data-Type"><a href="#Data-Type" class="headerlink" title="Data Type"></a>Data Type</h1><h2 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h2><table><thead><tr><th style="text-align:center">return</th><th style="text-align:center">Method</th><th style="text-align:center">Usage</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">boolean</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Character.html#isLetter-char-" target="_blank" rel="noopener">isLetter</a>(char ch)</td><td style="text-align:center">Character.isLetter(‘a’)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">static char</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Character.html#toLowerCase-char-" target="_blank" rel="noopener">toLowerCase</a>(char ch)</td><td style="text-align:center">Character.toLowerCase(‘A’)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">static String</td><td style="text-align:center">toString(char c)</td><td style="text-align:center">Character.toString(‘a’)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">static boolean</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Character.html#isWhitespace-char-" target="_blank" rel="noopener">isWhitespace</a>(char ch)</td><td style="text-align:center">Character.isWhiteSpace(‘ ‘)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><a id="more"></a> <h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><table><thead><tr><th style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" target="_blank" rel="noopener">String</a>[]</th><th style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#split-java.lang.String-" target="_blank" rel="noopener">split</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" target="_blank" rel="noopener">String</a> regex)</th><th style="text-align:center">str.split(“ “)</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">int</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#indexOf-java.lang.String-" target="_blank" rel="noopener">indexOf</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" target="_blank" rel="noopener">String</a> str or char ch)</td><td style="text-align:center">str.indexOf(“ab”); str.indexOf(‘a’)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">int</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#lastIndexOf-int-" target="_blank" rel="noopener">lastIndexOf</a>(char);  <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#lastIndexOf-int-" target="_blank" rel="noopener">lastIndexOf</a>(String)</td><td style="text-align:center">str.lastIndexOf(‘a’);str.lastIndexOf(“ab”)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">String</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#trim--" target="_blank" rel="noopener">trim</a>()</td><td style="text-align:center">str.trim()</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><table><thead><tr><th>Return</th><th>Method</th><th>Usage</th><th></th></tr></thead><tbody><tr><td>String</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/StringBuilder.html#toString--" target="_blank" rel="noopener">toString</a>()</td><td>sb.toString()</td><td></td></tr><tr><td></td><td>reverse()</td><td></td><td></td></tr><tr><td></td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/StringBuilder.html#delete-int-int-" target="_blank" rel="noopener">delete</a>(int start, int end)</td><td></td><td></td></tr><tr><td></td><td>deleteCharAt(int index)</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><table><thead><tr><th>Return</th><th>Method</th><th>Usage</th><th></th></tr></thead><tbody><tr><td>void</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Collections.html#swap-java.util.List-int-int-" target="_blank" rel="noopener">swap</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/util/List.html" target="_blank" rel="noopener">List</a>&lt;?&gt; list, int i, int j)</td><td>Collections.swap(list, i, j)</td><td></td></tr><tr><td>void</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Collections.html#reverse-java.util.List-" target="_blank" rel="noopener">reverse</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/util/List.html" target="_blank" rel="noopener">List</a>&lt;?&gt; list)</td><td>Collections.reverse(list)</td><td></td></tr><tr><td>void</td><td>sort(List<t> list,Comparator&lt;? super T&gt; c)</t></td><td>Collections.sort(list, new myComp);</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><hr><h1 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h1><p>##Stack</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">Return</th><th style="text-align:center">Method</th><th style="text-align:center">Usage</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Stack.html#push-E-" target="_blank" rel="noopener">push</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/util/Stack.html" target="_blank" rel="noopener">E</a> item)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Stack.html#pop--" target="_blank" rel="noopener">pop</a>()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Stack.html#peek--" target="_blank" rel="noopener">peek</a>()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">isEmpty()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">size()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>​                  |—&gt;不可以为primitive element， 必须是reference element</p><table><thead><tr><th></th><th>Method:  <em>Returns special value</em></th><th>Method:  <em>Throws exception</em></th><th>Descripttion</th></tr></thead><tbody><tr><td></td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html#offer-E-" target="_blank" rel="noopener">offer</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html" target="_blank" rel="noopener">E</a> e)</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html#add-E-" target="_blank" rel="noopener">add</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html" target="_blank" rel="noopener">E</a> e)</td><td></td></tr><tr><td></td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html#poll--" target="_blank" rel="noopener">poll</a>()</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html#remove--" target="_blank" rel="noopener">remove</a>()</td><td>Retrieves and removes the <strong>head of this queue.</strong></td></tr><tr><td></td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html#peek--" target="_blank" rel="noopener">peek</a>()</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html#element--" target="_blank" rel="noopener">element</a>()</td><td></td></tr><tr><td></td><td>isEmpty()</td><td>isEmpty()</td><td></td></tr><tr><td></td><td>size()</td><td>size()</td><td></td></tr><tr><td></td><td>addAll()</td><td>addAll()</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>queue是collection的子接口，表示的数据结构为队列（FIFO）</p><p><u>deque</u>是queue的子接口，是<strong>double-ended-queue</strong>的缩写，表示的数据结构为双端队列</p><table><thead><tr><th style="text-align:center">Return</th><th style="text-align:center">Method</th><th style="text-align:center">Usage</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">offerFirst(e)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">offerLast(e)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">pollFirst()</td><td style="text-align:center"></td><td style="text-align:center">检索+删除队列头元素， 若队列为空， 返回null</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">pollLast()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">peekFirst()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">peekLast()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">以下为会抛出异常操作</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">addFirst(e)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">addLast(e)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">removeFirst()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">removeLast()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">getFirst()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">getLast()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>collision—different key have same bucket</p><ul><li>Open hashing : Separate Chaining(Close Addressing) —use the linked list in the bucket to link the different k-v pairs</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">Return</th><th style="text-align:center">Method</th><th style="text-align:center">Usage</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">V</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/HashMap.html#get-java.lang.Object-" target="_blank" rel="noopener">get</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a> key)</td><td style="text-align:center">hashMap.get(key)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">value or default value</td><td style="text-align:center"><u>getOrDefault</u>(Object key, V defaultValue)</td><td style="text-align:center">hashMap.put(key, value)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">put(K key, V value)</td><td style="text-align:center">hashMap.put(key, value)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">containsKey(Object key)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Set&lt;Map.Entry&lt;K, V&gt;&gt;</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/HashMap.html#entrySet--" target="_blank" rel="noopener">entrySet</a>()</td><td style="text-align:center">获得了某个entry：entry.getKey(); entry.getValue()</td><td style="text-align:center">Returns a <a href="https://docs.oracle.com/javase/9/docs/api/java/util/Set.html" target="_blank" rel="noopener"><code>Set</code></a> view of the mappings contained in this map.</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/HashMap.html#remove-java.lang.Object-" target="_blank" rel="noopener">remove</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a> key)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/HashMap.html#remove-java.lang.Object-java.lang.Object-" target="_blank" rel="noopener">remove</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a> key, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a> value)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>Collection&lt;V&gt;</code></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/HashMap.html#values--" target="_blank" rel="noopener">values</a>()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>HashMap的遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(Map.Entry&lt;Integer, Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">int key = entry.getKey();</span><br><span class="line">int value = entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><table><thead><tr><th style="text-align:center">Return</th><th style="text-align:center">Method</th><th style="text-align:center">Usage</th><th style="text-align:center">Discription</th></tr></thead><tbody><tr><td style="text-align:center">boolean</td><td style="text-align:center">add(E e)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Set.html#contains-java.lang.Object-" target="_blank" rel="noopener">contains</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a> o)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Set.html#remove-java.lang.Object-" target="_blank" rel="noopener">remove</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a> o)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">isEmpty()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a>[]</td><td style="text-align:center">toArray()</td><td style="text-align:center"></td><td style="text-align:center">Returns an array containing all of the elements in this set.</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>什么时候最好用到PriorityQueue：</p><p>求最大值/最小值时： O(1)</p><p><img src="http://i68.tinypic.com/31667bq.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;ListNode&gt; minHeap = new PriorityQueue&lt;&gt;(lists.length, (a, b) -&gt; a.val - b.val);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;ListNode&gt; minHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; a.val - b.val);</span><br></pre></td></tr></table></figure><p>其中comparator要自定义，如果不是primitive type</p><table><thead><tr><th style="text-align:center">Return</th><th style="text-align:center">Method</th><th style="text-align:center">Usage</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">boolean</td><td style="text-align:center">offer(E e)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/PriorityQueue.html" target="_blank" rel="noopener">E</a></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/PriorityQueue.html#poll--" target="_blank" rel="noopener">poll</a>()</td><td style="text-align:center"></td><td style="text-align:center">Retrieves and removes the head of this queue, or returns <code>null</code> if this queue is empty.s</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><code>peek()</code></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">size()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a>[]</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/PriorityQueue.html#toArray--" target="_blank" rel="noopener">toArray</a>()</td><td style="text-align:center"></td><td style="text-align:center">Returns an array containing all of the elements in this queue.</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>什么时候使用TreeMap？</p><p>答案： 又想知道最小值，又想支持修改和删除 </p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Sliding Window 总结</title>
      <link href="/2018/05/07/Sliding-Window-%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/07/Sliding-Window-%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="Slide-Window-滑动窗口-Hash"><a href="#Slide-Window-滑动窗口-Hash" class="headerlink" title="Slide Window 滑动窗口 + Hash"></a>Slide Window 滑动窗口 + Hash</h1><h3 id="什么样的题目适合用slide-window"><a href="#什么样的题目适合用slide-window" class="headerlink" title="什么样的题目适合用slide window"></a>什么样的题目适合用slide window</h3><ol><li>找符合某种condition 的subtring </li></ol><p>相似题目：</p><ol><li>Minimum window substring</li><li>Longest Substring without Repeating Characters</li><li>Longest Substring with at most 2 Distinct Characters</li><li>Longest Substring with at most k Distinct Characters</li></ol><a id="more"></a><h4 id="题型：找符合某种condition-的subtring"><a href="#题型：找符合某种condition-的subtring" class="headerlink" title="题型：找符合某种condition 的subtring"></a>题型：找符合某种condition 的subtring</h4><hr><h4 id="LeetCode-3-Longest-Substring-Without-Repeating-Characters"><a href="#LeetCode-3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="LeetCode 3. Longest Substring Without Repeating Characters"></a>LeetCode 3. Longest Substring Without Repeating Characters</h4><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><p><strong>Examples:</strong></p><p>Given <code>&quot;abcabcbb&quot;</code>, the answer is <code>&quot;abc&quot;</code>, which the length is 3.</p><p>Given <code>&quot;bbbbb&quot;</code>, the answer is <code>&quot;b&quot;</code>, with the length of 1.</p><p>Given <code>&quot;pwwkew&quot;</code>, the answer is <code>&quot;wke&quot;</code>, with the length of 3. Note that the answer must be a <strong>substring</strong>, <code>&quot;pwke&quot;</code> is a <em>subsequence</em>and not a substring.</p><p><strong>题目意思： 找符合“no repeat”条件的substring</strong></p><p>技巧摘要： </p><ol><li>Two Pointer （start， i）— 决定substring的长度 len = i - start + 1</li><li>HashMap: 存string中每个character的index， 持续保持更新</li><li>conditional variable： no repeat</li></ol><p>解法一：beat： 31% 用 hashMap： 存char, Latest updated char’s index </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        if(s == null || s.length() == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">        int start = 0; </span><br><span class="line">        int len = 0;</span><br><span class="line">        //hashMap: char, char&apos;s lastes updated index</span><br><span class="line">        </span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; s.length(); i++)&#123;</span><br><span class="line">            if(hashMap.containsKey(s.charAt(i)))&#123;</span><br><span class="line">            //start pointer只能往前走： case： pwwkewp</span><br><span class="line">                start = Math.max(start, hashMap.get(s.charAt(i)) + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新或增加hashMap中的index</span><br><span class="line">            hashMap.put(s.charAt(i), i);</span><br><span class="line">            len = Math.max(len, i - start + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 优化：beat 91% </p><p>与解法一思想一样，只是 用hashtable: </p><p>int[] hash = new int[256];  //最多有256个字符</p><p>initialize foreach hash[i] = -1;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        if(s == null || s.length() == 0)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        //p w e w k e p</span><br><span class="line">        //注意点： start, i 只能forward</span><br><span class="line">        //hash: char : char&apos;s lastest updated index        </span><br><span class="line">        int[] hash = new int[256];</span><br><span class="line">        for(int i = 0; i &lt; 256; i++)</span><br><span class="line">            hash[i] = -1;</span><br><span class="line">        </span><br><span class="line">        int start = 0;</span><br><span class="line">        int max = 0;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; s.length(); i++)&#123;</span><br><span class="line">            if(hash[s.charAt(i)] != -1)&#123;</span><br><span class="line">                start = Math.max(start, hash[s.charAt(i)] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            hash[s.charAt(i)] = i;</span><br><span class="line">            max = Math.max(max, i - start + 1); //i 每往前forward一次, 都要从新计算maxLength</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="159-Longest-Substring-with-At-Most-Two-Distinct-Characters"><a href="#159-Longest-Substring-with-At-Most-Two-Distinct-Characters" class="headerlink" title="159. Longest Substring with At Most Two Distinct Characters"></a>159. Longest Substring with At Most Two Distinct Characters</h4><p>Given a string <strong>s</strong> , find the length of the longest substring <strong>t</strong>  that contains <strong>at most</strong> 2 distinct characters.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;eceba&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: t is &quot;ece&quot; which its length is 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;ccaabbb&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: t is &quot;aabbb&quot; which its length is 5.</span><br></pre></td></tr></table></figure><p>题目意思： 找到符合“at most 2 distinct character” 的Substring</p><p> 和LeetCode 3 类似，难点在于怎么处理contidition variable = “at most 2 distinct character”</p><p>技巧摘要： </p><ol><li>Two Pointer （start， i）— 决定substring的长度 len = i - start + 1</li><li>HashMap: 存string中每个character的index， 持续保持更新</li><li>conditional variable： at most 2 distinct character</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstringTwoDistinct(String s) &#123;</span><br><span class="line">        </span><br><span class="line">        if(s == null || s.length() == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        int start = 0;</span><br><span class="line">        int max = 0;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; s.length(); i++)&#123;</span><br><span class="line">            //处理conditional： at most 2 distinct character</span><br><span class="line">            if(hashMap.size() &lt; 2)&#123;</span><br><span class="line">                hashMap.put(s.charAt(i), i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if(hashMap.size() == 2)&#123;</span><br><span class="line">                if(hashMap.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                    hashMap.put(s.charAt(i), i);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    int leftMost = s.length();</span><br><span class="line">                    for(int num: hashMap.values())&#123;</span><br><span class="line">                        leftMost = Math.min(leftMost, num);</span><br><span class="line">                    &#125;</span><br><span class="line">                    //保证hashMap中元素最多两个</span><br><span class="line">                    hashMap.remove(s.charAt(leftMost));</span><br><span class="line">                    start = leftMost + 1;</span><br><span class="line">                    hashMap.put(s.charAt(i), i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            max = Math.max(max, i - start + 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        return max;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> String </tag>
            
            <tag> Two Pointer </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DFS 模板 + 相关问题</title>
      <link href="/2018/05/07/DFS%E6%A8%A1%E6%9D%BF+%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2018/05/07/DFS%E6%A8%A1%E6%9D%BF+%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="DFS-模板-相关问题"><a href="#DFS-模板-相关问题" class="headerlink" title="DFS 模板 + 相关问题"></a>DFS 模板 + 相关问题</h1><a id="more"></a><h2 id="DFS-BackTracking"><a href="#DFS-BackTracking" class="headerlink" title="DFS + BackTracking"></a>DFS + BackTracking</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void dfs(...) </span><br><span class="line">&#123;</span><br><span class="line">    // Step 1： 结束递归的条件</span><br><span class="line">    if (...) &#123;</span><br><span class="line">        ..... // 把“当前结果” 加入 “结果集容器” 中</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Step 2: 继续递归，里面可能有回溯，也可能没有</span><br><span class="line">    //---used for backtracking： 如果需要回溯， 先保存当前状态</span><br><span class="line">    if (...) &#123;</span><br><span class="line"></span><br><span class="line">        ... // 在容器中保存当前数据</span><br><span class="line">        dfs() </span><br><span class="line">        ... // 在容器中删除上面保存的数据（注：这种情况下就称为回溯，很明显它是dfs的一个步骤）</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //----backtracking如果需要回溯， reset</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###难点</p><ol><li>寻找dfs结束条件</li><li>继续dfs的条件</li></ol><h4 id="79-Word-Search"><a href="#79-Word-Search" class="headerlink" title="79. Word Search"></a>79. Word Search</h4><p>Given a 2D board and a word, find if the word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given word = &quot;ABCCED&quot;, return true.</span><br><span class="line">Given word = &quot;SEE&quot;, return true.</span><br><span class="line">Given word = &quot;ABCB&quot;, return false.</span><br></pre></td></tr></table></figure><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><ol><li><p>遍历board所有cell，因为每个cell都可以作为起点</p></li><li><p>DFS中： 寻找DFS终止条件</p><p>2.1 越界： 该起点不行—&gt;return false</p><p>2.2 当前cell不是我要找的Character： 该起点不行—&gt; return false</p><p>2.3 避开了以上出口条件： 没越界，起点是要找单字， 且是<strong>最后一个单字</strong> —&gt;该起点整句找到， return true</p></li><li><p>如果避开以上， 说明没找到整句，以该坐标为起点， 继续四个方向找Index + 1的单字</p><p>3.1 注意去重：方法一： Mark board； 方法二： 另用一个visited二维数组</p><p>​    3.1.1  尝试4个方向前， mark  该坐标为visited， 记得保存当前状态，作为reset</p></li><li><p>explore 4 direction</p></li><li><p>reset board （backtracking）</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">        </span><br><span class="line">        if(board == null || board.length == 0 || board[0].length == 0 || word == null || word.length() == 0)</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        //尝试所有的cell，记得reset board</span><br><span class="line">        for(int i = 0; i &lt; board.length; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; board[0].length; j++)&#123;</span><br><span class="line">                if(dfsExist(board, word, 0, i, j))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return false;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public boolean dfsExist(char[][] board, String word, int index, int x, int y)&#123;</span><br><span class="line">        if(x &lt; 0 || y &lt; 0 | x &gt;= board.length || y &gt;= board[0].length)</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        if(word.charAt(index) != board[x][y])</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        if(index == word.length() - 1)</span><br><span class="line">            return true;</span><br><span class="line">        </span><br><span class="line">        char tmp = board[x][y]; //保存当前状态，用作以后reset</span><br><span class="line">        board[x][y] = &apos;#&apos;; //mark as visited</span><br><span class="line">        </span><br><span class="line">        boolean res = dfsExist(board, word, index + 1, x, y + 1) || dfsExist(board, word, index + 1, x, y - 1) </span><br><span class="line">            || dfsExist(board, word, index + 1, x + 1,  y ) || dfsExist(board, word, index + 1, x - 1,  y );</span><br><span class="line">        </span><br><span class="line">        board[x][y] = tmp; //backtracking： reset board</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java基础知识总结----集合，框架</title>
      <link href="/2018/05/05/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93----%E9%9B%86%E5%90%88%EF%BC%8C%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/05/05/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93----%E9%9B%86%E5%90%88%EF%BC%8C%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<h1 id="Java基础知识总结—集合，框架"><a href="#Java基础知识总结—集合，框架" class="headerlink" title="Java基础知识总结—集合，框架"></a>Java基础知识总结—集合，框架</h1><p><img src="https://i1.wp.com/javabydeveloper.com/wp-content/uploads/2016/06/Collection-Framework-hierarchy.png" alt="集合，框架"></p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection:"></a>Collection:</h2><h4 id="—List-有序-元素存入集合的顺序和取出的顺序一致-，元素都有索引。元素可以重复。"><a href="#—List-有序-元素存入集合的顺序和取出的顺序一致-，元素都有索引。元素可以重复。" class="headerlink" title="—List: 有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。"></a>—List: 有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。</h4><h4 id="—Set-无序-存入和取出顺序有可能不一致-，不可以存储重复元素。必须保证元素唯一性。"><a href="#—Set-无序-存入和取出顺序有可能不一致-，不可以存储重复元素。必须保证元素唯一性。" class="headerlink" title="—Set: 无序(存入和取出顺序有可能不一致)，不可以存储重复元素。必须保证元素唯一性。"></a>—Set: 无序(存入和取出顺序有可能不一致)，不可以存储重复元素。必须保证元素唯一性。</h4><a id="more"></a><h3 id="常用方法：（增查删改）"><a href="#常用方法：（增查删改）" class="headerlink" title="常用方法：（增查删改）"></a>常用方法：（增查删改）</h3><ul><li>添加：<ul><li>add(object)：添加一个元素</li><li>addAll(Collection) ：添加一个集合中的所有元素。</li></ul></li><li>删除<ul><li>clear()：将集合中的元素全删除，清空集合。</li><li>remove(obj) ：删除集合中指定的对象。注意：删除成功，集合的长度会改变。</li><li>removeAll(collection) ：删除部分元素。部分元素和传入Collection一致。</li></ul></li><li>判断：<ul><li>boolean contains(obj) ：集合中是否包含指定元素 。</li><li>boolean containsAll(Collection) ：集合中是否包含指定的多个元素。</li><li>boolean containsAll(Collection) ：集合中是否包含指定的多个元素。</li></ul></li><li>获取：<ul><li>int size()：集合中有几个元素。</li></ul></li><li>取交集<ul><li>boolean  retainAll(Collection) ：对当前集合中保留和指定集合中的相同的元素。如果两个集合元素相同，返回flase；如果retainAll修改了当前集合，返回true。</li></ul></li><li>获取集合中所有元素<ul><li>Iterator  iterator()：迭代器 </li></ul></li><li>将集合变成数组：<ul><li>toArray(); </li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = coll.iterator();//获取容器中的迭代器对象，至于这个对象是是什么不重要。这对象肯定符合一个规则Iterator接口。</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Collection coll = new ArrayList();</span><br><span class="line"></span><br><span class="line">coll.add(&quot;abc0&quot;);</span><br><span class="line"></span><br><span class="line">coll.add(&quot;abc1&quot;);</span><br><span class="line"></span><br><span class="line">coll.add(&quot;abc2&quot;);</span><br><span class="line"></span><br><span class="line">//--------------方式1----------------------</span><br><span class="line"></span><br><span class="line">Iterator it = coll.iterator();</span><br><span class="line"></span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(it.next());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//---------------方式2用此种----------------------</span><br><span class="line"></span><br><span class="line">for(Iterator it = coll.iterator();it.hasNext(); )&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(it.next());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h4 id="Collection-接口之—-List接口："><a href="#Collection-接口之—-List接口：" class="headerlink" title="Collection 接口之— List接口："></a>Collection 接口之— List接口：</h4><h4 id="List本身是Collection接口的子接口，具备了Collection的所有方法。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。"><a href="#List本身是Collection接口的子接口，具备了Collection的所有方法。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。" class="headerlink" title="List本身是Collection接口的子接口，具备了Collection的所有方法。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。"></a><strong>List本身是Collection接口的子接口，具备了Collection的所有方法</strong>。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。</h4><h4 id="List：有序-元素存入集合的顺序和取出的顺序一致-，元素都有索引。元素可以重复。"><a href="#List：有序-元素存入集合的顺序和取出的顺序一致-，元素都有索引。元素可以重复。" class="headerlink" title="List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。"></a>List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。</h4><p>|–ArrayList：底层的数据结构是数组,线程不同步，ArrayList替代了Vector，查询元素的速度非常快。</p><p>|–LinkedList：底层的数据结构是链表，线程不同步，增删元素的速度非常快。</p><p>|–Vector：底层的数据结构就是数组，线程同步的，Vector无论查询和增删都巨慢。</p><p>1，添加：</p><p>add(index,element) ：在指定的索引位插入元素。</p><p>addAll(index,collection) ：在指定的索引位插入一堆元素。</p><p>2，删除：</p><p>remove(index) ：删除指定索引位的元素。 返回被删的元素。</p><p>3，获取：</p><p>Object get(index) ：通过索引获取指定元素。</p><p><strong>int indexOf(obj) ：</strong>获取指定元素第一次出现的索引位，如果该元素不存在返回-1；</p><p> 所以，通过-1，可以判断一个元素是否存在。</p><p>int lastIndexOf(Object o) ：反向索引指定元素的位置。</p><p>List subList(start,end) ：获取子列表。</p><p>4，修改：</p><p>Object set(index,element) ：对指定索引位进行元素的修改。</p><p>5，获取所有元素：</p><p>ListIterator listIterator()：list集合特有的迭代器。</p><p>List集合支持对元素的增、删、改、查。</p><h4 id="Collection接口之—LinkedList-接口"><a href="#Collection接口之—LinkedList-接口" class="headerlink" title="Collection接口之—LinkedList 接口"></a>Collection接口之—LinkedList 接口</h4><p><strong>LinkedList</strong>：<strong>的特有方法。</strong></p><p>addFirst();</p><p>addLast();</p><p>在jdk1.6以后。</p><p><strong>offerFirst();</strong></p><p><strong>offerLast();</strong></p><p>getFirst():获取链表中的第一个元素。如果链表为空，抛出NoSuchElementException;</p><p>getLast();</p><p>在jdk1.6以后。</p><p><strong>peekFirst();</strong>获取链表中的第一个元素。如果链表为空，返回null。</p><p><strong>peekLast();</strong></p><p>removeFirst()：获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，抛出NoSuchElementException</p><p>removeLast();</p><p>在jdk1.6以后。</p><p><strong>pollFirst();</strong>获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，返回null。</p><p><strong>pollLast();</strong></p><h4 id="Collection接口之—Set接口"><a href="#Collection接口之—Set接口" class="headerlink" title="Collection接口之—Set接口"></a>Collection接口之—Set接口</h4><p>Set接口中的方法和Collection中方法一致的。<strong>Set接口取出方式只有一种，迭代器。</strong></p><p>|–HashSet：底层数据结构是哈希表，线程是不同步的。无序，高效；</p><p>HashSet集合保证元素唯一性：通过元素的hashCode方法，和equals方法完成的。</p><p>当元素的hashCode值相同时，才继续判断元素的equals是否为true。</p><p>如果为true，那么视为相同元素，不存。如果为false，那么存储。</p><p>如果hashCode值不同，那么不判断equals，从而提高对象比较的速度。</p><p>​      |–LinkedHashSet：有序，hashset的子类。</p><p>|–TreeSet：对Set集合中的元素的进行指定顺序的排序。不同步。TreeSet底层的数据结构就是二叉树</p><p>TreeSet:</p><p>用于对Set集合进行元素的指定顺序排序，排序需要依据元素自身具备的比较性。</p><p>如果元素不具备比较性，在运行时会发生ClassCastException异常。</p><p>所以需要元素实现Comparable接口，强制让元素具备比较性，复写compareTo方法。</p><p>依据compareTo方法的返回值，确定元素在TreeSet数据结构中的位置。</p><p>TreeSet方法保证元素唯一性的方式：就是参考比较方法的结果是否为0，如果return 0，视为两个对象重复，不存。</p><p>注意：在进行比较时，如果判断元素不唯一，比如，同姓名，同年龄，才视为同一个人。</p><p>在判断时，需要分主要条件和次要条件，当主要条件相同时，再判断次要条件，按照次要条件排序。</p><p>TreeSet集合排序有两种方式，Comparable和Comparator区别：</p><p>1：让元素自身具备比较性，需要元素对象实现Comparable接口，覆盖compareTo方法。</p><p>2：让集合自身具备比较性，需要定义一个实现了Comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给TreeSet集合的构造函数。</p><p>第二种方式较为灵活。</p><h2 id="Map集合："><a href="#Map集合：" class="headerlink" title="Map集合："></a>Map集合：</h2><h5 id="–Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。"><a href="#–Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。" class="headerlink" title="|–Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。"></a>|–Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。</h5><h4 id="–HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable"><a href="#–HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable" class="headerlink" title="|–HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable."></a>|–HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable.</h4><h4 id="–TreeMap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。"><a href="#–TreeMap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。" class="headerlink" title="|–TreeMap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。"></a>|–TreeMap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。</h4><p>Map集合存储和Collection有着很大不同：</p><p>Collection一次存一个元素；Map一次存一对元素。</p><p>Collection是单列集合；Map是双列集合。</p><p>Map中的存储的一对元素：一个是键，一个是值，键与值之间有对应(映射)关系。</p><p>特点：要保证map集合中键的唯一性。</p><p>1，添加。</p><p> <strong>put</strong>(key,value)：当存储的键相同时，新的值会替换老的值，并将老值返回。如果键没有重复，返回null。</p><p>void putAll(Map);</p><p>2，删除。</p><p>void clear()：清空</p><p>value remove(key) ：删除指定键。</p><p>3，判断。</p><p>boolean <strong>isEmpty</strong>()：</p><p>boolean <strong>containsKey</strong>(key)：是否包含key</p><p>boolean <strong>containsValue</strong>(value) ：是否包含value</p><p>4，取出。</p><p>int size()：返回长度</p><p>value <strong>get</strong>(key) ：通过指定键获取对应的值。如果返回null，可以判断该键不存在。当然有特殊情况，就是在hashmap集合中，是可以存储null键null值的。</p><p>Collection <strong>values</strong>()：获取map集合中的所有的值。</p><p>5，想要获取map中的所有元素：</p><p>原理：map中是没有迭代器的，collection具备迭代器，只要将map集合转成Set集合，可以使用迭代器了。之所以转成set，是因为map集合具备着键的唯一性，其实set集合就来自于map，set集合底层其实用的就是map的方法。</p><p>把map集合转成set的方法：</p><p>Set <strong>keySet</strong>();</p><p>Set <strong>entrySet</strong>();//取的是键和值的映射关系</p><p>Entry就是Map接口中的内部接口；</p><p>为什么要定义在map内部呢？entry是访问键值关系的入口，是map的入口，访问的是map中的键值对。</p><hr><p>取出map集合中所有元素的方式一：keySet()方法。</p><p>可以将map集合中的键都取出存放到set集合中。对set集合进行迭代。迭代完成，再通过get方法对获取到的键进行值的获取。</p><h4 id="使用Collection，-Map的技巧："><a href="#使用Collection，-Map的技巧：" class="headerlink" title="使用Collection， Map的技巧："></a>使用Collection， Map的技巧：</h4><p>看到Array就是数组结构，有角标，查询速度很快。</p><p>看到link就是链表结构：增删速度快，而且有特有方法。addFirst； addLast； removeFirst()； removeLast()； getFirst()；getLast()；</p><p>看到hash就是哈希表，就要想要哈希值，就要想到唯一性，就要想到存入到该结构的中的元素必须覆盖hashCode，equals方法。</p><p>看到tree就是二叉树，就要想到<strong>排序</strong>，就想要用到比较。</p><p>比较的两种方式：</p><p>一个是Comparable：覆盖compareTo方法；</p><p>一个是Comparator：覆盖compare方法。</p><p>LinkedHashSet，LinkedHashMap:这两个集合可以保证哈希表有存入顺序和取出顺序一致，保证哈希表有序</p><p>####集合什么时候用？</p><p>当存储的是一个元素时，就用Collection。当存储对象之间存在着映射关系时，就使用Map集合。</p><p><u>保证唯一，就用Set</u>。不保证唯一，就用List。</p><p>#####Collections：它的出现给集合操作提供了更多的功能。这个类不需要创建对象，内部提供的都是静态方法。</p><p>####Collection 和 Collections的区别：</p><p>Collections是个java.util下的类，是针对集合类的一个<strong>工具类</strong>,提供一系列静态方法,实现对集合的查找、排序、替换、线程安全化（将非同步的集合转换成同步的）等操作。</p><p>Collection是个java.util下的接口，它是各种集合结构的父接口，继承于它的接口主要有Set和List,提供了关于集合的一些操作,如插入、删除、判断一个元素是否其成员、遍历等。</p><p>文章转载自： <a href="http://www.cnblogs.com/bigorangehasc/p/8646091.html" target="_blank" rel="noopener">http://www.cnblogs.com/bigorangehasc/p/8646091.html</a></p>]]></content>
      
      <categories>
          
          <category> LearnJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Typora</title>
      <link href="/2018/05/05/Typora%E9%94%AE%E7%9B%98%E4%BE%A0/"/>
      <url>/2018/05/05/Typora%E9%94%AE%E7%9B%98%E4%BE%A0/</url>
      <content type="html"><![CDATA[<h1 id="Typora-从此请叫我键盘侠"><a href="#Typora-从此请叫我键盘侠" class="headerlink" title="Typora:从此请叫我键盘侠"></a>Typora:从此请叫我键盘侠</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. cd hexoFolder</span><br><span class="line">2. $ hexo new &quot;My New Post&quot;</span><br><span class="line">3. 修改tags和categories</span><br><span class="line">4. 在本地服务器上检测： hexo s --debug</span><br><span class="line">5. 传到GitHub：</span><br><span class="line"></span><br><span class="line"> $hexo g</span><br><span class="line"> $hexo d</span><br><span class="line"> </span><br><span class="line">快捷键大全：</span><br><span class="line"></span><br><span class="line">http://joehill.me/2015/07/27/2015-07-27-Markdown-Typora/</span><br><span class="line"></span><br><span class="line">http://www.flypeom.site/documentation/2017/09/02/Typora%E7%AE%80%E4%BB%8B%E5%8F%8AMarkdown%E8%AF%AD%E6%B3%95%E7%B2%BE%E8%AE%B2/</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LearnJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>刷题中问题总结</title>
      <link href="/2018/05/05/Java/"/>
      <url>/2018/05/05/Java/</url>
      <content type="html"><![CDATA[<ol><li><p><strong>while循环什么时候退出？</strong></p><p>先分析题意，找到退出条件conditions, 然后while循环里的statement就是：<strong>^(conditions)</strong></p><p>De-Morgan’s Law:</p><ol><li>^(A &amp;&amp; B) —&gt; ^A || ^B</li><li>^(A || B)  —&gt; ^A &amp;&amp; ^B</li></ol></li><li><p>对于一个Sorted Array出现的问题</p></li></ol><p>立马联想到：</p><ul><li>Binary Search</li><li>while loop + two pointers: 谁小移动谁</li></ul><p><a href="https://www.geeksforgeeks.org/union-and-intersection-of-two-sorted-arrays-2/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/union-and-intersection-of-two-sorted-arrays-2/</a></p>]]></content>
      
      <categories>
          
          <category> LearnJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Learn to build personal web</title>
      <link href="/2018/05/05/LeetCode/"/>
      <url>/2018/05/05/LeetCode/</url>
      <content type="html"><![CDATA[<p>我就想随便写点啥</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p></blockquote><figure class="highlight plain"><figcaption><span>_.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="noopener">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.compact([0, 1, false, 2, &apos;&apos;, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LearnJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/05/05/hello-world/"/>
      <url>/2018/05/05/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
