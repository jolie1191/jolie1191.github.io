<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>DFS 模板 + 相关问题</title>
      <link href="/2018/05/07/DFS%E6%A8%A1%E6%9D%BF+%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2018/05/07/DFS%E6%A8%A1%E6%9D%BF+%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="DFS-模板-相关问题"><a href="#DFS-模板-相关问题" class="headerlink" title="DFS 模板 + 相关问题"></a>DFS 模板 + 相关问题</h1><a id="more"></a><h2 id="DFS-BackTracking"><a href="#DFS-BackTracking" class="headerlink" title="DFS + BackTracking"></a>DFS + BackTracking</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void dfs(...) </span><br><span class="line">&#123;</span><br><span class="line">    // Step 1： 结束递归的条件</span><br><span class="line">    if (...) &#123;</span><br><span class="line">        ..... // 把“当前结果” 加入 “结果集容器” 中</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Step 2: 继续递归，里面可能有回溯，也可能没有</span><br><span class="line">    //---used for backtracking： 如果需要回溯， 先保存当前状态</span><br><span class="line">    if (...) &#123;</span><br><span class="line"></span><br><span class="line">        ... // 在容器中保存当前数据</span><br><span class="line">        dfs() </span><br><span class="line">        ... // 在容器中删除上面保存的数据（注：这种情况下就称为回溯，很明显它是dfs的一个步骤）</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //----backtracking如果需要回溯， reset</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###难点</p><ol><li>寻找dfs结束条件</li><li>继续dfs的条件</li></ol><h4 id="79-Word-Search"><a href="#79-Word-Search" class="headerlink" title="79. Word Search"></a>79. Word Search</h4><p>Given a 2D board and a word, find if the word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given word = &quot;ABCCED&quot;, return true.</span><br><span class="line">Given word = &quot;SEE&quot;, return true.</span><br><span class="line">Given word = &quot;ABCB&quot;, return false.</span><br></pre></td></tr></table></figure><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><ol><li><p>遍历board所有cell，因为每个cell都可以作为起点</p></li><li><p>DFS中： 寻找DFS终止条件</p><p>2.1 越界： 该起点不行—&gt;return false</p><p>2.2 当前cell不是我要找的Character： 该起点不行—&gt; return false</p><p>2.3 避开了以上出口条件： 没越界，起点是要找单字， 且是<strong>最后一个单字</strong> —&gt;该起点整句找到， return true</p></li><li><p>如果避开以上， 说明没找到整句，以该坐标为起点， 继续四个方向找Index + 1的单字</p><p>3.1 注意去重：方法一： Mark board； 方法二： 另用一个visited二维数组</p><p>​    3.1.1  尝试4个方向前， mark  该坐标为visited， 记得保存当前状态，作为reset</p></li><li><p>explore 4 direction</p></li><li><p>reset board （backtracking）</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">        </span><br><span class="line">        if(board == null || board.length == 0 || board[0].length == 0 || word == null || word.length() == 0)</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        //尝试所有的cell，记得reset board</span><br><span class="line">        for(int i = 0; i &lt; board.length; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; board[0].length; j++)&#123;</span><br><span class="line">                if(dfsExist(board, word, 0, i, j))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return false;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public boolean dfsExist(char[][] board, String word, int index, int x, int y)&#123;</span><br><span class="line">        if(x &lt; 0 || y &lt; 0 | x &gt;= board.length || y &gt;= board[0].length)</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        if(word.charAt(index) != board[x][y])</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        if(index == word.length() - 1)</span><br><span class="line">            return true;</span><br><span class="line">        </span><br><span class="line">        char tmp = board[x][y]; //保存当前状态，用作以后reset</span><br><span class="line">        board[x][y] = &apos;#&apos;; //mark as visited</span><br><span class="line">        </span><br><span class="line">        boolean res = dfsExist(board, word, index + 1, x, y + 1) || dfsExist(board, word, index + 1, x, y - 1) </span><br><span class="line">            || dfsExist(board, word, index + 1, x + 1,  y ) || dfsExist(board, word, index + 1, x - 1,  y );</span><br><span class="line">        </span><br><span class="line">        board[x][y] = tmp; //backtracking： reset board</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java基础知识总结----集合，框架</title>
      <link href="/2018/05/05/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93----%E9%9B%86%E5%90%88%EF%BC%8C%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/05/05/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93----%E9%9B%86%E5%90%88%EF%BC%8C%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<h1 id="Java基础知识总结—集合，框架"><a href="#Java基础知识总结—集合，框架" class="headerlink" title="Java基础知识总结—集合，框架"></a>Java基础知识总结—集合，框架</h1><p><img src="https://i1.wp.com/javabydeveloper.com/wp-content/uploads/2016/06/Collection-Framework-hierarchy.png" alt="集合，框架"></p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection:"></a>Collection:</h2><h4 id="—List-有序-元素存入集合的顺序和取出的顺序一致-，元素都有索引。元素可以重复。"><a href="#—List-有序-元素存入集合的顺序和取出的顺序一致-，元素都有索引。元素可以重复。" class="headerlink" title="—List: 有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。"></a>—List: 有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。</h4><h4 id="—Set-无序-存入和取出顺序有可能不一致-，不可以存储重复元素。必须保证元素唯一性。"><a href="#—Set-无序-存入和取出顺序有可能不一致-，不可以存储重复元素。必须保证元素唯一性。" class="headerlink" title="—Set: 无序(存入和取出顺序有可能不一致)，不可以存储重复元素。必须保证元素唯一性。"></a>—Set: 无序(存入和取出顺序有可能不一致)，不可以存储重复元素。必须保证元素唯一性。</h4><a id="more"></a><h3 id="常用方法：（增查删改）"><a href="#常用方法：（增查删改）" class="headerlink" title="常用方法：（增查删改）"></a>常用方法：（增查删改）</h3><ul><li>添加：<ul><li>add(object)：添加一个元素</li><li>addAll(Collection) ：添加一个集合中的所有元素。</li></ul></li><li>删除<ul><li>clear()：将集合中的元素全删除，清空集合。</li><li>remove(obj) ：删除集合中指定的对象。注意：删除成功，集合的长度会改变。</li><li>removeAll(collection) ：删除部分元素。部分元素和传入Collection一致。</li></ul></li><li>判断：<ul><li>boolean contains(obj) ：集合中是否包含指定元素 。</li><li>boolean containsAll(Collection) ：集合中是否包含指定的多个元素。</li><li>boolean containsAll(Collection) ：集合中是否包含指定的多个元素。</li></ul></li><li>获取：<ul><li>int size()：集合中有几个元素。</li></ul></li><li>取交集<ul><li>boolean  retainAll(Collection) ：对当前集合中保留和指定集合中的相同的元素。如果两个集合元素相同，返回flase；如果retainAll修改了当前集合，返回true。</li></ul></li><li>获取集合中所有元素<ul><li>Iterator  iterator()：迭代器 </li></ul></li><li>将集合变成数组：<ul><li>toArray(); </li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = coll.iterator();//获取容器中的迭代器对象，至于这个对象是是什么不重要。这对象肯定符合一个规则Iterator接口。</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Collection coll = new ArrayList();</span><br><span class="line"></span><br><span class="line">coll.add(&quot;abc0&quot;);</span><br><span class="line"></span><br><span class="line">coll.add(&quot;abc1&quot;);</span><br><span class="line"></span><br><span class="line">coll.add(&quot;abc2&quot;);</span><br><span class="line"></span><br><span class="line">//--------------方式1----------------------</span><br><span class="line"></span><br><span class="line">Iterator it = coll.iterator();</span><br><span class="line"></span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(it.next());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//---------------方式2用此种----------------------</span><br><span class="line"></span><br><span class="line">for(Iterator it = coll.iterator();it.hasNext(); )&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(it.next());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h4 id="Collection-接口之—-List接口："><a href="#Collection-接口之—-List接口：" class="headerlink" title="Collection 接口之— List接口："></a>Collection 接口之— List接口：</h4><h4 id="List本身是Collection接口的子接口，具备了Collection的所有方法。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。"><a href="#List本身是Collection接口的子接口，具备了Collection的所有方法。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。" class="headerlink" title="List本身是Collection接口的子接口，具备了Collection的所有方法。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。"></a><strong>List本身是Collection接口的子接口，具备了Collection的所有方法</strong>。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。</h4><h4 id="List：有序-元素存入集合的顺序和取出的顺序一致-，元素都有索引。元素可以重复。"><a href="#List：有序-元素存入集合的顺序和取出的顺序一致-，元素都有索引。元素可以重复。" class="headerlink" title="List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。"></a>List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。</h4><p>|–ArrayList：底层的数据结构是数组,线程不同步，ArrayList替代了Vector，查询元素的速度非常快。</p><p>|–LinkedList：底层的数据结构是链表，线程不同步，增删元素的速度非常快。</p><p>|–Vector：底层的数据结构就是数组，线程同步的，Vector无论查询和增删都巨慢。</p><p>1，添加：</p><p>add(index,element) ：在指定的索引位插入元素。</p><p>addAll(index,collection) ：在指定的索引位插入一堆元素。</p><p>2，删除：</p><p>remove(index) ：删除指定索引位的元素。 返回被删的元素。</p><p>3，获取：</p><p>Object get(index) ：通过索引获取指定元素。</p><p><strong>int indexOf(obj) ：</strong>获取指定元素第一次出现的索引位，如果该元素不存在返回-1；</p><p> 所以，通过-1，可以判断一个元素是否存在。</p><p>int lastIndexOf(Object o) ：反向索引指定元素的位置。</p><p>List subList(start,end) ：获取子列表。</p><p>4，修改：</p><p>Object set(index,element) ：对指定索引位进行元素的修改。</p><p>5，获取所有元素：</p><p>ListIterator listIterator()：list集合特有的迭代器。</p><p>List集合支持对元素的增、删、改、查。</p><h4 id="Collection接口之—LinkedList-接口"><a href="#Collection接口之—LinkedList-接口" class="headerlink" title="Collection接口之—LinkedList 接口"></a>Collection接口之—LinkedList 接口</h4><p><strong>LinkedList</strong>：<strong>的特有方法。</strong></p><p>addFirst();</p><p>addLast();</p><p>在jdk1.6以后。</p><p><strong>offerFirst();</strong></p><p><strong>offerLast();</strong></p><p>getFirst():获取链表中的第一个元素。如果链表为空，抛出NoSuchElementException;</p><p>getLast();</p><p>在jdk1.6以后。</p><p><strong>peekFirst();</strong>获取链表中的第一个元素。如果链表为空，返回null。</p><p><strong>peekLast();</strong></p><p>removeFirst()：获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，抛出NoSuchElementException</p><p>removeLast();</p><p>在jdk1.6以后。</p><p><strong>pollFirst();</strong>获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，返回null。</p><p><strong>pollLast();</strong></p><h4 id="Collection接口之—Set接口"><a href="#Collection接口之—Set接口" class="headerlink" title="Collection接口之—Set接口"></a>Collection接口之—Set接口</h4><p>Set接口中的方法和Collection中方法一致的。<strong>Set接口取出方式只有一种，迭代器。</strong></p><p>|–HashSet：底层数据结构是哈希表，线程是不同步的。无序，高效；</p><p>HashSet集合保证元素唯一性：通过元素的hashCode方法，和equals方法完成的。</p><p>当元素的hashCode值相同时，才继续判断元素的equals是否为true。</p><p>如果为true，那么视为相同元素，不存。如果为false，那么存储。</p><p>如果hashCode值不同，那么不判断equals，从而提高对象比较的速度。</p><p>​      |–LinkedHashSet：有序，hashset的子类。</p><p>|–TreeSet：对Set集合中的元素的进行指定顺序的排序。不同步。TreeSet底层的数据结构就是二叉树</p><p>TreeSet:</p><p>用于对Set集合进行元素的指定顺序排序，排序需要依据元素自身具备的比较性。</p><p>如果元素不具备比较性，在运行时会发生ClassCastException异常。</p><p>所以需要元素实现Comparable接口，强制让元素具备比较性，复写compareTo方法。</p><p>依据compareTo方法的返回值，确定元素在TreeSet数据结构中的位置。</p><p>TreeSet方法保证元素唯一性的方式：就是参考比较方法的结果是否为0，如果return 0，视为两个对象重复，不存。</p><p>注意：在进行比较时，如果判断元素不唯一，比如，同姓名，同年龄，才视为同一个人。</p><p>在判断时，需要分主要条件和次要条件，当主要条件相同时，再判断次要条件，按照次要条件排序。</p><p>TreeSet集合排序有两种方式，Comparable和Comparator区别：</p><p>1：让元素自身具备比较性，需要元素对象实现Comparable接口，覆盖compareTo方法。</p><p>2：让集合自身具备比较性，需要定义一个实现了Comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给TreeSet集合的构造函数。</p><p>第二种方式较为灵活。</p><h2 id="Map集合："><a href="#Map集合：" class="headerlink" title="Map集合："></a>Map集合：</h2><h5 id="–Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。"><a href="#–Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。" class="headerlink" title="|–Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。"></a>|–Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。</h5><h4 id="–HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable"><a href="#–HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable" class="headerlink" title="|–HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable."></a>|–HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable.</h4><h4 id="–TreeMap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。"><a href="#–TreeMap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。" class="headerlink" title="|–TreeMap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。"></a>|–TreeMap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。</h4><p>Map集合存储和Collection有着很大不同：</p><p>Collection一次存一个元素；Map一次存一对元素。</p><p>Collection是单列集合；Map是双列集合。</p><p>Map中的存储的一对元素：一个是键，一个是值，键与值之间有对应(映射)关系。</p><p>特点：要保证map集合中键的唯一性。</p><p>1，添加。</p><p> <strong>put</strong>(key,value)：当存储的键相同时，新的值会替换老的值，并将老值返回。如果键没有重复，返回null。</p><p>void putAll(Map);</p><p>2，删除。</p><p>void clear()：清空</p><p>value remove(key) ：删除指定键。</p><p>3，判断。</p><p>boolean <strong>isEmpty</strong>()：</p><p>boolean <strong>containsKey</strong>(key)：是否包含key</p><p>boolean <strong>containsValue</strong>(value) ：是否包含value</p><p>4，取出。</p><p>int size()：返回长度</p><p>value <strong>get</strong>(key) ：通过指定键获取对应的值。如果返回null，可以判断该键不存在。当然有特殊情况，就是在hashmap集合中，是可以存储null键null值的。</p><p>Collection <strong>values</strong>()：获取map集合中的所有的值。</p><p>5，想要获取map中的所有元素：</p><p>原理：map中是没有迭代器的，collection具备迭代器，只要将map集合转成Set集合，可以使用迭代器了。之所以转成set，是因为map集合具备着键的唯一性，其实set集合就来自于map，set集合底层其实用的就是map的方法。</p><p>把map集合转成set的方法：</p><p>Set <strong>keySet</strong>();</p><p>Set <strong>entrySet</strong>();//取的是键和值的映射关系</p><p>Entry就是Map接口中的内部接口；</p><p>为什么要定义在map内部呢？entry是访问键值关系的入口，是map的入口，访问的是map中的键值对。</p><hr><p>取出map集合中所有元素的方式一：keySet()方法。</p><p>可以将map集合中的键都取出存放到set集合中。对set集合进行迭代。迭代完成，再通过get方法对获取到的键进行值的获取。</p><h4 id="使用Collection，-Map的技巧："><a href="#使用Collection，-Map的技巧：" class="headerlink" title="使用Collection， Map的技巧："></a>使用Collection， Map的技巧：</h4><p>看到Array就是数组结构，有角标，查询速度很快。</p><p>看到link就是链表结构：增删速度快，而且有特有方法。addFirst； addLast； removeFirst()； removeLast()； getFirst()；getLast()；</p><p>看到hash就是哈希表，就要想要哈希值，就要想到唯一性，就要想到存入到该结构的中的元素必须覆盖hashCode，equals方法。</p><p>看到tree就是二叉树，就要想到<strong>排序</strong>，就想要用到比较。</p><p>比较的两种方式：</p><p>一个是Comparable：覆盖compareTo方法；</p><p>一个是Comparator：覆盖compare方法。</p><p>LinkedHashSet，LinkedHashMap:这两个集合可以保证哈希表有存入顺序和取出顺序一致，保证哈希表有序</p><p>####集合什么时候用？</p><p>当存储的是一个元素时，就用Collection。当存储对象之间存在着映射关系时，就使用Map集合。</p><p><u>保证唯一，就用Set</u>。不保证唯一，就用List。</p><p>#####Collections：它的出现给集合操作提供了更多的功能。这个类不需要创建对象，内部提供的都是静态方法。</p><p>####Collection 和 Collections的区别：</p><p>Collections是个java.util下的类，是针对集合类的一个<strong>工具类</strong>,提供一系列静态方法,实现对集合的查找、排序、替换、线程安全化（将非同步的集合转换成同步的）等操作。</p><p>Collection是个java.util下的接口，它是各种集合结构的父接口，继承于它的接口主要有Set和List,提供了关于集合的一些操作,如插入、删除、判断一个元素是否其成员、遍历等。</p><p>文章转载自： <a href="http://www.cnblogs.com/bigorangehasc/p/8646091.html" target="_blank" rel="noopener">http://www.cnblogs.com/bigorangehasc/p/8646091.html</a></p>]]></content>
      
      <categories>
          
          <category> LearnJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Typora</title>
      <link href="/2018/05/05/Typora%E9%94%AE%E7%9B%98%E4%BE%A0/"/>
      <url>/2018/05/05/Typora%E9%94%AE%E7%9B%98%E4%BE%A0/</url>
      <content type="html"><![CDATA[<h1 id="Typora-从此请叫我键盘侠"><a href="#Typora-从此请叫我键盘侠" class="headerlink" title="Typora:从此请叫我键盘侠"></a>Typora:从此请叫我键盘侠</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. cd hexoFolder</span><br><span class="line">2. $ hexo new &quot;My New Post&quot;</span><br><span class="line">3. 修改tags和categories</span><br><span class="line">4. 在本地服务器上检测： hexo s --debug</span><br><span class="line">5. 传到GitHub：</span><br><span class="line"></span><br><span class="line"> $hexo g</span><br><span class="line"> $hexo d</span><br><span class="line"> </span><br><span class="line">快捷键大全：</span><br><span class="line"></span><br><span class="line">http://joehill.me/2015/07/27/2015-07-27-Markdown-Typora/</span><br><span class="line"></span><br><span class="line">http://www.flypeom.site/documentation/2017/09/02/Typora%E7%AE%80%E4%BB%8B%E5%8F%8AMarkdown%E8%AF%AD%E6%B3%95%E7%B2%BE%E8%AE%B2/</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LearnJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java</title>
      <link href="/2018/05/05/Java/"/>
      <url>/2018/05/05/Java/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> LearnJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Learn to build personal web</title>
      <link href="/2018/05/05/LeetCode/"/>
      <url>/2018/05/05/LeetCode/</url>
      <content type="html"><![CDATA[<p>我就想随便写点啥</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p></blockquote><figure class="highlight plain"><figcaption><span>_.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="noopener">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.compact([0, 1, false, 2, &apos;&apos;, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LearnJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/05/05/hello-world/"/>
      <url>/2018/05/05/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
