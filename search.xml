<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Breaking News</title>
      <link href="/2018/10/15/Breaking-News/"/>
      <url>/2018/10/15/Breaking-News/</url>
      
        <content type="html"><![CDATA[<h1 id="Week-5"><a href="#Week-5" class="headerlink" title="Week 5"></a>Week 5</h1><p>测试测试</p><h1 id="Week-6"><a href="#Week-6" class="headerlink" title="Week 6"></a>Week 6</h1><h3 id="NoSQL-vs-SQL"><a href="#NoSQL-vs-SQL" class="headerlink" title="NoSQL vs. SQL"></a>NoSQL vs. SQL</h3><p>CAP Theorem: (database 的特性， 一般只能满足两个)</p><ul><li>Consistensy;</li><li>Availaility </li><li>Partition-tolerance:</li></ul><p>NoSQL: </p><ul><li>Key-value Store: Dynamo, <strong>Redis</strong></li><li><strong>Document-based Store: MongoDB</strong></li><li>Column-based Store: BigTable, HBase, Cassandra</li></ul><p>SQL:</p><ul><li>SQL is structured query language for managing data held in a realational database.</li></ul><a id="more"></a><p>####MongonDB: Document Oriented database</p><ul><li>NoSQL</li><li>Documents(objects) map nicely programming language data types<ul><li>Document: Python Dictionary, JavaScript Object, Java Bean</li></ul></li><li>Embedded docuements <strong>reduce the need for joins</strong><ul><li>you can put the entire ducoment in MongoDB</li></ul></li><li><p>Dynamic schema <strong>makes change easier</strong></p></li><li><p>JSON-style, stored as BSON (python中使用pika把BSON转化成JSON)</p></li><li><p>High Scalable: MongoDB supports <strong><em>horizontal scaling</em></strong> through <strong>sharding</strong> (把不同的数据存在不同的服务器上)</p></li><li>Much faster than SQL database (Access)</li><li>Simple Queries (给一个key， 就给你整个文件)</li><li>Easier and faster interagtion of data</li></ul><p>####MongoDB in Python</p><ul><li>Connect to MongoDB</li><li>Insert</li><li>Query</li><li>Update</li></ul><h3 id="Message-Queue"><a href="#Message-Queue" class="headerlink" title="Message Queue"></a>Message Queue</h3><ul><li>对时间要求不高的放到Message Queue中比如<ul><li>Image Resizing online</li><li>log analysis</li><li>spam emails</li></ul></li><li>对时间要求高的，要立马显现在网页上的交给前端实现。</li></ul><p>###RabbitMQ</p><ul><li>Project is based on the Cloud-based Solution<ul><li>CloudAMQP</li></ul></li><li><p>RabbitMQ in Python:</p><ul><li>use “pika” library</li><li>Send a message</li><li>Recieve a message:</li></ul></li><li><p>Backend server used: traditonal HTTP and Python RPC. </p></li></ul><p>###SOA: Service Oriented Architecture</p><ul><li>All teams expose their data and functionality through <strong>service interfaces.</strong></li><li>Benifit:<ul><li>Isolation: <ul><li>decoupling </li><li>language, techonology, tools</li><li>deployment and maintanance</li></ul></li><li>Ownership</li><li>Scalability: easy to scale up and modify</li></ul></li></ul><h3 id="API-Design"><a href="#API-Design" class="headerlink" title="API Design"></a>API Design</h3><ul><li><strong>Web Service APIs</strong><ul><li>SOAP, XML-RPC, JSON-RPC, REST</li></ul></li><li>Library-based APIs<ul><li>Javascript(Google Map API)</li></ul></li><li>Class-based APIs<ul><li>Java API, Android API</li></ul></li><li>OS Functions and Routines<ul><li>File ystem, User interface</li></ul></li><li>Hardware APIs<ul><li>camera API</li></ul></li></ul><h4 id="RPC-vs-REST"><a href="#RPC-vs-REST" class="headerlink" title="RPC vs. REST"></a>RPC vs. REST</h4><ul><li><p><strong>RPC</strong></p><ul><li><p>Remote procedure call (类似本地的程序调用 invoke a function from remote computer)</p></li><li><p>RPC is strictly defined: client must know method name, argument, and types to make a call.</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service?request=GetOrders?orderId=123</span><br></pre></td></tr></table></figure></li></ul></li><li><p>REST （more like HTTP request)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service/orders?orderId=123</span><br></pre></td></tr></table></figure></li></ul><h4 id="JSON-RPC-vs-XML-RPC"><a href="#JSON-RPC-vs-XML-RPC" class="headerlink" title="JSON-RPC vs. XML-RPC"></a>JSON-RPC vs. XML-RPC</h4><p>In this project, we used JSON-RPC</p><ul><li>JSON-RPC is more readable and save more space.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo pip install pyhton-jsonrpc</span><br></pre></td></tr></table></figure><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation:"></a>Implementation:</h2><h1 id="Week-7-Data-Pipeline-amp-NLP"><a href="#Week-7-Data-Pipeline-amp-NLP" class="headerlink" title="Week 7: Data Pipeline &amp; NLP"></a>Week 7: Data Pipeline &amp; NLP</h1><h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><p>Abstract:</p><ul><li>Web Scraping</li><li>NLP Basics</li><li>Machine Learning Basics</li></ul><p><img src="http://i66.tinypic.com/35hk95u.png" alt=""></p><p>3个模块 to get and handle <strong><u><em>Data</em></u></strong>：</p><ol><li><strong>News Monitor</strong> 是通过一个叫News API (public API)来得到 latest news abtract(only include title, and <strong>URLs</strong>)</li><li>通过New Monitors 的到的URLs of news abtract, 把这个URLs 放到<u>RabbitMQ</u>中， 再通过<strong>Web Scrappers 爬虫</strong>在对应的URLs上采集 corresponding news that are from “BBC News”, “CNN”, “CNBC”.</li><li>再把采集到的数据发送到下一个<u>RabbitMQ queue</u>中， 对于重复的新闻使用<strong>News Deduper</strong>—使用的是<u><em>TF-IDF similarity check</em></u>, 通过一个阈值匹配一下existed database中 是否存在相似news, 如存在， 那么就dedup掉。 最后通过<u>News Deduper 把文件写入我们的database中去</u>。</li></ol><ul><li>TensorFlow 是做offLine training. 和backend合作， 再给前端做recommendation.</li></ul><h3 id="Web-Scraping-网页爬虫"><a href="#Web-Scraping-网页爬虫" class="headerlink" title="Web Scraping (网页爬虫)"></a>Web Scraping (网页爬虫)</h3><ul><li><p>Application:</p><ul><li><strong>Data Source</strong></li><li>Crawler &amp; Indexer (网页索引， 主要search engine来做)</li><li>Test: </li></ul></li><li><p>Web Scraping Basic Flow:</p><p><img src="http://i64.tinypic.com/1zqu7mg.png" alt=""></p><ol><li>stage1: 使用HTTP Get/some/resource 从目标服务器上抓取我们要的内容， 并保存起来（Raw HTML file)</li><li>stage2: <strong>analysis, parse and extract</strong> the Raw HTML file, like news title, description…, 之后再存入database成为一个usable data.</li></ol><ul><li><p>how to do HTML Parsing &amp; Extraction?</p><ul><li>parsing the HTML’s DOM Tree<ol><li>Regular Expression</li><li>XPath (XPath’s index start from index 1)</li><li><strong>Beautiful Soup: Python package for parsing HTML and XML document</strong> (in this project, we use the build-in library)</li></ol></li></ul></li><li><p><strong>A Simple Pyhton Scraper</strong></p><ol><li>Request HTML: Request Web Server to retrive HTML content –&gt; <strong>requests library</strong></li><li>Parse HTML: Parse the HTML into the structured data (Beautiful Soup) –&gt; <strong>lxml</strong></li><li>Extract information: Use XPath/Regex to extract useful information –&gt; <strong>lxml, re</strong></li><li>Store Information: Store the information to database –&gt; <strong>pymongo library</strong></li></ol></li><li><p><strong>Integration with RabbitMQ</strong></p><ol><li><p>why integrating with queue?</p><ul><li>Store scraping tasks temporarily</li><li>Make scraper running cotinuously (scrap web by BFS)</li><li>Let scraper feed itself</li><li>coordinate multiple scrapers working together(让多个爬虫同时工作)</li></ul><p>(如图所示：)</p><p><img src="http://i63.tinypic.com/2agm0cw.png" alt=""></p></li></ol></li><li><p>Avoid Blocking: (网站的时候对爬虫的封锁)</p></li></ul></li></ul><h3 id="NLP-Basics-Natrual-Language-Processing-Basics"><a href="#NLP-Basics-Natrual-Language-Processing-Basics" class="headerlink" title="NLP Basics - Natrual Language Processing Basics"></a>NLP Basics - Natrual Language Processing Basics</h3><p>Application:</p><ul><li>Applications for processing large amount of texts</li><li>Index and search large texts</li><li>Speech understanding (Alexa, amazon echo, google home)</li><li>Information retrival  </li><li>Automatic summarization </li><li>Human computer Interaction</li><li>……</li></ul><p><strong>Common Tasks:</strong></p><ul><li>Stemming: is the process of reducing words to their root/base/stem from <ul><li>used widly in normalize text: search engine etc…</li><li>Fishing, fishes, fisher –&gt; fish</li></ul></li><li>Part-of-Speech Tagging(POS Tagging) 根据每个word语法的分析<ul><li>Grammatical analysis: nouns, verbs, adjectives, adverbs</li><li>analyze the meaning of ambigutity. </li></ul></li><li>Parsing (分解每个句子)<ul><li>determine the <strong>parse tree</strong> (grammatical analysis) of a given sentence</li></ul></li><li>Semantic (语义学)<ul><li>machine traslation</li><li>Natural Language Generation</li><li>Natrual Language Understanding </li><li>Sentiment Analysis</li><li><strong>Topic Modeling</strong> (对话题进行分类)</li><li>…….</li></ul></li></ul><h4 id="TF-IDF-term-frequency-and-inversed-ducument-frquency"><a href="#TF-IDF-term-frequency-and-inversed-ducument-frquency" class="headerlink" title="TF-IDF: (term frequency and inversed ducument frquency)"></a>TF-IDF: (term frequency and inversed ducument frquency)</h4><ul><li>TF(t): measures how frequently a term occurs in a document.<ul><li>TF(t) = (Number of times term t appears in a document)/ (Total number of terms in the document)</li></ul></li><li>IDF(t): 描述这个term是否importance. Measures how important a term in all documents. (stop words like “is”, “of”, “the” is less important)</li><li>Use <strong>TF-IDF(t) weight</strong> to do the similarity.</li></ul><h3 id="Machine-Learning-Basics"><a href="#Machine-Learning-Basics" class="headerlink" title="Machine Learning Basics"></a>Machine Learning Basics</h3><p>Application:</p><ul><li>Text Recognition</li><li>Spam Filtering </li><li><strong>Recommendation System</strong></li><li>Medical Diagosis</li><li>Self Driving Car</li></ul><h4 id="Types-of-Machine-Learning"><a href="#Types-of-Machine-Learning" class="headerlink" title="Types of Machine Learning:"></a>Types of Machine Learning:</h4><ul><li><strong>Supervised Learning</strong>: learning by data <strong>(Labeled data, direct feedback, Predict outcome/future</strong>)<ul><li>An email spam detector that learnor from users’ historical spam tags</li></ul></li><li>Unsupervised Learning: discovering parttern itself (No labels, no feedbacks, “Find hidden structure”)</li><li><strong>Reinforcement Learning</strong>: feedback right/wrong (Decision Process, reward System, learn series of actions)<ul><li>learn to play chess by winning or losing</li></ul></li></ul><h4 id="Types-of-tasks-that-Machine-Learning-is-to-solve"><a href="#Types-of-tasks-that-Machine-Learning-is-to-solve" class="headerlink" title="Types of tasks that Machine Learning is to solve:"></a>Types of tasks that Machine Learning is to solve:</h4><ul><li>Classification: Map an element to category </li><li>Regeression: Predict numerical values</li><li><strong>Similarity: Find more similar</strong></li><li>Ranking: Return an ordered list(based on relevance)</li><li>Sequence Prediction: Predict the next one in the seires. (预测用户的行为)</li></ul><p>Meachine Learning 在现实生活中的基本构架</p><p><img src="http://i67.tinypic.com/2ahrses.png" alt=""></p><p>More additional work during training part:</p><p><img src="http://i65.tinypic.com/2wod4s0.png" alt=""></p><ul><li>Supervised ML Basics:<ul><li>Label: label is what we predict</li><li>feature: is an input variables. </li><li>Model: define the realationship between features and label.</li><li>Mainly: Regression vs. Classification <ul><li>regression model: predict continuous value</li><li>calssification model:  predict discrete values.</li></ul></li></ul></li></ul><h2 id="Week-8"><a href="#Week-8" class="headerlink" title="Week 8"></a>Week 8</h2><h3 id="Machine-Learning-amp-TensorFlow"><a href="#Machine-Learning-amp-TensorFlow" class="headerlink" title="Machine Learning &amp; TensorFlow"></a>Machine Learning &amp; TensorFlow</h3><ol><li>Machine Learning Basics</li><li>Tensorflow Basics</li><li>TensorFlow Serving</li></ol><h4 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h4><h4 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h4><ul><li><strong>TensorFlow</strong> is a deep learning library open-sourced by Google</li><li>TensorFlow provides primitives for defining funcitons on Tensors and automatically computing their deriviatives.</li></ul><ol><li>What is Tensor?<ul><li>a scalar, a vector or a matrix can be Tensor</li></ul></li></ol><ul><li><p>Jupyter: in Trainer.py file:</p><ul><li>data format: </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;#class_number(topic)&#125; , &#123;news_title&#125;, &#123;news_decription&#125;, &#123;news_source&#125;</span><br></pre></td></tr></table></figure><ul><li>using: <strong>pandas dataframe</strong> is a useful data structure for data science</li></ul></li><li><p>Vocabulary Embedding</p><ul><li>TensorFow cannot handle String directly. Therefore, we need to convert String into vectors. This is called embedding.</li><li><strong>VacabularyProcessor</strong>: TensorFlow provides a easy-to-use tool to do embedding.(把一个句子转化成一串数字)</li><li><strong>One-Hot Embedding</strong>: we converted <u>the string into an integer vector</u>. but that is not good enough. we need to <u>convert a word into one-hot vector</u>.</li><li><strong>Embedded Sequence:</strong> </li></ul></li><li><p><strong>Convolutinal Neural Networks(CNNs)</strong></p><ul><li>Convolution: (卷积)理解为一种特殊的乘法（image applied with a filter —&gt; convolved feature)</li><li>Pooling(采样)： eg: max pool with 2*2 filters and stride 2</li><li>More Info about CNN in NLP: <a href="http://www.wildml.com/2015/11/understanding-convolutional-neural-networks-for-nlp/" target="_blank" rel="noopener">http://www.wildml.com/2015/11/understanding-convolutional-neural-networks-for-nlp/</a></li><li>More Info about CNN in NLP: <a href="http://www.wildml.com/2015/12/implementing-a-cnn-for-text-classification-in-tensorflow/" target="_blank" rel="noopener">http://www.wildml.com/2015/12/implementing-a-cnn-for-text-classification-in-tensorflow/</a></li></ul></li><li><p>Implementation:</p><ul><li>def generatCNNmodel(n_classes, n_words):</li></ul></li></ul><ol><li>the data source is in Web Scraping from 3 major news websites: CNN, BBC, CNBC</li><li>we use Beautiful Soup Python library to parse Raw HTML file.</li><li>we use TF-IDF weight formula to measure the sililarity of extracted files.</li><li>In Jupyter, we use Pyhton build-in library like Pandas, Numpy, TensorFlow to build a CNN Model, train and save model.</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Web Development </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Engineer Connector Project</title>
      <link href="/2018/10/08/Engineer-Connector-Project/"/>
      <url>/2018/10/08/Engineer-Connector-Project/</url>
      
        <content type="html"><![CDATA[<h1 id="The-project-My-LinkedIn-Engineer-Connector"><a href="#The-project-My-LinkedIn-Engineer-Connector" class="headerlink" title="The project: My LinkedIn Engineer Connector"></a>The project: My LinkedIn Engineer Connector</h1><ul><li><p>A small social network with authentication, profiles, dashborad, posts</p></li><li><p>More Details:</p><ul><li>Create backedn API with Node/Express</li><li>Test with Postman</li><li>Explore the Bootstrap Theme</li><li>Implement React and connect with the backend</li><li>Implement Redux for state management</li><li><p>Prepare, build &amp; deploy to Heroku</p></li><li><p>测试测试测试</p></li></ul></li></ul><a id="more"></a><h1 id="Backend-server-js"><a href="#Backend-server-js" class="headerlink" title="Backend: server.js"></a>Backend: server.js</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm i express mongoose passport passport-jwt jsonwebtoken body-parser bcryptjs validator</span><br><span class="line">$ npm i -D nodemon</span><br></pre></td></tr></table></figure><p><strong>.gitignore</strong> file includes:</p><ul><li>config : keys.js &amp; password.js</li><li>node-modules</li></ul><p>set/Connect MongoDB</p><h2 id="User-API-Routes-amp-JWT-Authentication"><a href="#User-API-Routes-amp-JWT-Authentication" class="headerlink" title="User API Routes &amp; JWT Authentication"></a>User API Routes &amp; JWT Authentication</h2><ol><li><p>Creating the User Model</p></li><li><p>User Registration &amp; Postman</p><ul><li>generate Gravatar URLS in Node.js based on gravatar specs.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm install gravatar</span><br></pre></td></tr></table></figure><ul><li>password encrypted</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm install bcrypt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bcrypt.genSalt(10, (err, salt) =&gt; &#123;</span><br><span class="line">  bcrypt.hash(newUser.password, salt, (err, hash) =&gt; &#123;</span><br><span class="line">    if(err) throw err;</span><br><span class="line">    newUser.password = hash;</span><br><span class="line">    newUser.save()</span><br><span class="line">    .then(user =&gt; res.json(user))</span><br><span class="line">    .catch(err =&gt; console.log(err));</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><strong>Using Postman to check the response from dcrypt</strong>: x-www-form-urlencoded should be checked</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//Do NOT foget to set the x-www-form-urlencoded in the Postman</span><br></pre></td></tr></table></figure><ol start="3"><li><p>Email &amp; Password Login</p></li><li><p>Password JWT Authentication Strategy： 基于token 的认证</p></li><li><p>server-side validation </p><ul><li>login:</li><li>register:</li><li>is-empty:</li></ul></li></ol></li></ol><h2 id="Profile-API-Routes"><a href="#Profile-API-Routes" class="headerlink" title="Profile API Routes"></a>Profile API Routes</h2><ol><li>Create the Profile model</li><li>current user profile route</li><li>create &amp; update peofile routes</li><li>profile Field Validations</li><li>More Profile API Routes</li><li>Add Expereience &amp; Education Routes</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Web Development </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>572 复习</title>
      <link href="/2018/09/29/572-%E5%A4%8D%E4%B9%A0/"/>
      <url>/2018/09/29/572-%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="5-2-Inverted-Index-Phase-One"><a href="#5-2-Inverted-Index-Phase-One" class="headerlink" title="5.2 : Inverted Index Phase One"></a>5.2 : Inverted Index Phase One</h1><ol><li><p>Skip Pointer: is techniques to speed up the merging posting </p></li><li><p>Phrase Query: </p><ul><li>Bi-word indexes</li><li>Positional index</li></ul></li></ol><h1 id="2-2-Search-Engine-Evaluation"><a href="#2-2-Search-Engine-Evaluation" class="headerlink" title="2.2 Search Engine Evaluation"></a>2.2 Search Engine Evaluation</h1><table><thead><tr><th>Recall</th><th>Precison (分母动态)</th></tr></thead><tbody><tr><td>tp/(tp + fp)</td><td>tp/(tp + fn)</td></tr><tr><td>(A &amp; B)/A        A:relevant, B: retrieved</td><td>(A &amp; B)/B</td></tr><tr><td></td></tr></tbody></table><ul><li><p>harmonic mean of the precision and the recall</p><p>F = 2PR/(P + R)</p></li><li><p>accuracy of an Engine:</p><p>(tp + tn)/(tp + tn + fp + fn)</p></li><li></li></ul><hr><ul><li><p>Precision, Recall:</p><ul><li><p><strong>Defination</strong>: </p><ul><li><ol><li>Precision: # of retrieved relevant / # of retrieved </li><li>Recall: # of retrieved relevant /# of relevant</li></ol></li><li><ol><li>Precision = tp / (tp + fp)</li><li>Recall = tp/(tp + fn)</li></ol></li></ul></li><li><p><strong>Harmonic mean</strong> of precision, recall (<strong>F-measure</strong>):  </p><ul><li><p>Harmonic mean of n numbers: n/(1/a1 + 1/a2 + 1/a3 + ….1/an)</p></li><li><p>F-measure = 2RP/(R + P)</p></li></ul></li><li><p><strong>MAP</strong> = Sum(AvgP(i))/Q</p></li></ul></li><li><p><strong><u>Distance Measure:</u></strong></p><ul><li><strong>4 Properties:</strong> <ul><li><ol><li>No negative </li><li>D(x, y) iff x = y </li><li>D(x, y) = D(y, x) symmetric </li><li>D(x, y) &lt;= D(x, z) + D(z, y) Triangle Inequality</li></ol></li></ul></li><li><strong>5 Specific distance measure :</strong><ul><li><ol><li><strong>Jaccard Distance</strong>: (<strong>Jaccard Similarity</strong>: (A &amp;B) /( A or B); <strong>Jaccard Distance</strong>: 1- JS)</li><li>Hamming Distance: </li><li>Euclidean Distance</li></ol></li></ul></li></ul></li><li><p><strong><u>Coordination of Distributed Crawlers</u></strong></p><ul><li>3 different ways the crawlers can interact:<ul><li><ol><li>Independent: no coordination, every process follows its extracted links</li><li>Dynamic assignment: a central coordinator dynamically divides the web into small partitions and assign each partition to a process</li><li>static assignment: web is partitioned and assigned without a central coordinator before the crawler starts.</li></ol></li></ul></li></ul></li><li><p><strong>DCG</strong> (Discounted Cumulative Gain) :</p><p>= REL(1) + REL(2)/log(3) + REL(3)/log(4) + ….REL(n)/log(n + 1)</p></li><li><p><strong>Power Law</strong>: y = K*x^C</p><ul><li><p><strong>Zipf’s Law</strong>: y = 1/x</p><ul><li><p>y is <u>the frequency of the word</u>, and x is <u>its ranking</u> in the frequency table. C = -1.</p></li><li><p>Zipf’s law—log-log scale:</p><p>since <u>data has exponetial grow</u>, when using log-log scale, it <u>becomes a straight line</u> with slope c like: logy = logK + Clogx</p></li></ul></li><li><p><strong>Heap’s Law</strong>: V= Kn^C</p><ul><li>If V is the <strong>size of the vocabulary</strong> and n is the <strong>number of words</strong></li><li>K = 10 ~ 100， C= 0.4 ~ 0.6</li></ul></li></ul></li><li><p><strong>Skip pointer</strong>:</p><ul><li>speed up the merging of positing in an inverted index</li></ul></li><li><p><strong>SoundEx algorithm</strong>:</p><ul><li>For <u>term with the same pronunciation</u> to be <u>encoded to the same string</u> so that matching can occur despite minor difference in spelling.</li></ul></li><li><p><strong>Cosine Similarity</strong>: </p><ul><li>sum(Ai <em>Bi)/sqrt(sum(Ai^2)) </em>sum(Bi^2)</li></ul></li><li><p><strong>HITS</strong>: Hubs and Authority </p></li><li><p><strong>MRR</strong>(Mean Reciprocal Rank):  把rank倒数过来， 求平均数 sum(1/rank(Qi))/N</p><ul><li>= sum(1/rank(Qi))/N</li></ul></li><li><p><strong>Lexicon</strong> (词典字典）: The database of the vocabulary of a particular domain</p><p><strong>Tokenization</strong>（语义切分）: The task of chopping a document into pieces called tokens,and possibly throw away possible characters.</p></li><li><p>properties of <strong>Crytographic Hash Function</strong>: </p><ul><li><p>three main <strong>properties</strong>:</p><ol><li><p>easy to calculate hash value for any given data (对已知data hash 容易)</p></li><li><p>difficult to get text that has a given hash vlaue (从hash value得到text难)</p></li><li><p>a small change to data yields a different hash value (较小的改变可能产生不同的hash value)</p></li><li><p>——不记了</p></li></ol></li><li><p><strong>hash functions</strong>: MD5, SHA-1(SHA-2)</p></li></ul></li><li><p><strong>Collection frquency of term</strong>: is the num of times term t appears in he collection of document, counting multiple appearances. </p></li><li></li><li></li><li></li><li></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>讲座</title>
      <link href="/2018/09/26/%E8%AE%B2%E5%BA%A7/"/>
      <url>/2018/09/26/%E8%AE%B2%E5%BA%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="数学归纳法构建：-线，-树，图！"><a href="#数学归纳法构建：-线，-树，图！" class="headerlink" title="数学归纳法构建： 线， 树，图！"></a>数学归纳法构建： 线， 树，图！</h2><p>写样列， 观察， 找合适的数据结构， 分清楚op,  corner cases, coding </p><p>线性： for(0…n) + op[a_i] = for(a[…])</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(0...n)&#123;</span><br><span class="line">    op[a_i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线性模型： 走来走去只有一个方向可以走</p><p>树型模型：</p><p>！！！学会画树模型</p><p>图模型： （$$$$$DAG)</p><p>(其他： DCG(topo), UG)</p><p>树没有交叉， 图会有交叉， 那么就会产生重复计算， 所以立马想到要用memorazation + DFS/DP</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Union Find 总结</title>
      <link href="/2018/09/19/Union-Find-%E6%80%BB%E7%BB%93/"/>
      <url>/2018/09/19/Union-Find-%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Union-Find-可以处理什么问题"><a href="#Union-Find-可以处理什么问题" class="headerlink" title="Union-Find 可以处理什么问题"></a>Union-Find 可以处理什么问题</h2><ol><li>连接问题：<strong>网络(graph, tree)中节点间的连接状态</strong></li></ol><p>两点之间是否存在一个path将两点连接起来。</p><ol start="2"><li>数学中的集合类的实现（集合的并集）</li></ol><p>##区别： 连接问题（T/F）和路径问题(All solution)</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>git基本操作</title>
      <link href="/2018/09/16/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/09/16/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="git基本操作"><a href="#git基本操作" class="headerlink" title="git基本操作"></a>git基本操作</h1><blockquote><p>包含多个branch:  master</p><p>​                qa</p><p>​                     dashborad</p><pre><code>......</code></pre></blockquote><a id="more"></a><ol><li>从git上把project取下来</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; git clone http://......</span><br></pre></td></tr></table></figure><ol start="2"><li>进入摸个文件夹</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; cd someFolder</span><br></pre></td></tr></table></figure><ol start="3"><li>查看当前状态</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; git status</span><br></pre></td></tr></table></figure><ol start="4"><li>从当前的master branch 转到qa branch 上去</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; git chckout qa</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; git status .....</span><br></pre></td></tr></table></figure><ol start="6"><li>把当前all改动加入到branch中去</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; git add -A</span><br></pre></td></tr></table></figure><ol start="7"><li>commit当前操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; git cimmit 0m &quot;msg&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; git pull origin qa</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; git push origin qa</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>复习错题frequency List</title>
      <link href="/2018/08/27/%E5%A4%8D%E4%B9%A0%E9%94%99%E9%A2%98frequency-List/"/>
      <url>/2018/08/27/%E5%A4%8D%E4%B9%A0%E9%94%99%E9%A2%98frequency-List/</url>
      
        <content type="html"><![CDATA[<blockquote><ol><li><p>分解问题的角度: fix 某一维度，尝试另一维度上的所有可能     </p><p>a. 可能是array的(i, j)pointers, b. 可能是矩形的长与宽, c. 可能是tree的每一个subtree, d. 可能是情景题的每一对pair…    </p></li><li><p>求所有解的, 暴力上backtracking吧  </p></li><li><p>如果问最短/最少的, 先想BFS、DP这对好基友  </p></li><li><p>如果环相关/重复访问, DFS + visited state雄起  </p></li><li><p>如果问连通性, 静态靠DFS/BFS, 动态靠Union-Find  </p></li><li><p>如果有依赖性, 想想Topologic order 和indegree  </p></li><li><p>DAG的万能套路 DFS+memo, 再到DP </p></li><li><p>建图的时候想想vertex, edges/neighbors, cost分别是什么。如果出现cycle, 别忘了给vertex增加状态  </p></li><li><p>树相关, 永远有backtracking 和 pure recursion两条路  </p></li><li><p>遇到字符串/字典/char board相关的, Trie tree总是可以试试的  </p></li><li><p>Range里求最大/最小/sum等特征值, Segment tree会是不错的选择 </p></li><li><p>Matrix和Array通常都是1. Two Pointers, 2. Sliding Window(fixed &amp; not fixed), 3. DP  </p></li><li><p>DP题型往往是: a. 问你可不可以啊, 数量有多少啊, b. 两个string上match来match去的, c. 1D/2D array 相关, d. 博弈游戏  </p></li><li><p>破解DAG cycle想想哪个维度是具有单调性的: 常见的steps, directions, paths </p></li><li><p>Reversed idea非常重要, 可能会帮助你破题: 最长可能是某种最短的反面, 最多可能是某种最少的反面, obstacle的反面是reachable, subarray的反面是array中的剩下元素, left的反面是right。  </p></li><li><p>Look up别忘了HashMap/HashSet, HashMap + DLL是常见hybrid数据结构。</p></li><li><p>找规律试试那些旁门左道: 单调Stack/双端Deque  </p></li><li><p>排序大法总是可以试试的  </p></li><li><p>时空复杂度: </p><p>a. backtracking相关, 想想branching factor和height                           </p><p>b. DFS+memo/DP相关, 想想state数量, 以及每个state的cost                           </p><p>c. tree相关, 总是要考虑balanced 和 single linked list的                            </p><p>d. array/矩阵相关, 先数数你有多少个for loops                            </p><p>e. binary search application相关, 别忘了check function开销                           </p><p>f. stack/queue/deque相关, 常说的吃进去一次又吐出来一次                           </p><p>g. Java的string是朵奇葩, string concatenation不是免费的                           </p><p>h. 没人知道n是什么, 先告诉别人m，n，k，V，E是什么  </p></li><li><p>比较不同sol的trade offs: </p><p>a. Time/Space complexity异同                                               </p><p>b. online/offline算法                                               </p><p>c. pre-computation cost                                               </p><p>d. 不同APIs的call frequency差异会导致不同的时间要求                                               </p><p>e. extension: 是否适用于generic parameters/stream input                                               </p><p>f. 线程安全/large scale</p></li></ol><p>以上转载别处博客~</p></blockquote><a id="more"></a><h2 id="错题集"><a href="#错题集" class="headerlink" title="错题集"></a>错题集</h2><table><thead><tr><th style="text-align:left">Quesiton</th><th style="text-align:center">Frequency</th><th style="text-align:center">Diffuculty</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">312.  Burst Balloons</td><td style="text-align:center">1</td><td style="text-align:center">H</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">727. Minimum Window Subsequence</td><td style="text-align:center">1</td><td style="text-align:center">H</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">97.    Interleaving String</td><td style="text-align:center">1</td><td style="text-align:center">H</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">115.    Distinct subsequence</td><td style="text-align:center">1</td><td style="text-align:center">H</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">524.    Longest Word in Dictionary through Deleting</td><td style="text-align:center">1</td><td style="text-align:center">M</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">174. Dungeon Game</td><td style="text-align:center">1</td><td style="text-align:center">H</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">221. Maximal Squares</td><td style="text-align:center">1</td><td style="text-align:center">M</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">322. Coin Change</td><td style="text-align:center">1</td><td style="text-align:center">M</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">343. Integer Break</td><td style="text-align:center">1</td><td style="text-align:center">M</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">357. COunt Numbers with Unique Digits</td><td style="text-align:center">1</td><td style="text-align:center">M</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">300. Longest Increasing Subsequence</td><td style="text-align:center">2</td><td style="text-align:center">M</td><td style="text-align:left">DP; Patient sort</td></tr><tr><td style="text-align:left">265. Paint House II</td><td style="text-align:center">2</td><td style="text-align:center">H</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">277. FInd the celebrity</td><td style="text-align:center">1</td><td style="text-align:center">M</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">301. Remove Invalid Parentheses</td><td style="text-align:center">2</td><td style="text-align:center">H</td><td style="text-align:left">BFS最短路径问题</td></tr><tr><td style="text-align:left">122. Best Time to Buy and Sell II (unlimited transactions)</td><td style="text-align:center">2</td><td style="text-align:center">E</td><td style="text-align:left">Greedy sum += (price[i] - price[i - 1])</td></tr><tr><td style="text-align:left">123. Best Time to Buy and Sell Stock III (at most two times)</td><td style="text-align:center">2</td><td style="text-align:center">H</td><td style="text-align:left">DP: state machine</td></tr><tr><td style="text-align:left">188. Best Time to Buy and Sell Stock IV (at most k transactions)</td><td style="text-align:center">2</td><td style="text-align:center">H</td><td style="text-align:left">DP: state machine</td></tr><tr><td style="text-align:left">689. Maximum Sum of 3 No-Overlaping Subarray</td><td style="text-align:center">2</td><td style="text-align:center">H</td><td style="text-align:left">逆向思维： 划定中间range, 找到两边的range中的那个subarray 有max sum.</td></tr><tr><td style="text-align:left">680. Valid Palindrome II</td><td style="text-align:center">2</td><td style="text-align:center">E</td><td style="text-align:left">双指针向内缩进， 不相等char(delete), 调用isPalindrome: 整体O(n)</td></tr><tr><td style="text-align:left">161. One Edit Distance</td><td style="text-align:center">2</td><td style="text-align:center">M</td><td style="text-align:left">O(n), 双指针同时forwar, char不相等时(Edit)： 调用postfixStr1.equals(postfixStr2)</td></tr><tr><td style="text-align:left">352. Data Stream as Disjoint Intervals</td><td style="text-align:center">2</td><td style="text-align:center">H</td><td style="text-align:left">使用TreeSet数据结构实现Binary Search O(logn)的search/insert/remove.  取代list中search(O(n))/insert:O(n)/remove:O(n)</td></tr><tr><td style="text-align:left"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dynamic Programming 总结</title>
      <link href="/2018/06/28/Dynamic-Programming-%E6%80%BB%E7%BB%93/"/>
      <url>/2018/06/28/Dynamic-Programming-%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="DP的解题常用方法："><a href="#DP的解题常用方法：" class="headerlink" title="DP的解题常用方法："></a>DP的解题常用方法：</h1><h2 id="1-一维的original-data-such-as-a-rope-a-word-a-peice-of-wood-求MAX-or-MIN-cut-merge-etc…"><a href="#1-一维的original-data-such-as-a-rope-a-word-a-peice-of-wood-求MAX-or-MIN-cut-merge-etc…" class="headerlink" title="1. 一维的original data(such as a rope, a word, a peice of wood), 求MAX or MIN(cut, merge, etc…)"></a>1. 一维的original data(such as a rope, a word, a peice of wood), 求MAX or MIN(cut, merge, etc…)</h2><p>1.1 if the <strong>weight</strong> of each smallest elements in the original data is <strong>identical/similar</strong></p><p>1.1.1. e.g. <strong>identical</strong>: 1 meter of rope</p><p>1.1.2. e.g. <strong>similar</strong>: a letter, a number</p><p>这种类似的题目有可以用：</p><p><strong><u>Linear scan and look back to the previous elments</u></strong></p><a id="more"></a><p>####例题 1：Longest Ascending Subarray (Linear Scan 回头看 ， 看一个)</p><p>Given an unsorted array, find the length of longest ascending subarray.</p><p>e.g.:  {7, 2, 3, <strong>1, 5, 8, 9</strong>, 6}</p><p>output: 4    </p><p>solution:</p><p>input:    {7, 2, 3, <strong>1, 5, 8, 9</strong>, 6}</p><p>dp[i]:       1, 1, 2, <strong>1, 2, 3, 4,</strong> 1</p><p>dp[i]: the length of longest ascending subarray include i-th element</p><p><img src="http://server.myspace-shack.com/d23/27054dc4-2162-492e-bcdf-cbbb81ebc709.png" alt=""></p><ol><li>Base case: M[0] = 1;</li><li>Induction Rule:  M[i] represents (from the 0-th element to the i-th element)</li></ol><p>M[i] = M[i] + 1     if nums[i] &gt; nums[i - 1]</p><p>​            1                if nums[i] &lt;= nums[ i - 1]</p><h4 id="例题2：Maximal-Product-when-Cutting-a-Rope-（Linear-Scan回头看，-看所有cases）"><a href="#例题2：Maximal-Product-when-Cutting-a-Rope-（Linear-Scan回头看，-看所有cases）" class="headerlink" title="例题2：Maximal Product when Cutting a Rope （Linear Scan回头看， 看所有cases）"></a>例题2：Maximal Product when Cutting a Rope （Linear Scan回头看， 看所有cases）</h4><p><img src="http://server.myspace-shack.com/d23/39b05d9f-adff-456e-9cbd-0391fa63b18c.png" alt=""></p><p><img src="http://server.myspace-shack.com/d23/063f85e9-791c-4299-985f-f152568a7c09.png" alt=""></p><p><img src="http://server.myspace-shack.com/d23/7f5e8a60-cbbd-424b-8dda-96dc2faac637.png" alt=""></p><p><img src="http://server.myspace-shack.com/d23/f3d6a9ef-4935-4d8a-b851-6223890ed91a.png" alt=""> </p><p>LeetCode 279. Perfect Square</p><p>####方法二： 更重要！！更general</p><p><img src="http://server.myspace-shack.com/d23/48cf1f92-7771-4e71-a370-f2e3f559af83.png" alt=""></p><p><img src="http://server.myspace-shack.com/d23/faa64d3e-9137-40c7-8a5f-19126bdc3b0f.png" alt=""></p><p>右小段是只考虑<strong>最后一步怎么处理的</strong>， 然后再往前思考！</p><h4 id="方法三：-Non-DP-Recursion-可能有些题目需要memorization减少运行时间"><a href="#方法三：-Non-DP-Recursion-可能有些题目需要memorization减少运行时间" class="headerlink" title="方法三： (Non-DP) Recursion + (可能有些题目需要memorization减少运行时间)"></a>方法三： (Non-DP) Recursion + (可能有些题目需要memorization减少运行时间)</h4><p>主要思路也是延续方法二： 只考虑最后一步怎么处理， 再往小的问题思考</p><p>比如： getMaxProduct of cutting rope with size n, 可以分出几个叉来？</p><p>—最后一步枚举我可以切1m, or 2m, or 3m….(n-1)m， 用一个for loop就可以表示出来。</p><p>然后计算maxProduct of cutting n, 再return maxProduct</p><p><img src="http://server.myspace-shack.com/d23/1db00d8d-dbdf-4113-9682-366addef021e.png" alt=""></p><h3 id="例题3：-又是一种新的一维题型（从右往左看—linear-Scan回头看，-看全部）"><a href="#例题3：-又是一种新的一维题型（从右往左看—linear-Scan回头看，-看全部）" class="headerlink" title="例题3： 又是一种新的一维题型（从右往左看—linear Scan回头看， 看全部）"></a>例题3： 又是一种新的一维题型（从右往左看—linear Scan回头看， 看全部）</h3><p><img src="http://server.myspace-shack.com/d23/eef7ddce-041b-458a-bebb-afc2fcb97cee.png" alt=""></p><p>从右往左看 + linear Scan 回头看， 看全部</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Recursion-2总结</title>
      <link href="/2018/06/19/Recursion-2%E6%80%BB%E7%BB%93/"/>
      <url>/2018/06/19/Recursion-2%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Recursion和数学运算的总结"><a href="#Recursion和数学运算的总结" class="headerlink" title="Recursion和数学运算的总结"></a>Recursion和数学运算的总结</h1><a id="more"></a><h2 id="recursion在数学计算上的陷阱："><a href="#recursion在数学计算上的陷阱：" class="headerlink" title="recursion在数学计算上的陷阱："></a>recursion在数学计算上的陷阱：</h2><ol><li><p>0 as the denominator</p></li><li><p>1/3 as an integer?? or float (精度问题)</p></li><li><p>0^0 无意义</p></li></ol><p>##1. a^b</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public double power(double a, double b)&#123;</span><br><span class="line">   if(a == 0 &amp;&amp; b &lt;= 0)</span><br><span class="line">   return -1;</span><br><span class="line">   else if(b &lt; 0)&#123;</span><br><span class="line">       return 1/(double)pow(a,-b);</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">       return (double)pow(a, b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//主逻辑：a为负数的时候也可以处理</span><br><span class="line">public int pow(int a,int b)&#123;</span><br><span class="line">    if(b == 0)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int half_res = pow(a, b/2);</span><br><span class="line">    if(b % 2 == 0)&#123;</span><br><span class="line">        return half_res * half_res;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return half_res * half_res*a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Recursion与-1D-or-2D-Array的结合"><a href="#2-Recursion与-1D-or-2D-Array的结合" class="headerlink" title="2. Recursion与 1D or 2D Array的结合"></a>2. Recursion与 1D or 2D Array的结合</h2><h3 id="1-在-1D-array-二分法比较常见"><a href="#1-在-1D-array-二分法比较常见" class="headerlink" title="1.在 1D array: 二分法比较常见"></a>1.在 1D array: 二分法比较常见</h3><p>1.1 MergeSort</p><p>1.2 QuickSort</p><h3 id="2-在-2D-array"><a href="#2-在-2D-array" class="headerlink" title="2. 在 2D array:"></a>2. 在 2D array:</h3><p>2.1 逐层（row by row) 递归： 8 queen –&gt; n queen</p><p>8皇后问题： 每行每列只能有一个Q, 每个Q可以在8个方向上相互攻击， 找到8皇后问题的所有解使得8皇后不能相互攻击？</p><p>–因为每行每列只能放一个Q: 我们可以逐行的去放Q, 用一个一维数组的index来代表行数，value代表Q放在在index 行value列</p><p>如： 【0， 3， 2， 1， 4， 6， 5， 7】</p><p>查看这样一种摆放方式是否会引起相互攻击。</p><p>类似permutation的问题：</p><p>【0， 3， 2， 1， 4， 6， 5， 7】</p><p>Recursion Tree:</p><p>​                                                       []</p><p>Level 0:                      /     /     /    /     \      \    \    \</p><p>for idx_i 放在0_th col           ……3rd col           …  7-th col</p><p>Level 1:  / / / / \ \ \        / / / / \ \ \ \   ……………………………../ / / / \ \ \ \</p><p>Level 2: …….</p><p>Level 3: ……</p><p>…..</p><p>Level 7:</p><p>Time: (8 ^ 8)—&gt; O(8!)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void eightQueen(int[] A, int index)&#123;</span><br><span class="line">    if(index == n)  //base case: 到了最底层--即最后一个index</span><br><span class="line">    //print A[N];</span><br><span class="line">    </span><br><span class="line">    for(int i = 0; i &lt; N; i++)&#123; //N-叉树的写法： we can try N column to put new Queen</span><br><span class="line">        A[index] = i;  //i is the column number</span><br><span class="line">        //check whether this configuration is valid or not</span><br><span class="line">        //using a helper funciton to check whether A[0.... index - 1] </span><br><span class="line">        confilicts the current queen inserted or not</span><br><span class="line">        </span><br><span class="line">        if(pass the check)&#123;</span><br><span class="line">        eightQueen(A, index + 1); //recursive rule</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2 How to print 2D array in spiral order (N*N)</p><p><img src="http://server.myspace-shack.com/d23/de59e730-672f-431e-998e-428340f48152.png" alt=""></p><p>一层一层像剥洋葱圈一样打印出来</p><p>每次recursion都是打印一圈， 然后再往里打印, 直到size &lt;= 0时</p><ul><li>size每剥一圈皮，size 都会 - 2</li><li>每次先答应upper-level, right-column, lower-level, left-column (全是for循环)</li><li>offset: 查看每圈的左上角， A[0 + offeset][i + offset]</li><li>recursion rule: 继续往里一层： spiralprint(A, offset + 1， size - 2,  counter)</li></ul><p><img src="http://server.myspace-shack.com/d23/3e4a4416-1628-41e9-ab6f-518f17862b29.png" alt=""></p><h2 id="3-Recursion-on-Linked-List"><a href="#3-Recursion-on-Linked-List" class="headerlink" title="3. Recursion on Linked List"></a>3. Recursion on Linked List</h2><h3 id="3-1-Reverse-Linked-List-鼻祖题"><a href="#3-1-Reverse-Linked-List-鼻祖题" class="headerlink" title="3.1 Reverse Linked List (鼻祖题)"></a>3.1 Reverse Linked List (鼻祖题)</h3><p><img src="http://server.myspace-shack.com/d23/66042989-3118-4bcb-a5f2-bfbdf4c17ac3.png" alt=""></p><h3 id="3-2-Reverse-Linked-List-pair-by-pair"><a href="#3-2-Reverse-Linked-List-pair-by-pair" class="headerlink" title="3.2 Reverse Linked List (pair by pair)"></a>3.2 Reverse Linked List (pair by pair)</h3><p><img src="http://server.myspace-shack.com/d23/821936dc-3ce9-41a2-b86f-4c60e3aa81f5.png" alt=""></p><h2 id="4-Recursion-与String的结合"><a href="#4-Recursion-与String的结合" class="headerlink" title="4. Recursion 与String的结合"></a>4. Recursion 与String的结合</h2><h3 id="4-1-Reverse-a-string-using-recursion"><a href="#4-1-Reverse-a-string-using-recursion" class="headerlink" title="4.1 Reverse a string using recursion"></a>4.1 Reverse a string using recursion</h3><p>abcd –&gt; dcba</p><p>i       j</p><p>​     a | b XXXXXXc| d</p><p>​     i                             j</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void reverseString(char[] input, int i , int j)&#123;</span><br><span class="line">if( i &gt;= j)</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h3><h2 id="5-Recursion与Tree的结合"><a href="#5-Recursion与Tree的结合" class="headerlink" title="5. Recursion与Tree的结合"></a>5. Recursion与Tree的结合</h2><p><img src="http://server.myspace-shack.com/d23/101d9cbb-a5af-4fd9-bcec-2fbbaf7b4bba.png" alt=""></p><h3 id="5-1-Tree-Recursion-第一类问题：-从下往上返回值（int-bool-etc"><a href="#5-1-Tree-Recursion-第一类问题：-从下往上返回值（int-bool-etc" class="headerlink" title="5.1 Tree + Recursion 第一类问题： 从下往上返回值（int, bool, etc.)"></a>5.1 Tree + Recursion 第一类问题： 从下往上返回值（int, bool, etc.)</h3><h3 id="思考三部曲："><a href="#思考三部曲：" class="headerlink" title="思考三部曲："></a>思考三部曲：</h3><p><img src="http://server.myspace-shack.com/d23/15ffc11f-836e-4c4c-8601-f492016fbc4b.png" alt=""></p><h4 id="5-1-1-从下往上返值-Review"><a href="#5-1-1-从下往上返值-Review" class="headerlink" title="5.1.1 (从下往上返值) Review"></a>5.1.1 (从下往上返值) Review</h4><p>int getHeight（TreeNode root){</p><p>}</p><h3 id="5-1-2-从下往上返值-How-to-store-how-many-nodes-in-each-node’s-left-subtree"><a href="#5-1-2-从下往上返值-How-to-store-how-many-nodes-in-each-node’s-left-subtree" class="headerlink" title="5.1.2(从下往上返值) How to store how many nodes in each node’s  left subtree?"></a>5.1.2(从下往上返值) How to store how many nodes in each node’s  left subtree?</h3>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树---总结</title>
      <link href="/2018/06/19/%E6%A0%91-%E6%80%BB%E7%BB%93/"/>
      <url>/2018/06/19/%E6%A0%91-%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="常见题目"><a href="#常见题目" class="headerlink" title="常见题目"></a>常见题目</h1><a id="more"></a><p><img src="http://server.myspace-shack.com/d23/83f75c01-2df3-4fdc-88aa-7587bb93f206.png" alt=""></p><p><img src="http://server.myspace-shack.com/d23/05a326cc-2a6a-4a76-90da-9840f3c658e0.png" alt=""></p><h1 id="基本知识：-模板-必背"><a href="#基本知识：-模板-必背" class="headerlink" title="基本知识： 模板(必背)"></a>基本知识： 模板(必背)</h1><h2 id="1-Preorder"><a href="#1-Preorder" class="headerlink" title="1. Preorder"></a>1. Preorder</h2><p><img src="http://server.myspace-shack.com/d23/c4ce23d4-24bb-4317-9e10-903d7a3aa84a.png" alt=""></p><p>或者：<br><img src="http://server.myspace-shack.com/d23/158189fc-47ca-4a52-bc0f-7378c70924f1.png" alt=""></p><h2 id="2-Inorder"><a href="#2-Inorder" class="headerlink" title="2. Inorder"></a>2. Inorder</h2><ol><li><p>Recursion </p></li><li><p>Iterative </p><p><img src="http://server.myspace-shack.com/d23/42299e7d-3a67-41ca-88b5-05b8f840164e.png" alt=""></p></li></ol><h2 id="3-Postorder"><a href="#3-Postorder" class="headerlink" title="3. Postorder"></a>3. Postorder</h2><ol><li>Recursion</li><li>Iterative</li></ol><p><img src="http://server.myspace-shack.com/d23/0c94f3a5-6b20-42a2-820f-e7656822a794.png" alt=""></p><h2 id="4-Level-order"><a href="#4-Level-order" class="headerlink" title="4. Level-order"></a>4. Level-order</h2><ol><li>Iterative (BFS-层序遍历–queue)</li><li>Recursion</li></ol><p><img src="http://server.myspace-shack.com/d23/076e0b17-cdfa-4ab6-b43a-9d3c740cd895.png" alt=""></p><h1 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h1><h3 id="preorder"><a href="#preorder" class="headerlink" title="preorder"></a>preorder</h3><ol><li>LeetCode 112. Path Sum: 路径和(一)-是否存在二叉树路径和等于给定值（根节点到叶子节点）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasPathSum(TreeNode root, int sum) &#123;</span><br><span class="line">        /*</span><br><span class="line">        双pre-order 题型</span><br><span class="line">        什么时候终止， 到叶子节点的时候！</span><br><span class="line">        </span><br><span class="line">        */</span><br><span class="line">        if(root == null)</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        if(root.left == null &amp;&amp; root.right == null) //叶子结点</span><br><span class="line">            return root.val == sum;</span><br><span class="line">        </span><br><span class="line">        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>LeetCode 113. Path Sum II: 路径和(二)-二叉树中路径和等于给定值的所有路径（根节点到叶子节点）</li></ol>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>各类模糊点总结</title>
      <link href="/2018/06/16/%E5%90%84%E7%B1%BB%E6%A8%A1%E7%B3%8A%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2018/06/16/%E5%90%84%E7%B1%BB%E6%A8%A1%E7%B3%8A%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="关于Serialize-和Deserialize的一些问题"><a href="#关于Serialize-和Deserialize的一些问题" class="headerlink" title="关于Serialize 和Deserialize的一些问题"></a>关于Serialize 和Deserialize的一些问题</h1><h2 id="1-LeetCode-297-Serialize-and-DeSerialize-Binary-Tree"><a href="#1-LeetCode-297-Serialize-and-DeSerialize-Binary-Tree" class="headerlink" title="1. LeetCode 297. Serialize and DeSerialize Binary Tree"></a>1. LeetCode 297. Serialize and DeSerialize Binary Tree</h2><p>题目：Design an algorithm to serialize and deserialize a binary tree. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">You may serialize the following tree:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">     / \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">as &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-LeetCode-652-Find-Duplicate-Subtrees"><a href="#2-LeetCode-652-Find-Duplicate-Subtrees" class="headerlink" title="2. LeetCode 652. Find Duplicate Subtrees"></a>2. LeetCode 652. Find Duplicate Subtrees</h2><p>题目： Given a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any <strong>one</strong>of them.</p><p>Two trees are duplicate if they have the same structure with same node values.</p><p>//画recursion tree</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> /   / \</span><br><span class="line">4   2   4</span><br><span class="line">   /</span><br><span class="line">  4</span><br></pre></td></tr></table></figure><p>The following are two duplicate subtrees:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>and</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>Therefore, you need to return above trees’ root in the form of a list.</p><h2 id="3-LeetCode-572-Subtree-of-Another-Tree"><a href="#3-LeetCode-572-Subtree-of-Another-Tree" class="headerlink" title="3. LeetCode 572. Subtree of Another Tree"></a>3. LeetCode 572. Subtree of Another Tree</h2><p><strong>Example 1:</strong><br>Given tree s:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br><span class="line"> / \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>Given tree t:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  4 </span><br><span class="line"> / \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>Return </p><p>true</p><p>, because t has the same structure and node values with a subtree of s.</p><p><strong>Example 2:</strong><br>Given tree s:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br><span class="line"> / \</span><br><span class="line">1   2</span><br><span class="line">   /</span><br><span class="line">  0</span><br></pre></td></tr></table></figure><p>Given tree t:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  4</span><br><span class="line"> / \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>Return </p><p>false</p><h1 id="关于—前缀和"><a href="#关于—前缀和" class="headerlink" title="关于—前缀和"></a>关于—前缀和</h1><h2 id="1-前缀和-hashTable"><a href="#1-前缀和-hashTable" class="headerlink" title="1.前缀和 + hashTable"></a>1.前缀和 + hashTable</h2><h3 id="1-LeetCode-560-Subarray-Sum-Equals-K"><a href="#1-LeetCode-560-Subarray-Sum-Equals-K" class="headerlink" title="1. LeetCode 560. Subarray Sum Equals K"></a>1. LeetCode 560. Subarray Sum Equals K</h3><p>Given an array of integers and an integer <strong>k</strong>, you need to find the total number of continuous subarrays whose sum equals to <strong>k</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:nums = [1,1,1], k = 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The length of the array is in range [1, 20,000].</li><li>The range of numbers in the array is [-1000, 1000] and the range of the integer <strong>k</strong> is [-1e7, 1e7].</li></ol><h3 id="2-LeetCode-325-Maximum-Size-Subarray-Sum-Equals-K"><a href="#2-LeetCode-325-Maximum-Size-Subarray-Sum-Equals-K" class="headerlink" title="2. LeetCode 325. Maximum Size Subarray Sum Equals K"></a>2. LeetCode 325. Maximum Size Subarray Sum Equals K</h3><p>Given an array <em>nums</em> and a target value <em>k</em>, find the maximum length of a subarray that sums to <em>k</em>. If there isn’t one, return 0 instead.</p><p><strong>Note:</strong><br>The sum of the entire <em>nums</em> array is guaranteed to fit within the 32-bit signed integer range.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1, -1, 5, -2, 3], k = 3</span><br><span class="line">Output: 4 </span><br><span class="line">Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-2, -1, 2, 1], k = 1</span><br><span class="line">Output: 2 </span><br><span class="line">Explanation: The subarray [-1, 2] sums to 1 and is the longest.</span><br></pre></td></tr></table></figure><p><strong>Follow Up:</strong><br>Can you do it in O(<em>n</em>) time?</p><p>.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DP做题积累</title>
      <link href="/2018/06/14/DP%E5%81%9A%E9%A2%98%E7%A7%AF%E7%B4%AF/"/>
      <url>/2018/06/14/DP%E5%81%9A%E9%A2%98%E7%A7%AF%E7%B4%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Number-of-ways"><a href="#1-Number-of-ways" class="headerlink" title="1. Number of ways"></a>1. Number of ways</h1><p>##1. 1： LeetCode 91. Decode Ways</p><p>A message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;A&apos; -&gt; 1</span><br><span class="line">&apos;B&apos; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&apos;Z&apos; -&gt; 26</span><br></pre></td></tr></table></figure><p>Given a <strong>non-empty</strong> string containing only digits, determine the total number of ways to decode it.</p><a id="more"></a><p>###分析： </p><p>E.g:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;2 2 6 1 5 2&quot;</span><br><span class="line">output: 6</span><br><span class="line"></span><br><span class="line">分析：</span><br><span class="line">      2 2 6 1 5 2</span><br><span class="line">    p c |</span><br><span class="line">    </span><br><span class="line">           w(2 2 6 1 5)</span><br><span class="line">           / valid(5)  \  valid(15)</span><br><span class="line">       w(2 2 6 1)  +   w(2 2 6)</span><br><span class="line">       /v(1) \v(61)wrg  /   \  v(26)</span><br><span class="line"> w(2 2 6)  +           w(2 2)  w(2)</span><br><span class="line">   /    \            </span><br><span class="line"> w(2 2)+w(2)</span><br><span class="line">  /  \     |</span><br><span class="line">w(2) w(&apos;&apos;) 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总体来说：</span><br><span class="line">dp[i] : total number of ways to decode string from index 0 to index i-th</span><br><span class="line"></span><br><span class="line">base case:</span><br><span class="line">1. empty string: dp[-1] = 1;  //empty string</span><br><span class="line">2. s.length = 1: dp[0] = 1; if s[0] != &apos;0&apos;</span><br><span class="line"></span><br><span class="line">dp rules:</span><br><span class="line">1.  ans = 0, if both s[i]; s[i - 1]s[i] invalid</span><br><span class="line">2. dp[i] = dp[i - 1] + dp[i - 2] if both s[i]; s[i - 1]s[i] valid</span><br><span class="line">3. dp[i] = dp[i - 1] if only s[i] valid</span><br><span class="line">4. dp[i] = dp[i - 2] if only s[i - 1]s[i] valid</span><br><span class="line"></span><br><span class="line">valid(char a): 0&lt; n &lt;= 9</span><br><span class="line">valid(char a, char b): </span><br><span class="line">      int n = (a - &apos;0&apos;) * 10 + (b - &apos;0&apos;);</span><br><span class="line">      --&gt;  10 &lt;= n &lt;= 26</span><br><span class="line">   </span><br><span class="line">根据dp rule可知： dp[i] 只与dp[i - 1]和dp[i - 2]有关系</span><br><span class="line">用两个临时变量保存下前两位值就可以了： int pre, cur</span><br><span class="line"></span><br><span class="line">初始化 int pre = 1, cur = 1;   //代表的是base case 的两种情况</span><br><span class="line"></span><br><span class="line">corner case:</span><br><span class="line">s = “0121”  string start with &apos;0&apos; ---&gt; return 0;</span><br></pre></td></tr></table></figure><p>time compelxity: O(n)</p><p>space: O(n) —&gt; 降维度后： O(1)</p><p>###代码： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numDecodings(String s) &#123;</span><br><span class="line">        </span><br><span class="line">        if(s == null || s.length() == 0 || s.charAt(0) == &apos;0&apos;)</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">        //base case:</span><br><span class="line">        int dpi_2 = 1;</span><br><span class="line">        int dpi_1 = 1;</span><br><span class="line">        </span><br><span class="line">        for(int i = 1; i &lt; s.length(); i++)&#123;</span><br><span class="line">            char si_1 = s.charAt(i - 1);</span><br><span class="line">            char si = s.charAt(i);</span><br><span class="line">            int dpi = 0;</span><br><span class="line">            </span><br><span class="line">            if(!valid(si_1, si) &amp;&amp; !valid(si)) return 0;</span><br><span class="line">            if(valid(si_1, si) &amp;&amp; valid(si))</span><br><span class="line">                dpi = dpi_2 + dpi_1;</span><br><span class="line">            else if(valid(si))</span><br><span class="line">                dpi = dpi_1;</span><br><span class="line">            else</span><br><span class="line">                dpi = dpi_2;</span><br><span class="line">            </span><br><span class="line">            //交替转化</span><br><span class="line">            dpi_2 = dpi_1;</span><br><span class="line">            dpi_1 = dpi;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        return dpi_1;   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean valid(char a)&#123;</span><br><span class="line">        int n = a - &apos;0&apos;;</span><br><span class="line">        return n &gt; 0 &amp;&amp; n &lt;= 9;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean valid(char a, char b)&#123;</span><br><span class="line">        int n = (a - &apos;0&apos;) * 10 + (b - &apos;0&apos;);</span><br><span class="line">        return n &gt;= 10 &amp;&amp; n &lt;= 26;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Bit Manipulation知识总结</title>
      <link href="/2018/06/12/Bit-Manipulation%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/2018/06/12/Bit-Manipulation%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>##基础知识：</p><a id="more"></a><ul><li><p>Bit Representation </p><p><img src="http://server.myspace-shack.com/d23/234be130-d52a-48c1-8653-567d71089aa6.png" alt=""></p></li></ul><p>int a = 0;</p><p>unsigned int a = 0;  11111111111(32个1)   表示实实在在2^32 - 1</p><p>有符号： 0： positive 1: negative</p><p>Two’s Complement:</p><p>在二进制表示中： 将1 变成 - 1</p><p><img src="http://server.myspace-shack.com/d23/2a6b89e1-d408-4b15-bd8c-ca0dd38d8b97.png" alt=""></p><ul><li><p>Bit Manipulation 的6中操作</p><ul><li><p><u><strong>&amp;</strong></u> AND      vs  if(true1 &amp;&amp; true2)</p><p><u>上下都是1 res = 1</u></p><p>​     1100 1110</p><p>&amp;  1001 1000</p><p>============</p><p>​     1000 1000</p></li><li><p>| OR vs  if(true1 || true2)</p><p><u>上下有一个或两个是1， res = 1</u></p></li><li><p>~ NOT (1-&gt;0 and 0-&gt; 1 for each bit) int c = ~a (把a 上每一位取反，赋给c)</p></li><li><p>^ XOR</p><p>（<strong>异</strong>）或—&gt;有异才有1</p><p><u>上下不相同时候， res = 1</u></p><ul><li>0 0(上下)  -&gt; 0</li><li>1 1-&gt; 0</li><li>0 1 or 1 0 -&gt; 1</li></ul><p>使用方法： ？？？？</p></li><li><p>&lt;&lt; left shift </p><ul><li><p><strong>左移右侧补0</strong></p></li><li><p>左移一位，相当于原来十进制数*2 (前提移动每越界)</p></li></ul></li><li><p>还有 &gt;&gt; right shit</p><ul><li><p>右移左侧“正数”补0， “负数”补1</p></li><li><p>右移一位，相当于原十进制数/2 (前提移动每越界)</p></li></ul></li></ul></li></ul><h1 id="Common-Questions"><a href="#Common-Questions" class="headerlink" title="Common Questions:"></a>Common Questions:</h1><ol><li><p>Given a number x, how to set x’s (右数) <u>k-th bit to 1</u>?</p><p>Eg: x = 00000….1010000<strong>Y</strong>101  k = 3</p><ul><li>任何bit 和1 取 或（|）都为1</li><li>任何bit 和0 取 或 （|） 都为它自己</li></ul><p>solution:</p><p>int <strong>bit_setter</strong> = 1 // 000000000000….00001</p><p><strong>bit_setter</strong> = bit_setter &lt;&lt; k; // 0000000…00<strong>1</strong>000</p><p>x = x | bit_setter; //重点</p></li><li><p>Given a number x, how to set x’s (右数) <u>k-th bit to 0</u>?</p><ul><li>任何bit 和 0 取 AND（&amp;） 都是0</li><li>任何bit 和 1取 AND （&amp;） 都是它自己 </li></ul><p>0000  1000  取 NOT</p><p>1111…0111</p><p>Solution:</p><p>int <strong>bit_setter</strong> = 1; // 0000….0001</p><p><strong>bit_setter</strong> = bit_setter &lt;&lt; k;  //0000…1000    k = 3</p><p><strong>bit_setter</strong> = ~bit_setter; //1111..0111</p><p>x = x &amp; bit_setter; // aaaa…Yaaa</p><p>​                &amp;1111…0111</p><p>​            ================</p><p>​                   aaaa…0aaa</p></li><li><p>determine whether a number <strong>x is a power of 2</strong>?  (x = 2^n) n &gt;0</p><p>Solution 1:非bit manipulation</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//2^n: 1 2 4 8 16 32...</span><br><span class="line">while(num &gt; 1)&#123; //把一个数一直除2， 直到它 = 1</span><br><span class="line">    if(num % 2 != 0)</span><br><span class="line">    return false;</span><br><span class="line">    num /= 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i = num; i &gt; 1; i /= 2)&#123;</span><br><span class="line">    if(i % 2 != 0)</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Solution 2: Bit manipulation (很有意思！)</p><ul><li><p><strong>x</strong> = 8是2^n， 它的二进制一定是：</p><p>​         <strong>0001000</strong>  即—只有一个1</p></li><li><p><strong>x - 1</strong>:         0000111</p><p>​        </p><p>​        0001000      x</p><p>&amp;        0000111      x - 1</p><p>=================</p><p>​                  0000000       (全为0)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean isPowerOf2(int num)&#123;</span><br><span class="line">    return (x &amp; (x - 1) == 0 &amp;&amp; x != 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>How to determine the number of bits that are different between two postive integers?</p><p>int x = 0101;</p><p>int y = 0111;</p></li></ol><p>return 1;</p><p>使用方法：</p><ul><li>XOR (异)或</li></ul><p>​        0101</p><p>​            ^  0111</p><p>​    ==========</p><p>res        0 0 10</p><ul><li><p><strong>再数一下res中有多少个1</strong></p><p>​    res    0010    </p><p><strong>res &gt;&gt; i</strong>   0001   (<strong>res &gt;&gt; i</strong> )</p><p>​    &amp;    0001     ( <strong>1</strong>)</p><p>==============</p><p>​        0001    (<strong>1</strong>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int numOfDiffBits(int x, int y)&#123;</span><br><span class="line">    int res = x ^ y;</span><br><span class="line">    </span><br><span class="line">    int count = 0;</span><br><span class="line">    for(int i = 0; i &lt; 32; i++)&#123;</span><br><span class="line">        if((res &gt;&gt; i) &amp; 1 == 1)</span><br><span class="line">        count++；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>###5. detemine whether a word  contains all letters that are unique (no <strong>duplicate letters in the word</strong>)</p><p>依题意： check 一个word中是否有重复的letter? <u>只contain a~z的小写字母</u></p><p>solution 1: hashset, boolean[] hashset = new boolean(26);  </p><p>time: O(n)</p><p>space: O(n)</p><p>Solution 2: Bit manipulation</p><p>Time: O(n) </p><p>Space: O(1)</p><p><u>用一个<strong>int dic = 0；</strong> 去模拟一个hashset</u></p><p><strong>dic:         0000 0000 0000 0000 …0000</strong>       <u>一共有32位，足够表示26个字母</u></p><p><strong>a–z                          zyx                    …….dcba</strong></p><p>=========================================</p><p><strong>int dic = 0;</strong></p><p><strong>int pos = word.charAt(i) - ‘a’;</strong>       //获得i-th letter 在dic 中的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasDupLetter(String word)&#123;</span><br><span class="line">    if(word == null || word.length() == 0)</span><br><span class="line">    return false;</span><br><span class="line">    </span><br><span class="line">    int dic = 0;</span><br><span class="line">    for(int i = 0; i &lt; word.length(); i++)&#123;</span><br><span class="line">        int pos = word.charAt(i) - &apos;a&apos;;</span><br><span class="line">        if((dic &gt;&gt; pos) &amp; 1 == 1)&#123; //char &apos;d&apos; exist</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else&#123;//把dic中‘d’位置上--pos上设为1</span><br><span class="line">            dic = dic | (1 &lt;&lt; pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Follow-Up: <strong>Assumption: not only contain a~z. contain all ASCII codes (256)</strong></p><ul><li>ASCII中一共有256个letter;</li><li>每个int dic = 0; 可以表示32个letter</li><li>所以一共需要8个这样的dics 去表示256个letters</li><li>Eg: x = ‘#’— 88      通过： x/32获得<u><strong>第几个dic</strong></u>，再通过x%32 获得它<u><strong>在这个dic中的pos</strong></u></li></ul><p>这就引出了一下：bit vector.</p><h3 id="Terminology-Bit-Vector"><a href="#Terminology-Bit-Vector" class="headerlink" title="Terminology: Bit Vector"></a>Terminology: Bit Vector</h3><p>把原有hash_table 的空间缩小了很多倍： 原来是boolean[256], 现在是 int bit_map[8];</p><p><strong>int bit_map[8];</strong>   //8 * 32 bit = 256 bits</p><ul><li>88/32 = 2 —&gt; bit_map[2]</li><li>88%32 = 24 —&gt; bit_map[2] 中int dic个的第24个bit</li></ul><p><strong>int dic = acsNum / 32;</strong> </p><p><strong>int dicPos = acsNum % 32;</strong></p><p><img src="http://server.myspace-shack.com/d23/deaec0fa-05a9-43f7-94d1-344f02aeacea.png" alt=""></p><p>Follow_up 代码：几乎和只含有a~z的题目一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasDupLetter(String word)&#123;</span><br><span class="line">if(word == null || word.length() == 0)</span><br><span class="line">return false;</span><br><span class="line"></span><br><span class="line">int[] bit_map = new int[8]; //8 个dic表示256个letter的hashtable</span><br><span class="line">for(int i = 0; i &lt; word.length(); i++)&#123;</span><br><span class="line">        int ascNum = word.charAt(i);</span><br><span class="line">        int dic = acsNum / 32;</span><br><span class="line">        int dicPos = acsNum % 32;</span><br><span class="line">        if((bit_map[dic] &gt;&gt; dicPos) &amp; 1 == 1)&#123;//&apos;#&apos; exist</span><br><span class="line">        return true;</span><br><span class="line">&#125;else&#123; //change the pos of the dic to 1</span><br><span class="line">            bit_map[dic] = bit_map[dic] | (1 &lt;&lt; dicPos);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><p>How to <strong>reverse all bits of a number</strong>?</p><p>E.g: 1010xxxxxxx0010  —&gt; 0100 xxxxxxx 0101</p></li></ol><p>   String中是two pointer + swap:</p><p>   s t u d e n t</p><p>   i–&gt;          &lt;–j</p><p>   数字bit的reverse也是相似的：</p><p>   ​        1010xxxxxxxx0010</p><p>   ​        i                j    </p><p>   XOR        <strong>1000000000000001</strong>   //重点</p><p>   ==========================</p><p>   res:        0    一样        1</p><ul><li><p>i, j 位上bit相同，不reverse; 不相同， reverse（采用如上方式）。</p></li><li><p>如何不断的改变i~j， 即 00001000000000100000</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int reverseBits(int n)&#123;</span><br><span class="line">    int i = 31; // 刚开始 L移动位数：  1000 0000 。。。。0000</span><br><span class="line">    int j = 0;  //刚开始 R移动位数</span><br><span class="line">    while(j &lt; i)&#123;</span><br><span class="line">        if(((n &gt;&gt; i) &amp; 1) != ((n &gt;&gt; j) &amp; 1))&#123;</span><br><span class="line">        //swapAPairOfBit(n, i, j);</span><br><span class="line">        n = n ^ ((1 &lt;&lt; i) | (1 &lt;&lt; j)); //就是以上步骤</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">   return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="7"><li>how to convert a number to Hexademical?</li></ol><p>$\textcolor{Red}{没懂啊没懂啊!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!} $</p><p><a href="https://leetcode.com/problems/number-of-1-bits/discuss/111379/Party-of-all-possible-JAVA-solutions" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-1-bits/discuss/111379/Party-of-all-possible-JAVA-solutions</a></p><p><a href="https://leetcode.com/problems/sum-of-two-integers/discuss/84278/A-summary:-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently" target="_blank" rel="noopener">https://leetcode.com/problems/sum-of-two-integers/discuss/84278/A-summary:-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently</a></p><h3 id="要记住的关于bit模板"><a href="#要记住的关于bit模板" class="headerlink" title="要记住的关于bit模板"></a>要记住的关于bit模板</h3><ol><li>获得i-th bit的两种写法：</li></ol><ul><li>for loop:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; 32; i++)&#123;</span><br><span class="line">    </span><br><span class="line">    //do something;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>while loop:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while(n &gt; 0)&#123; //如果存在负数， 状态条件改为： n != 0</span><br><span class="line">   //do something</span><br><span class="line">   </span><br><span class="line">  n = n &gt;&gt; 1; //注意:如果存在负数必须用无逻辑位移： &gt;&gt;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="add-more"><a href="#add-more" class="headerlink" title="add more"></a>add more</h1><h3 id="知识盲点："><a href="#知识盲点：" class="headerlink" title="知识盲点："></a>知识盲点：</h3><table><thead><tr><th>描述</th><th>十进制</th><th>Bit</th><th>记忆</th></tr></thead><tbody><tr><td>x = powerOf2</td><td>2^n</td><td><strong>0001000</strong></td><td>只有一个1</td></tr><tr><td>x = 2^n, 问<strong>x - 1</strong></td><td>2^n - 1</td><td><strong>0000111</strong></td><td>对比观察2^n的Bit</td></tr><tr><td><strong>int bit_setter = 1</strong></td><td>1</td><td>00…0001</td><td></td></tr><tr><td></td><td>&lt;&lt; k   (k = 3)</td><td>00…1000</td><td><strong>用处</strong>： 结果&amp;/\</td><td>操作，将<strong>x的k-th bit 改为0/1</strong></td></tr><tr><td>^ XOR: 求x, y中有多少bits不同</td><td></td><td></td><td>（异）或： 就是异， res = 1 + 再数res中有多少个1</td></tr><tr><td>数res中有多少个1？</td><td></td><td></td><td>0001 &amp; 1 == 1； 0100 &amp; 1 == 0</td></tr><tr><td>检查dic第k-th bit是否为1？</td><td></td><td></td><td>if (<strong>(dic &gt;&gt; k) &amp; 1 == 1</strong>) return true</td></tr><tr><td>将<strong>x的k-th bit改为 1/0</strong>?</td><td></td><td></td><td>—<strong>改1：</strong> x = x \</td><td>(1 &lt;&lt; k) 注意点： 是使用\</td><td>还是&amp;。<strong>改0：</strong> x = x &amp;（ ~(1 &lt;&lt; k)）</td></tr><tr><td>用一个<strong>int dic = 0</strong>去模拟一个HashSet。去判断一个Word中的<strong>letter的重复</strong></td><td></td><td></td><td>int pos = word.charAt(i) - ‘a’;</td></tr><tr><td><strong>x ^ 0 = x</strong></td><td></td><td></td><td>任何数^(异或) 0都是它自己</td></tr><tr><td>x^x = 0</td><td></td><td></td><td>任何数^自己 = 0</td></tr><tr><td>十进制数上：<u><strong>A^B^C^B^C = A^B^B^C^C=A</strong></u></td><td></td><td></td><td>异或时候的交换律</td></tr><tr><td>int dic = 0； 来模拟只有a—z或1–32范围的letter的hashtable</td><td></td><td></td><td></td></tr><tr><td>bit_map[8] 来模拟有256范围的hashtable    — <strong>Bit Vector</strong></td><td></td><td></td><td>int dicIdx = asc / 32; int pos = asc %32;</td></tr><tr><td>在bit上： <strong>x ^ 1= ~x</strong>  异或1用来反转某一个bit</td><td></td><td></td><td></td></tr><tr><td>在bit上： <strong>x ^ 0 = x</strong>     异或0等于自己</td><td></td><td></td><td></td></tr><tr><td>在bit上： x ^ x = 0</td><td></td><td></td><td></td></tr><tr><td>判断两个数X, Y 在右数p1-th和p2-th上<strong>bit是否相等</strong>？</td><td></td><td></td><td>((X &gt;&gt; p1) &amp; 1) =?= ((Y &gt;&gt; p2) &amp; 1)</td></tr><tr><td>Reverse number: **x ^ = ((1 &lt;&lt; i) \</td><td>(1 &lt;&lt; j))**</td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IBM 面试+ OA</title>
      <link href="/2018/05/29/IBM-%E9%9D%A2%E8%AF%95-OA/"/>
      <url>/2018/05/29/IBM-%E9%9D%A2%E8%AF%95-OA/</url>
      
        <content type="html"><![CDATA[<h1 id="1-OA-1"><a href="#1-OA-1" class="headerlink" title="1. OA 1"></a>1. OA 1</h1><p>题意： </p><p>Input： String ipt1 = “Frank-&gt;Mary,Mary-&gt;Sam,Mary-&gt;Bob,Sam-&gt;Katie,Sam-&gt;Pete,Bob-&gt;John,Bob,Katie”;</p><p>找到Bob, Katie lowest common Ancestor </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public String getAncestor(String input)&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        String[] strSet = input.split(&quot;,&quot;);</span><br><span class="line">        String target1 = strSet[strSet.length - 2];</span><br><span class="line">        String target2 = strSet[strSet.length - 1];</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; strSet.length - 2; i++)&#123;</span><br><span class="line">            String[] item = strSet[i].split(&quot;-&gt;&quot;);</span><br><span class="line">            String employee = item[1];</span><br><span class="line">            String manager = item[0];</span><br><span class="line">            hashMap.put(employee, manager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        String p1Manager = target1;</span><br><span class="line">        String p2Manager = target2;</span><br><span class="line">        while(hashMap.containsKey(p1Manager) || hashMap.containsKey(p2Manager))&#123;</span><br><span class="line">            if(hashMap.containsKey(p1Manager))&#123;</span><br><span class="line">                p1Manager = hashMap.get(p1Manager);</span><br><span class="line">                if(!hashSet.add(p1Manager)) return p1Manager;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(hashMap.containsKey((p2Manager)))&#123;</span><br><span class="line">                p2Manager = hashMap.get(p2Manager);</span><br><span class="line">                if(!hashSet.add(p2Manager)) return p2Manager;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return &quot;&quot;;//</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>各种sort总结</title>
      <link href="/2018/05/29/%E5%90%84%E7%A7%8Dsort%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/29/%E5%90%84%E7%A7%8Dsort%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Merge-sort"><a href="#1-Merge-sort" class="headerlink" title="1. Merge sort"></a>1. Merge sort</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public int[] mergeSort(int[] nums)&#123;</span><br><span class="line">        //int[] res = &#123;&#125;;</span><br><span class="line">        if(nums == null || nums.length &lt; 2)&#123;</span><br><span class="line">            return nums;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mergeSortHelper(nums, 0, nums.length - 1);</span><br><span class="line"></span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void mergeSortHelper(int[] nums, int i, int j)&#123;</span><br><span class="line"></span><br><span class="line">        if(i &gt;= j) //recursion: 什么时候停止</span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        int left = i;</span><br><span class="line">        int right = j;</span><br><span class="line">        int mid = left + (right - left)/2;</span><br><span class="line">        mergeSortHelper(nums, left, mid);</span><br><span class="line">        mergeSortHelper(nums, mid + 1, right);</span><br><span class="line">        merge(nums, left, mid + 1, right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void merge(int[] nums, int start1, int start2, int end)&#123;</span><br><span class="line">        int[] res = new int[end - start1 + 1]; //踩坑点！！</span><br><span class="line"></span><br><span class="line">        int p1 = start1, p2 = start2;</span><br><span class="line">        int i = 0;</span><br><span class="line">        while(p1 &lt; start2 &amp;&amp; p2 &lt;= end)&#123;</span><br><span class="line">            if(nums[p1] &lt; nums[p2])&#123;</span><br><span class="line">                res[i] = nums[p1];</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res[i] = nums[p2];</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        //post processing</span><br><span class="line">        while(p1 &lt; start2)&#123;</span><br><span class="line">            res[i++] = nums[p1++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(p2 &lt;= end)&#123;</span><br><span class="line">            res[i++] = nums[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int num: res)&#123;</span><br><span class="line">            nums[start1++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>TIme : O(nlogn)</p><p>space: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>String 类型题目总结</title>
      <link href="/2018/05/27/String-%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/27/String-%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><a id="more"></a><h2 id="1-remove-one-character-from-string"><a href="#1-remove-one-character-from-string" class="headerlink" title="1. remove one character from string"></a>1. remove one character from string</h2><p>###题目： 删除一个string中u 和 n, 返回一个string？</p><p>常见错误： Java中转化为char[]之后直接调用remove 之类的function， time complexity: O(n), 因为每remove一次，后面的items 都要往前shift</p><!-- more --> <h3 id="正确做法："><a href="#正确做法：" class="headerlink" title="正确做法："></a>正确做法：</h3><p>转化成char[]: （挡板思想）使用slow &amp; fast pointers:</p><p><strong>两个挡板， 三个区域，同向而行</strong></p><ul><li>slow: 所有不是’u’ or ‘n’的letter放在slow左边—最后我想return的结果</li><li>fast: 一个遍历器， 碰到非‘u’ or ‘ n’的就copy到i上去—疯狂往前跑的pointer</li></ul><p><img src="http://server.myspace-shack.com/d23/80215e16-54e3-4395-8fe4-00c9126a6da0.png" alt=""></p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public String removeUorN(String str)&#123;</span><br><span class="line">    </span><br><span class="line">    int slow = 0;</span><br><span class="line">    int fast = 0;</span><br><span class="line">    </span><br><span class="line">    char[] chars = str.toCharArray();</span><br><span class="line">    while(j &lt; str.length() &amp;&amp; i &lt; str.length())&#123;</span><br><span class="line">        if(chars[j] == &apos;u&apos; || chars[j] == &apos;n&apos;)</span><br><span class="line">        j++;</span><br><span class="line">        </span><br><span class="line">        swap(chars, i, j);</span><br><span class="line">        i++;</span><br><span class="line">      j++; //一句话： swap(chars, i++, j++);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //!!resize char array to size i</span><br><span class="line">    </span><br><span class="line">    return new String(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p><img src="http://server.myspace-shack.com/d23/70c42c15-8366-47b9-9453-dd9e40ede726.png" alt=""></p><h3 id="2-重点-Char-Removal-Remove-all-leading-trailing-and-duplicate-empty-space-onlu-leave-one-empty-space-if-duplicated-spaces-happen-from-the-input-string"><a href="#2-重点-Char-Removal-Remove-all-leading-trailing-and-duplicate-empty-space-onlu-leave-one-empty-space-if-duplicated-spaces-happen-from-the-input-string" class="headerlink" title="2.重点(Char Removal) Remove all leading/trailing and duplicate empty space (onlu leave one empty space if duplicated spaces happen) from the input string."></a>2.重点(Char Removal) Remove all leading/trailing and duplicate empty space (onlu leave one empty space if duplicated spaces happen) from the input string.</h3><p>input = “_ _ _ abc _ _ ed _ _ ef _ _”;</p><p>output = “abc_ed_ef”;</p><p><strong>思想： （W1) (_ W2) (_ W3) … (_ Wn)</strong></p><p>除了第一个word, 其他的前面都加一个‘空格’</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public String removalSpace(String str)&#123;</span><br><span class="line">    </span><br><span class="line">    char[] chars = str.toCharArray();</span><br><span class="line">    </span><br><span class="line">    int slow = 0;</span><br><span class="line">    int fast = 0;</span><br><span class="line">    int wordCount = 0;//special case for 1st word</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        //1. 处理leading space</span><br><span class="line">        while(fast &lt; str.length()/*重点*/ &amp;&amp; chars[fast] == &apos; &apos;)&#123;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //检查fast有没有越界， or这时候是不是全是space</span><br><span class="line">        if(fast == str.length()) //stop点：删除了头尾space</span><br><span class="line">        break;</span><br><span class="line">        </span><br><span class="line">        //2. 有word：wordCount &gt; 0, 加‘_’</span><br><span class="line">        if(wordCound &gt; 0)</span><br><span class="line">        chars[slow++] = &apos; &apos;;</span><br><span class="line">        </span><br><span class="line">        //3. copy word. 把word 拷贝到i部分</span><br><span class="line">        while(fast &lt; str.length() &amp;&amp; chars[fast] != &apos; &apos;)&#123;</span><br><span class="line">            chars[slow++] = chars[fast++]；</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        wordCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //char array resize to i;</span><br><span class="line">    </span><br><span class="line">    return new String(chars, 0, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Char-De-Duplication"><a href="#2-Char-De-Duplication" class="headerlink" title="2. Char De-Duplication"></a>2. Char De-Duplication</h2><h3 id="2-1-Char-de-duplicaiton"><a href="#2-1-Char-de-duplicaiton" class="headerlink" title="2.1 (Char de-duplicaiton)"></a>2.1 (Char de-duplicaiton)</h3><p>删除重复数字和相邻letter(不同的letter只保留一个)</p><p>E.g:</p><p>String s = “ a a b b _ _ c c” —&gt; “ab_ c”</p><p>​                           s</p><p>​                               f</p><p>还是slow, scanning pointer</p><p><strong>重点是： 什么时候slow pointer 要移动， 每次都和返回值区域slow部分最后一个char比</strong></p><p>s: is the slow/index all letters to the left of s (<strong>including</strong>(excluding) s) should be in final answer</p><p>f: is the fast/current index to scan the string( from left to right)</p><p>代码：</p><ol><li>slow 是<strong>including s</strong>的写法 : 不相等， 先右移s,再赋值</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public String deDuplicate(char[] str)&#123;</span><br><span class="line">    </span><br><span class="line">    int s = 0, f = 0; //重点1</span><br><span class="line">    while(f &lt; str.length)&#123;</span><br><span class="line">        if(str[s] != str[f])&#123; //重点2</span><br><span class="line">            s++; //重点3</span><br><span class="line">            str[s] = str[f];</span><br><span class="line">            f++;</span><br><span class="line">        &#125;else</span><br><span class="line">        f++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return new String(str, 0, s + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>slow 是<strong>excluding s</strong>的写法 （prefer）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public String deDuplicate(char[] str)&#123;</span><br><span class="line">    if(str == null || str.length &lt; 2)</span><br><span class="line">    return new String(str);</span><br><span class="line">    </span><br><span class="line">    int s = 1, f = 1; //重点1.</span><br><span class="line">    while(f &lt; str.length)&#123;</span><br><span class="line">    if(str[s - 1] != str[f])&#123; //重点2</span><br><span class="line">            str[s] = str[f];</span><br><span class="line">            s++;</span><br><span class="line">            f++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            f++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return new String(str, 0, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-（char-de-duplicate-ajacent-letter-Repeatly"><a href="#2-2-（char-de-duplicate-ajacent-letter-Repeatly" class="headerlink" title="2.2 （char de-duplicate ajacent letter Repeatly)"></a>2.2 （char de-duplicate ajacent letter <u>Repeatly</u>)</h3><p>E.g:</p><p>abbbbbaz —&gt; a1-a2z —&gt;z</p><p><strong>用什么样的数据结构可以随时帮助我们找到历史最新的元素</strong>？ stack</p><p><strong>Method 1:</strong>  <strong>显示的</strong>用一个stack —stack 最后保留的return</p><p>类似于以上slow， scanning 思想：</p><ul><li>碰到于Stack顶相同元素： while loop过掉相同元素 + pop栈顶元素 </li><li>不相同： push入栈， scanning++</li></ul><p>—coding trick: 可以用一个动态ArrayList 去模拟一个Stack， 可以利于最后random access 读取</p><p><strong>Method 2:</strong> 通过slow pointer<strong>隐示的</strong>体现一个栈的功能</p><p>主题思想还是类似于slow, scanning 思想 + 用slow pointer 隐示的维护一个Stack</p><p>通过slow–后退（左移）一格来体现Stack pop（）</p><p>​     a b b b b b a z</p><p>​     s</p><p>​                              f</p><h2 id="3-Substring"><a href="#3-Substring" class="headerlink" title="3. Substring"></a>3. Substring</h2><p>Q3: Substring problem: how to determine whether a string is a substring of another string.</p><p>Example:</p><p>​         0 1 2 3 4</p><p>s1 = “a b c d e”     s2 = “c d”</p><p>return index of s2, if not return -1.</p><p>Method 1: 暴力法</p><p>Time Complexity: O(n*m)</p><p>index 0 1 2 3 4</p><p>s1       a b c d e</p><p>​           |</p><p>​            c d</p><p>​                c  d</p><p>​                     c  d</p><p>​                          c  d</p><p>主要思想：以s1中的每一个char为起点， 再和 s2逐字检查， 只要有一个char不match–&gt;跳出，以下一个char为起点再逐字比较，直到和s2完全match为止。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int indexOf(String s1, String s2)&#123;</span><br><span class="line">if(s1 == null || s2 == null)</span><br><span class="line">return -1;</span><br><span class="line"></span><br><span class="line">//比到倒数第二个， 防止越界</span><br><span class="line">//1个letter debug</span><br><span class="line">//for every possible start index of s2</span><br><span class="line">for(int i = 0; i &lt;= s1.length() - s2.length(); i++)&#123;</span><br><span class="line">int j = 0;</span><br><span class="line">for(; j &lt; s2.length(); j++)&#123; //以是s1[i]为起点和s2逐字比较</span><br><span class="line">            if(s1.charAt(i + j) != s2.charAt(j))</span><br><span class="line">            break;</span><br><span class="line">&#125;</span><br><span class="line">if(j == s2.length())</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Method 2: Robin-Karp</p><p>$\textcolor{Red}{自己再做一遍!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!} $ </p><h2 id="4-String-Reversal"><a href="#4-String-Reversal" class="headerlink" title="4. String Reversal"></a>4. String Reversal</h2><h4 id="4-1-String-Reversal"><a href="#4-1-String-Reversal" class="headerlink" title="4.1 String Reversal"></a>4.1 String Reversal</h4><p>apple –&gt; elppa</p><p>i        j</p><p>解法一： iterative</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解法二： Recursion:</p><p><strong>Base Case: 子问题从两边想中间变小， 到只有1个或0个character时。</strong></p><p><strong>Recursion rule: reverseStr(str, i + 1, j - 1);</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//usage: reverseStr(str, 0, length - 1);</span><br><span class="line"></span><br><span class="line">public void reverseStr(String str, int i, int j)&#123;</span><br><span class="line">//base case</span><br><span class="line">if(i &gt;= j)</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">swap(str, i, j);</span><br><span class="line">reverseStr(str, i + 1, j - 1); //recursion rule</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-reverse-string"><a href="#4-2-reverse-string" class="headerlink" title="4.2 reverse string"></a>4.2 reverse string</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I love yahoo ---&gt; yahoo love I</span><br></pre></td></tr></table></figure><p>Method 1: 用Stack</p><p><strong>Method 2： Trick重点！</strong>！</p><ul><li><p>先reverse整个string</p></li><li><p>再按空格reverse每个Word</p></li></ul><h4 id="4-3-Shift-the-string-with-k-steps"><a href="#4-3-Shift-the-string-with-k-steps" class="headerlink" title="4.3 Shift the string with k steps"></a>4.3 Shift the string with k steps</h4><p><strong>abcd ef –&gt; ef abcd</strong> shift the whole string to the right-hand size by two position</p><p><strong>类似I love yahoo的方法reverse 3次</strong></p><ul><li>整个sentence reverse</li><li>按word1 reverse</li><li>按Word2 reverse</li></ul><h3 id="Discussion-4："><a href="#Discussion-4：" class="headerlink" title="Discussion 4："></a>Discussion 4：</h3><ol><li>什么时候回用到“I Love Yahoo” 翻转思想</li></ol><p><strong>一个chunk word不变，只是位置对调了： 翻转2次： 1. 整个翻转，2. 按chunk Word翻转</strong></p><ol><li>“I Love Yahoo” 翻转思想可以用到更多复杂的题目上： eg: String(array) shifting by X chars to the right</li></ol><h3 id="4-Char-Replacement"><a href="#4-Char-Replacement" class="headerlink" title="4. Char Replacement"></a>4. Char Replacement</h3><p>题目：</p><p>String str: stu<strong>den</strong>t </p><p>pattern: den–&gt; <strong>XX</strong></p><p>​        s1         s2</p><p>return: stu<strong>XX</strong>t</p><p>基本思路都是two pointers: slow and scanning</p><p>####<strong>Case 1: if s1.length() &gt;= s2.length()</strong></p><p>step1: find the single occurrence of s1 in the original string,  and jsut replace s1 with s2, until we are done</p><p>####<strong>Case 2: if s1.length() &lt; s2.length()</strong></p><p>“stu<strong>de</strong>nt<strong>de</strong>tstu<strong>de</strong>nt” –&gt; “stu<strong>XXX</strong>nt<strong>XXX</strong>t”</p><p>patthern: de –&gt; XXX</p><p>​                  s1          s2</p><p>how many extra spaces should we get?</p><p>Step1: count how many times s1 show up in original string. for example, 3 times</p><p>step2: extra space:  <strong>3*(s2.length() - s1.length())</strong></p><p>Step3: slow, scanning pointers. (<strong>特殊点： slow, scanning是从后往前)</strong></p><p>s t u d e n t d e t s t u d e n t _ _ _</p><p>​                                                         s</p><p>​                                                          f</p><p><strong>slow(s): all letter to the right side of slow pointers are the results we want to return</strong></p><h1 id="Advanced-Topic-String"><a href="#Advanced-Topic-String" class="headerlink" title="Advanced Topic(String)"></a>Advanced Topic(String)</h1><p>##常见题型及变种： </p><h3 id="1-Shuffling-e-g-ABCD1234-–-gt-A1B2C3D4"><a href="#1-Shuffling-e-g-ABCD1234-–-gt-A1B2C3D4" class="headerlink" title="1. Shuffling e.g: ABCD1234 –&gt; A1B2C3D4"></a>1. Shuffling e.g: ABCD1234 –&gt; A1B2C3D4</h3><h3 id="2-Permutation-use-DFS"><a href="#2-Permutation-use-DFS" class="headerlink" title="2. Permutation(use DFS)"></a>2. Permutation(use DFS)</h3><h3 id="3-Decoding-encoding-aaaabcc-–-gt-a4b1c2-Run-length-encode"><a href="#3-Decoding-encoding-aaaabcc-–-gt-a4b1c2-Run-length-encode" class="headerlink" title="3. Decoding/encoding aaaabcc –&gt; a4b1c2 (Run length encode)"></a>3. Decoding/encoding aaaabcc –&gt; a4b1c2 (Run length encode)</h3><h3 id="4-Sliding-windows-using-slow-fast-pointers"><a href="#4-Sliding-windows-using-slow-fast-pointers" class="headerlink" title="4. Sliding windows using slow/fast pointers"></a>4. Sliding windows using slow/fast pointers</h3><h4 id="4-1-Longest-substring-that-contains-only-unique-chars-abcda"><a href="#4-1-Longest-substring-that-contains-only-unique-chars-abcda" class="headerlink" title="4.1 Longest substring that contains only unique chars:  abcda"></a>4.1 Longest substring that contains only unique chars:  <u>abcd</u>a</h4><h2 id="题型1：-String-Shuffling"><a href="#题型1：-String-Shuffling" class="headerlink" title="题型1： String Shuffling"></a>题型1： String Shuffling</h2><h4 id="1-1-First-Direction-“A1B2C3D4E5”-—-gt-“ABCDE12345”-小—-gt-大"><a href="#1-1-First-Direction-“A1B2C3D4E5”-—-gt-“ABCDE12345”-小—-gt-大" class="headerlink" title="1.1 First Direction: “A1B2C3D4E5” —&gt; “ABCDE12345”  小—&gt;大"></a>1.1 First Direction: “A1B2C3D4E5” —&gt; “ABCDE12345”  小—&gt;大</h4><p>类似<strong>Merge Sort</strong></p><p>​                      l                              r</p><p>​                        A1B2C       3D4E5</p><p>​                   /          \          /         \                              Divide array into two subarray</p><p>​                 A1B       2C     3D4      E5</p><p>​                 /        \     /   \     /  \      /  \</p><p>​              A1       B   2    C  3  D4   E    5</p><p>​          /        \        /      /    /    /   /\    /     /      unitl cannot divide</p><p>​        A          1    B       2   C   3  D  4  E  5</p><p>=====================================</p><p>​             A1         B2      C3    D4        E5</p><p>​                 AB12        CD34        E5</p><p>​                       ABCD1234          E5                         merge <strong>two sorted arrays</strong></p><p>​                               ABCDE12345</p><p>merge 的时候需要写一下<strong>comparator</strong>: 字母比数字小， 字母和字母比按alphabetic 顺序， 数字按从小到大顺序</p><h4 id="1-2-Second-Direction-“ABCD12345”-—-gt-“A1B2C3D4E5”"><a href="#1-2-Second-Direction-“ABCD12345”-—-gt-“A1B2C3D4E5”" class="headerlink" title="1.2 Second Direction: “ABCD12345” —&gt; “A1B2C3D4E5”"></a>1.2 Second Direction: “ABCD12345” —&gt; “A1B2C3D4E5”</h4><p>类似reverse merge Sort的思想：</p><p>​         A1       B2        C3      D4</p><p>​            AB12          CD34</p><p>​             AB|CD|12|34</p><p>​     <u>chunk 1  2     3     4</u></p><p><strong>重点： guarantee size of chunk 1 == chunk 3</strong></p><p>​                A B C| <strong>D E F G</strong> |1 2 3| <strong>4 5 6 7</strong></p><p>index      0 1 2 |3  4 5 6 |7 8  9  |0 1 2 3</p><p>​                            <strong>lm</strong>           <strong>m</strong>          <strong>rm</strong> </p><p><strong>关键问题：注意n/2 == 7 == 奇数情况</strong></p><p><img src="http://server.myspace-shack.com/d23/52f789b9-3f02-4eea-83b7-6722d14cf90c.png" alt=""></p><p>重点公式！！！！</p><blockquote><p>size = 14</p><p>mid = left + size/2 = 7</p><p>leftmid = left + (1/4)*size = 3</p><p>rightmid = left + (3/4)*size = 10</p></blockquote><h4 id="代码很重要！！："><a href="#代码很重要！！：" class="headerlink" title="代码很重要！！："></a>代码很重要！！：</h4><p><img src="http://server.myspace-shack.com/d23/4c1b5d3f-00ca-4c6f-8221-7996fe08aa59.png" alt=""></p><h2 id="题型二：-String-Permutation-（DFS经典例题"><a href="#题型二：-String-Permutation-（DFS经典例题" class="headerlink" title="题型二： String Permutation （DFS经典例题)"></a>题型二： String Permutation （DFS经典例题)</h2><h4 id="2-1-no-duplicate-letters-in-input-string-LeetCode-46-Permutaiton"><a href="#2-1-no-duplicate-letters-in-input-string-LeetCode-46-Permutaiton" class="headerlink" title="2.1 no duplicate letters in input string (LeetCode 46 Permutaiton)"></a>2.1 no duplicate letters in input string (LeetCode 46 Permutaiton)</h4><p>E.g. </p><p><strong>input</strong>: “abc”</p><p><strong>output</strong>: </p><p>[ “aab”,</p><p>   “aba”,</p><p>   “baa”]</p><p>####2.1 Input string with duplicate (LeetCode 47 Permutation II)</p><h2 id="题型三：-String-En-Decoding"><a href="#题型三：-String-En-Decoding" class="headerlink" title="题型三： String En/Decoding"></a>题型三： String En/Decoding</h2><p>E.g. </p><p>“aaaabccaaaaa” ——&gt; “a4b1c2a5”  <strong>Restriciton: In-Place</strong></p><p>思路： Two Pointers: slow, fast</p><p>两种情况：</p><p>case 1: input.length &gt; output.length </p><p>case 2: input.length &lt; output.length</p><p>怎么样去综合处理？</p><p>分两步走：</p><p>Step1: </p><p>Step 2:</p><p>?????????没懂one more time  </p><p>$\textcolor{Red}{没懂啊没懂啊!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!} $ </p><p>//1: 30</p><h2 id="题型四：-Sliding-Window-in-a-String-slow-fast-indices"><a href="#题型四：-Sliding-Window-in-a-String-slow-fast-indices" class="headerlink" title="题型四： Sliding Window in a String (slow + fast indices)"></a>题型四： Sliding Window in a String (slow + fast indices)</h2><p>XXXXX<strong>XXXXXXXXXXX</strong>XXXXXXXXXXXXXXXXX</p><p>​           =============</p><p>​            L                         R</p><p>​                       ‘A ‘           counter(滑动窗口内‘A’ 的个数)</p><p>  hashMap&lt;Character, Integer&gt;</p><p>普及： <strong>Sliding Window  + 配套hashMap</strong>(count 窗口内每个char出现几次) + global-mx:</p><ul><li>定长</li><li>不定长</li></ul><h4 id="4-1-Longest-Substring-that-contains-only-unique-char"><a href="#4-1-Longest-Substring-that-contains-only-unique-char" class="headerlink" title="4.1 Longest Substring that contains only unique char"></a>4.1 Longest Substring that contains only unique char</h4><p>Given a string, return the length of the <strong>longest substring</strong> <strong>wihtout dupilcate character</strong>. </p><p>For Example, the longest substring wihtout repeating charater for “<strong>BDEFGA</strong>DE” is “<strong>BDEFGA</strong>“, whose size is 6.</p><p><strong>此类型题目有各种变种： (Follow-Up: that with duplicate characters at most k times. eg k = 5)</strong></p><p>分析该题： without repeating letters———&gt; <strong>k = 1</strong></p><ul><li>sliding window 中的每个character不会超过k 次</li></ul><p>idx: 0  1  2 3 4  5 6  7</p><p>E.g: <strong>B D’ E F G A </strong>D’ E                          k = 1</p><p>​                    ========</p><p>​                    L</p><p>​                                    R</p><p><strong>hashMap&lt;char</strong>, int&gt;</p><p>​                     B       0     </p><p>​                     D       1      <strong>&gt;k</strong>      <strong>开始移动L， 直到D == 1</strong> ;–&gt; D == K—&gt;R开始滑动</p><p>​             E        2     没&gt; k  —&gt; &gt; k <strong>开始移动L， 直到E == 1</strong>  –&gt;  D ==k —&gt;R开始滑动</p><p>​                     F        1      <strong>没&gt; k</strong></p><p>​             G        1    没 &gt; k</p><pre><code>A         1   没 &gt; k</code></pre><p><strong>global_max</strong> = l - r + 1 = 6</p><blockquote><p><strong>Move R</strong>: add更新hashMap + 检查当前‘A’&lt;= k  –&gt; 更新global_max</p><p>​                                                            ‘A’ &gt;k     —&gt;移动L</p><p><strong>Move L:</strong> delete更新hashMap， 直到‘A’ == k —&gt; 移动R</p></blockquote><p>####<strong>Critical points</strong> for review:</p><blockquote><p>We must maintain a hash_table that reflects the <strong>real-time</strong> information about the elements within the sliding window:</p><p>When we <strong>move the R border</strong>, we <strong>add</strong> the information to the hash_table, </p><p>When we <strong>move the L border</strong>, we <strong>delete</strong> information from the hash_table</p></blockquote><p>什么时候可以移动R？只要当前hashMap内当前‘A’‘’s counter &gt;k</p><h3 id="代码：重点！重点！重点！"><a href="#代码：重点！重点！重点！" class="headerlink" title="代码：重点！重点！重点！"></a>代码：重点！重点！重点！</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">String LongestSubstrW/oDup(String input)&#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">    int left = 0, right = 0;   //sliding window</span><br><span class="line">    int global_max = 0;</span><br><span class="line">    int start = 0, end = 0; //record the start and end index of the solution</span><br><span class="line">    </span><br><span class="line">    char[] chars = input.toCharArray();</span><br><span class="line">    while(right &lt; chars.length())&#123;//Move R: add更新当前’A‘to hash_table</span><br><span class="line">        hashMap.put(chars[right], hashMap.getOrDefault(chars[fast], 0) + 1);</span><br><span class="line">        </span><br><span class="line">        //检查当前’A‘是否 &gt; k</span><br><span class="line">        if(hashMap.get(chars[fast]) &gt; 1)&#123;</span><br><span class="line">        //move L: delete 更新hashMap, until &apos;A&apos; == k</span><br><span class="line">        while(hashMap.get(chars[fast]) &gt; 1)&#123;</span><br><span class="line">                hashMap.put(chars[left], hashMap.get(chars[left]) - 1);</span><br><span class="line">                left++;</span><br><span class="line">        &#125;   </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //移动R没有造成duplicate---&gt; update global_max</span><br><span class="line">            //global_max = Math.max(global_max, (right - left) + 1);</span><br><span class="line">            if(right - left + 1&gt; global_max)&#123;</span><br><span class="line">                global_max = right - left + 1;</span><br><span class="line">                start = slow;</span><br><span class="line">                end = fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right++; //第一步就要记得写</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return input.substring(start, end + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####LeetCode 340. Longest Substring with At Most K Distinct Characters</p><h4 id="substring-问题经典模板："><a href="#substring-问题经典模板：" class="headerlink" title="- substring 问题经典模板："></a>- substring 问题经典模板：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstringKDistinct(String s, int k) &#123;</span><br><span class="line">        </span><br><span class="line">        /*</span><br><span class="line">        sliding window: left, right pointers</span><br><span class="line">        hashMap&lt;character, integer&gt;: char, counter of the char</span><br><span class="line">        什么时候更新counter是重点哦， 根据题意</span><br><span class="line">        counter（状态条件）: # of distinct characters in sliding window--&gt; map[right] == 1 counter++; update + map[left] == 0 counter--</span><br><span class="line">        global_max: result</span><br><span class="line">        </span><br><span class="line">        */</span><br><span class="line">        </span><br><span class="line">        if(s ==  null || s.length() == 0 || k == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">        int left = 0, right = 0, counter = 0, global_max = 0;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        while(right &lt; s.length())&#123;</span><br><span class="line">            //move right until counter &gt; k</span><br><span class="line">            char ch = s.charAt(right);</span><br><span class="line">            hashMap.put(ch, hashMap.getOrDefault(ch, 0) + 1);</span><br><span class="line">            if(hashMap.get(ch) == 1)</span><br><span class="line">                counter++; //new char</span><br><span class="line">            </span><br><span class="line">            //move left when counter &gt; k</span><br><span class="line">            while(counter &gt; k)&#123;</span><br><span class="line">                char c = s.charAt(left);</span><br><span class="line">                hashMap.put(c, hashMap.get(c) - 1);</span><br><span class="line">                if(hashMap.get(c) == 0)</span><br><span class="line">                    counter--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //re-cal global_max</span><br><span class="line">            global_max = Math.max(global_max, right - left + 1);</span><br><span class="line">            </span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return global_max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有substring 问题的总结：</p><p><a href="https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/49708/Sliding-Window-algorithm-template-to-solve-all-the-Leetcode-substring-search-problem" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/49708/Sliding-Window-algorithm-template-to-solve-all-the-Leetcode-substring-search-problem</a>.</p><ol><li>LeetCode 3. Longest Substring Without Repeating Characters</li><li>Leetcode 159. Longest Substring with At Most Two Distinct Characters</li><li>LeetCode 340. Longest Substring with At Most K Distinct Characters</li><li>LeetCode 424. Longest Repeating Character Replacement (4.1的马甲题)</li></ol><h4 id="4-2-Find-all-Anagrams-of-a-substring-S2-in-a-long-string-S1"><a href="#4-2-Find-all-Anagrams-of-a-substring-S2-in-a-long-string-S1" class="headerlink" title="4.2 Find all Anagrams of a substring S2 in a long string S1"></a>4.2 Find all <u>Anagrams</u> of a substring S2 in a long string S1</h4><p>anagram: 同形异构</p><p>String s2 = “aabc”;</p><p>​            s1 = “zzzzcde<strong>bcaa</strong>bcyywwww”</p><p>思考过程： 要在s1中找到s2的anagram， 我们需要分析一下anagram的定义—solution 需要和pattern s2有相同的长度， 在这个段长度内且每个character的数量要一样——&gt; hash_table代表每次loop到的区间， <strong>这个区间还需要</strong>match到的character types数量和每个character’s count数量</p><ul><li><strong>我们只关注在hashMap中pattern要match的characters</strong></li><li>Sliding window 定长， window每次移动都是出一个，再进一个</li><li>window的每一次（进/出）移动都要判断(L/R) character 是否在hash_table中</li></ul><p>E.g:</p><p>   a a b c</p><p>   z z z z c d e <strong>b c a a </strong>b c y y w w w w</p><p>​                                            =====</p><p>​                                            l  </p><p>​                                                       r</p><p>HashMap&lt;char, int&gt; <strong>hashMap</strong>  real-time 更新window 内还需要match information</p><p>​                     <strong>a</strong>       2 - 1 = 1 - 1 = 0 + 1 + 1 = 2 -&gt; update unmatched </p><p>​                     <strong>b</strong>       1-1 = 0 - 1 + 1 = 0  + 1 = 1–&gt; update unmatched </p><p>​                     <strong>c</strong>        1- 1 = 0 + 1 - 1 = 0 + 1-&gt; update unmatched                 </p><p>​           <strong>types_of_letter_still_need_to_balance</strong> = 3 - 1 = 2 - 1 = 1 - 1 = 0 –&gt; one solution (l, r)</p><p>​                                c from 1 to 0                                                    –.&gt; 0 second solution (l’, r’)</p><p>​                                a from 1 to 0                              —&gt; 0 third solution (l’’, r’’)</p><p>​                                a from 0 to 1                                                    = 1</p><pre><code>b from 0 to 1                               = 1+ 1</code></pre><p>​                                c from 0 to 1                                        = 1 + 1 +1</p><p>Time: O(N)</p><p>以上是初始化pattern.length() —L = 0, R = pattern.length() - 1</p><p>写法二： left = 0, right = 0;</p><p>   a a b c</p><p>   z z z z c d e <strong>b c a a </strong>b c y y w w w w</p><p>​                           ====</p><p>​                           L</p><p>​                                  R</p><p>HashMap&lt;Character, Integer&gt;</p><p>​            a             2 -1 -1= 0</p><p>​                        b          1 - 1= 0 + 1 = 1</p><p>​            c         1 - 1= 0 - 1= -1+ 1 = 0</p><p>​                         unmatched_counter = 3 - 1= 2 - 1 = 1 - 1= 0 + 1</p><p>####Anagrams of Substring 第一次总结</p><ol><li><p>思路还是substring固有的sliding window(L, R pointers)解法</p></li><li><p>Anagrams(同形异构)： 保证result’s length = pattern’s length &amp;&amp; result’s elements = pattern’s elements</p><ul><li><u><strong>定长</strong>的Sliding window</u>: intialize 为 pattern’s length</li><li><strong>hashMap&lt;</strong>char, int&gt;: pattern’s character: how many # of the character does the window need to match?</li><li><strong>global_counter:</strong> how many types of characters do we still need to match?</li></ul></li><li><p>window 的每次定长移动都伴随着L, R的character的进出， 要在hash_table 里的character要做相应的增/减</p></li></ol><p>   $\textcolor{Red}{没懂啊没懂啊!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!} $ </p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><p>###4.3 Given a 0-1 array, you can flip at most k ‘0’s to ‘1’s. Please find the longest subarray that consists of all ‘1’s; </p><p>题型转化：</p><p>我们最终要找到一个<strong><u>longest subarray</u> with at most k ‘0’</strong> , 就变成了sliding window 的变种</p><p><strong>4.1 的变形题！！！</strong></p><p>！！！！做题时必须明白的重点：</p><ul><li>when to move R border:  when ‘0’ in sliding window &lt;=4</li><li>when to move L border:  when ‘0’ in sliding window &gt; 4</li></ul><h4 id="LeetCode-424-Longest-Repeating-Character-Replacement"><a href="#LeetCode-424-Longest-Repeating-Character-Replacement" class="headerlink" title="LeetCode 424. Longest Repeating Character Replacement"></a>LeetCode 424. Longest Repeating Character Replacement</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public int characterReplacement(String s, int k) &#123;</span><br><span class="line">        </span><br><span class="line">        if(s == null || s.length() == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">        int left = 0, right = 0, maxOcInWindow = 0, max_len = 0;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        while(right &lt; s.length())&#123;</span><br><span class="line">            </span><br><span class="line">            //moving right pointer forward and re-cal mostOC in sliding window(max = Math.max(max, hashMap[right]))</span><br><span class="line">            char ch = s.charAt(right);</span><br><span class="line">            hashMap.put(ch, hashMap.getOrDefault(ch, 0) + 1);</span><br><span class="line">            maxOcInWindow = Math.max(maxOcInWindow, hashMap.get(ch));  //重点哦！</span><br><span class="line">            </span><br><span class="line">            //moving left as (right - left + 1 - maxOC &gt; k)    --&gt; get possible answers</span><br><span class="line">            while(right - left + 1 - maxOcInWindow &gt; k)&#123;  //什么时候移动left？ 重点哦</span><br><span class="line">                char c = s.charAt(left);</span><br><span class="line">                hashMap.put(c, hashMap.get(c) - 1);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            //3. re-cal max_len</span><br><span class="line">            max_len = Math.max(max_len, right - left + 1);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return max_len;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-LeetCode-30-Substring-with-Concatenation-of-All-Words-H"><a href="#4-4-LeetCode-30-Substring-with-Concatenation-of-All-Words-H" class="headerlink" title="4.4 LeetCode 30. Substring with Concatenation of All Words (H)"></a>4.4 LeetCode 30. Substring with Concatenation of All Words (H)</h3><p>题目： 给一个String s = “barfoothefoobarman”, 和一个wordsList = [“foo”,”bar”]. 找到所有的start indexes of substring in (s) that is a concatanation of all words in wordsList exactly once and without any intervening characters.</p><p> 题意类似在String s 中找出所有的start indexes of angrams of wordLists. </p><p>同样的sliding window + HashMap的思路.</p><p>主要思路：使用sliding window, extend the correct window word by word</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">barfoothefoobarman</span><br><span class="line"> --|--|--|--|--|--</span><br><span class="line">  --|--|--|--|--|</span><br></pre></td></tr></table></figure><ul><li>两层循环：<ul><li>外循环： for each start index of s[i] to wordLen: </li><li>内循环： doing sliding window from start index s[i] + right pointer skip word by word</li></ul></li><li>Pattern’s HashMap(patternMap)： pattern word—word count</li><li>window’s HashMap(curMap): 当前window中包含的Word和Word count<ul><li>counter: 当前window match到多少pattern words 的个数</li></ul></li><li>when to move R?<ul><li>check if current word match any word in pattern? <ul><li>yes —keep moving R until 状态条件： curMap[word[right]] &gt; patternMap[word[right]]<ul><li>moving L while in 状态条件： curMap[word[right]] &gt; patternMap[word[right]]</li><li>if counter == wordList.length()  有解了:  找到一个解， 加入res + update new start point of window</li></ul></li><li>no — 当前word 不是pattern所需， window 清零， counter清零， update window起点为right + wordLen</li></ul></li></ul></li></ul><h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; findSubstring(String S, String[] wordsList) &#123;</span><br><span class="line">        </span><br><span class="line">        /*</span><br><span class="line">        //find all anagrams of words in S</span><br><span class="line">        </span><br><span class="line">        //移动L时， 类似substring without repeating character</span><br><span class="line">        </span><br><span class="line">        */</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        if(wordsList.length == 0 || S.length() &lt; wordsList.length * wordsList[0].length())</span><br><span class="line">            return res;</span><br><span class="line"></span><br><span class="line">        int strLen = S.length();</span><br><span class="line">        int wordCount = wordsList.length;</span><br><span class="line">        int wordLen = wordsList[0].length();</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, Integer&gt; pword_count = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //tinitialize the pattern&apos;s word count hashMap</span><br><span class="line">        for(String word: wordsList)&#123;</span><br><span class="line">            pword_count.put(word, pword_count.getOrDefault(word, 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for(int start = 0; start &lt; wordLen; start++)&#123; //对于每个起点做sliding window, 最多做wordLen次就可以了</span><br><span class="line">            //int left = start, right = start;</span><br><span class="line">            int counter = 0; //window 中match上了多少个Words</span><br><span class="line">            HashMap&lt;String, Integer&gt; winWords = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            //sliding window</span><br><span class="line">            for(int left = start, right = start; right + wordLen &lt;= S.length(); right += wordLen)&#123;</span><br><span class="line"></span><br><span class="line">                String curWord = S.substring(right, right + wordLen);</span><br><span class="line">                if(pword_count.containsKey(curWord))&#123; //当前word 是pattern 所需， 开始以当前left为起点进行sliding window</span><br><span class="line">                    winWords.put(curWord, winWords.getOrDefault(curWord, 0) + 1);</span><br><span class="line">                    if(winWords.get(curWord) &lt;= pword_count.get(curWord))&#123;</span><br><span class="line">                        counter++; //window match上了一个word</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    //前面的if判断保证了window中的words一定是Pattern所需！</span><br><span class="line">                    while(winWords.get(curWord) &gt; pword_count.get(curWord))&#123; //window 中的curWord 多余Pattern所需， 移动L</span><br><span class="line">                        String word = S.substring(left, left + wordLen);</span><br><span class="line">                        winWords.put(word, winWords.get(word) - 1);</span><br><span class="line">                        if(winWords.get(word) &lt; pword_count.get(word))</span><br><span class="line">                            counter--;</span><br><span class="line">                        left += wordLen; //移动L</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if(counter == wordCount)&#123; //找到一个解， 加入res + update new start point of window</span><br><span class="line">                        res.add(left);</span><br><span class="line">                        String cur = S.substring(left, left + wordLen);</span><br><span class="line">                        winWords.put(cur, winWords.get(cur) - 1);</span><br><span class="line">                        counter--;</span><br><span class="line">                        left += wordLen;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;else&#123;//当前word 不是pattern所需， window 清零， counter清零， update window起点为right + wordLen</span><br><span class="line">                    winWords.clear();</span><br><span class="line">                    //left += wordLen;</span><br><span class="line">                    left = right + wordLen; //这里是重点啊！！！left = right + wordLen;</span><br><span class="line">                    counter = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //winWords.clear();</span><br><span class="line">            //进行一轮sliding window, window hashMap 清零</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="String-第一次题型总结："><a href="#String-第一次题型总结：" class="headerlink" title="String 第一次题型总结："></a>String 第一次题型总结：</h1><h3 id="常见技巧："><a href="#常见技巧：" class="headerlink" title="常见技巧："></a><strong>常见技巧</strong>：</h3><ol><li><p><strong>Two pointers</strong>: slow, fast(scanning)</p><p><strong>主要思想： slow左边或右边所有元素就是我们要return result</strong></p><ul><li>同向而行 from left to right ——&gt;s    ——&gt;f</li><li>同向 from right to left:  f&lt;———    s&lt;———-</li><li>相向而行： ———&gt; l       r &lt;———–</li></ul><p><strong>coding 注意点：</strong> 记得检查是否要做post processing!</p></li><li><p><strong>“I LOVE YAHOO” 翻转</strong>2次题型： <u>“W1|W2|W3”—&gt; “W3|W2|W1”</u></p><p>主要思想： input和output 的 chunk Word一样， 相对位置不一样时， 可以用</p></li><li><p><strong>顺序Merge Sort</strong>， 和 <strong>Reverse Merge Sort</strong>类似思想</p><p>Merge Sort回顾</p><ul><li><p>先不断二分下去</p></li><li><p>在以某种方式merge</p></li></ul></li></ol><p>   3.1 顺序merge sort (A1B2C3D4   ——&gt;  ABCD1234 (sorted))</p><p>   和Merge Sort基本一样, merge时候需要改变一下comparator 的方式</p><p>   3.2 Reverse Merge Sort  (ABCD1234(sorted)  ——&gt; A1B2C3D4)</p><ul><li>先画画 merge sort recursion tree的下半部分， 找规律</li><li>分成4个chunks时， 保证size of chunk 1 == size of chunk2</li><li>—“I LOVE YAHOO” 翻转思想</li><li>解决更小的子问题 recursion rule</li></ul><ol start="4"><li><p><strong>DFS</strong> （找到<strong>所有的</strong>String permutation）</p></li><li><p>String Compression 的问题（注意压缩后的str可能比原string长）—&gt;$\textcolor{Red}{有一个通用解法！还不会!!}$</p></li><li><p><strong>Sliding Window</strong> （解决substring 一类的问题及变种问题）重点哦^_^</p><ul><li><p>配套设施：(按照题意： sliding window 有 <strong>定长/不定长</strong> 之分)</p><ul><li>Two Pointers (L, R) —— Sliding Window</li><li>Hash_table —— record <strong><u>real-time</u> information <u>that we care</u></strong> in sliding window</li><li>global_max/global_min</li></ul></li><li><p>做Sliding Window题， 心中要问自己：</p><ul><li>sliding window 定长/不定长？</li><li>sliding window (L/R) 起点？</li><li><strong>hash_table 中存的什么数据以及它们的物理意义？</strong></li><li><strong>什么时候移动 L pointer?</strong></li><li><strong>什么时候移动 R pointer?</strong></li><li>根据题意counter（状态条件）是什么？</li></ul></li><li><p>记住两个？经典模板！！！(LeetCode 340. Longest Substring with At Most K Distinct Characters)</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//LeetCode 340. Longest Substring with At Most K Distinct Characters</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstringKDistinct(String s, int k) &#123;</span><br><span class="line">        </span><br><span class="line">        /*</span><br><span class="line">        sliding window: left, right pointers</span><br><span class="line">        hashMap&lt;character, integer&gt;: char, counter of the char</span><br><span class="line">        什么时候更新counter是重点哦， 根据题意</span><br><span class="line">        counter（状态条件）: # of distinct characters in sliding window--&gt; map[right] == 1 counter++; update + map[left] == 0 counter--</span><br><span class="line">        global_max: result</span><br><span class="line">        </span><br><span class="line">        */</span><br><span class="line">        </span><br><span class="line">        if(s ==  null || s.length() == 0 || k == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">        int left = 0, right = 0, counter = 0, global_max = 0;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        while(right &lt; s.length())&#123;</span><br><span class="line">            //move right until counter &gt; k</span><br><span class="line">            char ch = s.charAt(right);</span><br><span class="line">            hashMap.put(ch, hashMap.getOrDefault(ch, 0) + 1);</span><br><span class="line">            if(hashMap.get(ch) == 1)</span><br><span class="line">                counter++; //new char</span><br><span class="line">            </span><br><span class="line">            //move left when counter &gt; k</span><br><span class="line">            while(counter &gt; k)&#123;</span><br><span class="line">                char c = s.charAt(left);</span><br><span class="line">                hashMap.put(c, hashMap.get(c) - 1);</span><br><span class="line">                if(hashMap.get(c) == 0)</span><br><span class="line">                    counter--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //计算结果： re-cal global_max</span><br><span class="line">            global_max = Math.max(global_max, right - left + 1);</span><br><span class="line">            </span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return global_max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://blog.csdn.net/yy254117440/article/details/53025142" target="_blank" rel="noopener">https://blog.csdn.net/yy254117440/article/details/53025142</a></p></li><li><p>sliding window 中match Pattern 的题型（hashMap存的是P, counter 是window需要match P中还需要字符种类）</p><ul><li>LeetCode 76. Minimum Window Substring （H)经典题目</li><li>LeetCode 438. Find All Anagrams in a String （E)难难难！和上题结合看</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public String minWindow(String s, String t) &#123;</span><br><span class="line">        </span><br><span class="line">        if(s == null || s.length() == 0)</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        </span><br><span class="line">        if(t.length() &gt; s.length()) //Corner case 1: t.length() &gt; s.length()</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        </span><br><span class="line">        int left = 0, right = 0;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        int counter = 0;</span><br><span class="line">        int min_len = Integer.MAX_VALUE; //这里又错了！！！</span><br><span class="line">        int minStart = 0, minEnd = 0;</span><br><span class="line">        </span><br><span class="line">        //1. 初始化 hashMap by Pattern</span><br><span class="line">        char[] chars = t.toCharArray();</span><br><span class="line">        for(char c: chars)&#123;</span><br><span class="line">            hashMap.put(c, hashMap.getOrDefault(c, 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //counter: window还要match pattern中的字符种类数</span><br><span class="line">        counter = hashMap.size();</span><br><span class="line">        </span><br><span class="line">        //scan S to match the requirement in hashMap about T</span><br><span class="line">        while(right &lt; s.length())&#123;</span><br><span class="line">            char ch = s.charAt(right);</span><br><span class="line">            if(hashMap.containsKey(ch))&#123;</span><br><span class="line">                hashMap.put(ch, hashMap.get(ch) - 1);</span><br><span class="line">                if(hashMap.get(ch) == 0)&#123;</span><br><span class="line">                    counter--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //moving left</span><br><span class="line">            while(counter == 0)&#123; //可能出现结果的地方</span><br><span class="line">                //计算结果： min/max or add new result or re-cal min-window</span><br><span class="line">                char lchar = s.charAt(left);</span><br><span class="line">                if(right - left + 1 &lt; min_len)&#123;</span><br><span class="line">                    min_len = right - left + 1;</span><br><span class="line">                    minStart = left;</span><br><span class="line">                    minEnd = right;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                //check the condional variable, # of types requires</span><br><span class="line">                if(hashMap.containsKey(lchar))&#123;  //只有在T hashMap中的才需要更新</span><br><span class="line">                    if(hashMap.get(lchar) == 0)</span><br><span class="line">                        counter++;</span><br><span class="line">                    //update hashMap</span><br><span class="line">                    hashMap.put(lchar, hashMap.get(lchar) + 1);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(min_len == Integer.MAX_VALUE)  //Corner case 2: s = &quot;abcd&quot; t = &quot;mmm&quot; 踩坑点！！！！！！又错了</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        else</span><br><span class="line">            return s.substring(minStart, minEnd + 1);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>常见题型：</p><p>LeetCode 443. String Compression (In-place, Two Pointers, copy char + copy count)</p><p>LeetCode 38. Count and Say (非In-Place 模板： i == str.length - 1 || str[i] != str[i + 1] )</p><hr><p>Map Reduce基本原理：以某种方式把jobs尽量均衡平衡的分布到每个mapper（slaves)机器上去。</p><p>reducer: intergation/aggregation:把最后的结果集成下来且保证正确性</p><p>什么时候用到map reduce: 一台机器搞不定运算， assume 1000 pcs to solve this problems.</p><ol><li><p>you need to understand the <strong>Distribution of data</strong> by performing <strong>Sampling</strong> to the data.</p></li><li><p>Mapper: relatively independently to solve the problem</p></li></ol><ol start="2"><li>Reducer:</li></ol><h1 id="Substring-问题的模板？？？"><a href="#Substring-问题的模板？？？" class="headerlink" title="Substring 问题的模板？？？"></a>Substring 问题的模板？？？</h1><p>XOR问题？？？</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图的搜索</title>
      <link href="/2018/05/22/%E5%9B%BE%E7%9A%84%E6%90%9C%E7%B4%A2/"/>
      <url>/2018/05/22/%E5%9B%BE%E7%9A%84%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h1><a id="more"></a><h2 id="Graph-representation"><a href="#Graph-representation" class="headerlink" title="Graph representation"></a>Graph representation</h2><h3 id="1-Ajacent-Matrix"><a href="#1-Ajacent-Matrix" class="headerlink" title="1. Ajacent Matrix"></a>1. Ajacent Matrix</h3><h3 id="2-Ajacent-List"><a href="#2-Ajacent-List" class="headerlink" title="2. Ajacent List"></a>2. Ajacent List</h3><h3 id="3-Ajacent-HashTable-hashMap-hashSet-重点"><a href="#3-Ajacent-HashTable-hashMap-hashSet-重点" class="headerlink" title="3. Ajacent HashTable(hashMap, hashSet)重点"></a>3. Ajacent HashTable(hashMap, hashSet)重点</h3><h2 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS-1"></a>BFS-1</h2><p><strong>按照start node(nodes), 按照一步以外的一圈走完之后，再以两步以外的一圈走完。。。一步一步往外走，直到queue为空</strong></p><h2 id="BFS-1-1"><a href="#BFS-1-1" class="headerlink" title="BFS-1"></a>BFS-1</h2><p>###BFS-1代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void bfs1(Node root)&#123;</span><br><span class="line">    if(root == null)</span><br><span class="line">    return;</span><br><span class="line">    </span><br><span class="line">    Queue&lt;Node&gt; q = new LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    while(!q.isEmpty())&#123;</span><br><span class="line">    //重点： 分层遍历， 在所有操作前， 记录size</span><br><span class="line">        int size = q.size();</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; size; i++)&#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            if(cur.left != null)</span><br><span class="line">            q.offer(cur.left);</span><br><span class="line">            if(cur.right != null)</span><br><span class="line">            q.offer(cur.right);</span><br><span class="line">            </span><br><span class="line">            Sysytem.out.print(cut.val + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常考题型"><a href="#常考题型" class="headerlink" title="常考题型"></a>常考题型</h3><ol><li><p>分层遍历： int size = queue.size()</p></li><li><p>Bipartile: 分组(u, v)， 如果同一个结点既背分到u group，后来又被分到v group，肯定不是bipartile</p><p>1(u) —— 2(v)</p><p>​    \     /</p><p>​    3(v != u)</p></li><li><p>determine a binary tree is a <strong>complete binary tree</strong>: 判断同层是否有气泡</p></li></ol><h3 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h3><h4 id="1-什么时候用BFS-1"><a href="#1-什么时候用BFS-1" class="headerlink" title="1. 什么时候用BFS-1"></a>1. 什么时候用BFS-1</h4><p>Tree Problem + <strong>考虑到<u><em>同层关系</em></u>时</strong>。</p><h2 id="Best-First-Search-BFS-2"><a href="#Best-First-Search-BFS-2" class="headerlink" title="Best First Search(BFS-2)"></a>Best First Search(BFS-2)</h2><p><strong>使用minHeap, 按照最小的key先出来</strong></p><h3 id="经典算法：-Dijkstra’s-Algorithm"><a href="#经典算法：-Dijkstra’s-Algorithm" class="headerlink" title="经典算法： Dijkstra’s Algorithm"></a>经典算法： Dijkstra’s Algorithm</h3><h4 id="1-Usage-点到面（-所有点）的最短距离算法"><a href="#1-Usage-点到面（-所有点）的最短距离算法" class="headerlink" title="1. Usage: 点到面（==所有点）的最短距离算法"></a>1. Usage: 点到面（==所有点）的最短距离算法</h4><h4 id="2-Example-Problem-从北京到中国其他所有主要城市的最短距离是多少"><a href="#2-Example-Problem-从北京到中国其他所有主要城市的最短距离是多少" class="headerlink" title="2. Example Problem: 从北京到中国其他所有主要城市的最短距离是多少"></a>2. Example Problem: 从北京到中国其他所有主要城市的最短距离是多少</h4><h4 id="3-Data-Structure-PriorityQueue-minHeap"><a href="#3-Data-Structure-PriorityQueue-minHeap" class="headerlink" title="3. Data Structure: PriorityQueue(minHeap)"></a>3. Data Structure: PriorityQueue(minHeap)</h4><h4 id="4-解题思路："><a href="#4-解题思路：" class="headerlink" title="4. 解题思路："></a>4. 解题思路：</h4><h5 id="4-1-initial-state-start-node"><a href="#4-1-initial-state-start-node" class="headerlink" title="4.1 initial state(start node)"></a>4.1 initial state(start node)</h5><h5 id="4-2-Node-expansion-Genration-rule"><a href="#4-2-Node-expansion-Genration-rule" class="headerlink" title="4.2 Node expansion/Genration rule:"></a>4.2 Node expansion/Genration rule:</h5><h5 id="4-3-Terminations-Condition-所有点都计算完毕才停止，也就是minHeap为空时"><a href="#4-3-Terminations-Condition-所有点都计算完毕才停止，也就是minHeap为空时" class="headerlink" title="4.3 Terminations Condition: 所有点都计算完毕才停止，也就是minHeap为空时"></a>4.3 Terminations Condition: 所有点都计算完毕才停止，也就是minHeap为空时</h5><p>####BFS应用—Topological sort</p><p>不同于BFS-1从一个start node 从上往下层层搜索； </p><p><strong>Topological sort是从外（<u>从所有leaves出发</u>）往里一层一层的缩小，直到Queue为空</strong></p><ol><li>LeetCode 207. Course Schedule</li><li>LeetCode 210. Course Schedule II</li><li>LeetCode 310. Minimum Height Trees 总结未做</li><li>LeetCode 444: Sequence Reconstruction ?</li><li>LeetCode 269: Alien Dictionary ?</li></ol><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><ol><li>粉红色路径，一头扎到底，（backtracking）是扎到底之后返回它上一层</li><li>有些问题不能使用BFS-1,是因为随着搜索范围的增大，层数的增大，queue的size也会随着exponetially 增大</li></ol><ul><li>Recall “using pre-order to traverse a tree”</li><li>实现方法： easy to use <strong>recursion</strong></li><li>常见考题：<ol><li>DFS 例题1： print all subsets of a set</li><li>DFS 例题2： print all valid permutation of () () ()</li><li>DFS 例题3： e.g.凑硬币金额99分<ul><li>有1分， 5分， 10 分， 25分coins, 给定金额99cents, 有多少种组成方式，并打印出所有可能组合</li></ul></li><li>DFS一类的题目</li></ol></li></ul><h3 id="1-DFS-类型1：0-or-1"><a href="#1-DFS-类型1：0-or-1" class="headerlink" title="1. DFS 类型1：0 or 1"></a>1. DFS 类型1：0 or 1</h3><p>####例题1. LeetCode 78. Subsets</p><p>题意： Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets (the power set).</p><p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p><p><img src="http://server.myspace-shack.com/d23/f0ae1fd5-fe37-47f6-9fe2-47f68aa58869.png" alt=""></p><p><img src="http://server.myspace-shack.com/d23/1ebef5ec-c5a2-440b-90e1-1ddb415109f2.png" alt=""></p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       //解法一： 对每个数字选 or 不选</span><br><span class="line">       //no duplicate</span><br><span class="line">       //dfs recusion tree</span><br><span class="line">       //有多少layer： n个数字，所有对n个数字做选 or 不选， ---n layer</span><br><span class="line">       //有多少个分叉： two, ---选 or 不选</span><br><span class="line">       </span><br><span class="line">       if(nums == null || nums.length == 0)</span><br><span class="line">           return new ArrayList&lt;&gt;();</span><br><span class="line">       </span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">       List&lt;Integer&gt; subset = new ArrayList&lt;&gt;();</span><br><span class="line">       </span><br><span class="line">       dfs(nums, 0, subset, res);</span><br><span class="line">       </span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void dfs(int[] nums, int index, List&lt;Integer&gt; subset, List&lt;List&lt;Integer&gt;&gt; res)&#123;</span><br><span class="line">       if(index == nums.length)&#123;</span><br><span class="line">           res.add(new ArrayList&lt;&gt;(subset));</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       if(index &lt; nums.length)&#123;</span><br><span class="line">           //case 1: chose nums[i]</span><br><span class="line">           subset.add(nums[index]);</span><br><span class="line">           dfs(nums, index + 1, subset, res);</span><br><span class="line">           subset.remove(subset.size() - 1);</span><br><span class="line"></span><br><span class="line">           //case 2: not choose nums[i]</span><br><span class="line">           dfs(nums, index + 1, subset, res);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="例题2：-LeetCode-22-Generate-Parentheses"><a href="#例题2：-LeetCode-22-Generate-Parentheses" class="headerlink" title="例题2： LeetCode 22: Generate Parentheses"></a>例题2： LeetCode 22: Generate Parentheses</h4><p>#####类似subset-I: 选‘（ ’ or 选‘ ）’ + 特定的<strong>剪枝</strong>—即：什么时候可以加（， 什么时候可以加）</p><p>题意：</p><p>Given <em>n</em> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>For example, given <em>n</em> = 3, a solution set is:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>思路：</p><p><img src="http://server.myspace-shack.com/d23/5f1594d6-3eff-48be-835b-5a0a66f2d7d1.png" alt=""></p><h5 id="Recursion-Tree"><a href="#Recursion-Tree" class="headerlink" title="Recursion Tree"></a>Recursion Tree</h5><p><img src="http://server.myspace-shack.com/d23/e55a1cf9-6641-46fe-82d7-a800c4bb5001.png" alt=""></p><p>虚线的state代表的是剪枝（<strong>Restrictions</strong>）</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        </span><br><span class="line">        //左右括号都必须得匹配</span><br><span class="line">        //n pairs of parentheses, then we have 2*n position to put &apos;(&apos; or &apos;)&apos;</span><br><span class="line">        //for each positon , we can either put &apos;(&apos; or &apos;)&apos;, 但是我们有一些constraints</span><br><span class="line">        //类似subset问题中每个数字，选or不选的关系</span><br><span class="line">        //constraints:</span><br><span class="line">        //1. 什么时候可以加&apos;(&apos;? --- numL # of &apos;(&apos; &lt; n</span><br><span class="line">        //2. 什么时候可以加&apos;)&apos;? --- numR # of &apos;(&apos; &gt; # of &apos;)&apos;</span><br><span class="line">        //3. base case: 什么时候跳出？ --- numL == n &amp;&amp; numR == n</span><br><span class="line">        List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        if(n == 0)</span><br><span class="line">            return res;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        </span><br><span class="line">        chooseLOrRhelper(n, 0 , 0, sb, res);</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //DFS: </span><br><span class="line">    public void chooseLOrRhelper(int n, int numL, int numR, StringBuilder sb, List&lt;String&gt; res)&#123;</span><br><span class="line">        </span><br><span class="line">        if(numL == n &amp;&amp; numR == n)&#123;</span><br><span class="line">            res.add(new StringBuilder(sb).toString());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //case 1: add &apos;(&apos;, 左子树</span><br><span class="line">        if(numL &lt; n)&#123;</span><br><span class="line">            sb.append(&apos;(&apos;);</span><br><span class="line">            chooseLOrRhelper(n, numL + 1, numR, sb, res);</span><br><span class="line">            sb.deleteCharAt(sb.length() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //case 2: add &apos;)&apos;, 右子树</span><br><span class="line">        if(numL &gt; numR)&#123;</span><br><span class="line">            sb.append(&apos;)&apos;);</span><br><span class="line">            chooseLOrRhelper(n, numL, numR + 1, sb, res);</span><br><span class="line">            sb.deleteCharAt(sb.length() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####例题4：LeetCode 46. Permutations </p><p>题意：</p><p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>#####方法一： with extra space: <strong>used[] 去记录某个数字是否使用过</strong></p><p><img src="http://i67.tinypic.com/2yx1a9u.png" alt=""></p><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">        </span><br><span class="line">        if(nums == null || nums.length == 0)</span><br><span class="line">            return new ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; item = new ArrayList&lt;&gt;();</span><br><span class="line">        int[] visited = new int[nums.length];</span><br><span class="line">        </span><br><span class="line">        dfs(nums, 0, item, res, visited);</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void dfs(int[] nums, int level, List&lt;Integer&gt; item, List&lt;List&lt;Integer&gt;&gt; res, int[] visited)&#123;</span><br><span class="line">        if(level == nums.length)&#123;</span><br><span class="line">            res.add(new ArrayList(item));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(level &lt; nums.length)&#123;</span><br><span class="line">            </span><br><span class="line">            //how many cases on each state on each level?</span><br><span class="line">            //i = 0----n, need to check visited</span><br><span class="line">            for(int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">                </span><br><span class="line">                if(visited[i] == 0)&#123;</span><br><span class="line">                    item.add(nums[i]);</span><br><span class="line">                    visited[i] = 1;</span><br><span class="line">                    dfs(nums, level + 1, item, res, visited);</span><br><span class="line">                    item.remove(item.size() - 1);</span><br><span class="line">                    visited[i] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二： in-place: 不需要used[] 去记录某个数字是否使用过</p><p>####<u>permutation —In-place 方法之index-swap-swap</u></p><p><img src="http://i68.tinypic.com/27xr0o5.png" alt=""></p><p>注意点：</p><ol><li>for循环中0 改为<strong>index</strong> </li><li>每次swap(input, <strong>index</strong>, i);</li></ol><p><img src="http://i65.tinypic.com/j58jk6.png" alt=""></p><h3 id="DFS中关于combination-permutation的一些问题"><a href="#DFS中关于combination-permutation的一些问题" class="headerlink" title="DFS中关于combination, permutation的一些问题"></a>DFS中关于combination, permutation的一些问题</h3><h4 id="1-Combination-题型及变形"><a href="#1-Combination-题型及变形" class="headerlink" title="1. Combination 题型及变形"></a>1. Combination 题型及变形</h4><h4 id="1-1-LeetCode-78-Subsets"><a href="#1-1-LeetCode-78-Subsets" class="headerlink" title="1.1 LeetCode 78. Subsets"></a>1.1 LeetCode 78. Subsets</h4><p>Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets (the power set).</p><p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Recursion Tree:</p><p><img src="http://server.myspace-shack.com/d23/0b14246c-4bef-4ed8-9062-9db01aa02211.png" alt=""></p><p>Follow-Up: LeetCode 90. Subsets II (有重复数字)</p><p>Given a collection of integers that might contain duplicates, <strong>nums</strong>, return all possible subsets (the power set).</p><p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Recursion Tree:</p><p><img src="http://server.myspace-shack.com/d23/86d36228-0fc1-47ea-916a-15054e45e792.png" alt=""></p><h4 id="1-2-Combination-Sum-input无重复-一个数字可以用无数次"><a href="#1-2-Combination-Sum-input无重复-一个数字可以用无数次" class="headerlink" title="1.2 Combination Sum (input无重复 + 一个数字可以用无数次)"></a>1.2 Combination Sum (input无重复 + 一个数字可以用无数次)</h4><p>Given a <strong>set</strong> of candidate numbers (<code>candidates</code>) <strong>(without duplicates)</strong> and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p><p>The <strong>same</strong> repeated number may be chosen from <code>candidates</code> unlimited number of times.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [2,3,6,7], target = 7,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p> Recusion Tree:</p><p><img src="http://server.myspace-shack.com/d23/c567f485-93a6-4d00-b1ed-db852fa24da2.png" alt=""></p><p>Folow-Up: LeetCode 40. Combination Sum II (input有重复 + 每个数字只能用一次)</p><p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p><p>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Recursion Tree:</p><p><img src="http://server.myspace-shack.com/d23/67482f96-dff9-4fe8-9eec-e7c9a3225eed.png" alt=""></p><p>Follow-Up: LeetCode 216. Combination Sum III （从1–9中挑选k个数字使得它们的和为n)</p><p>Find all possible combinations of <strong>*k*</strong> numbers that add up to a number <strong>*n*</strong>, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: k = 3, n = 7</span><br><span class="line">Output: [[1,2,4]]</span><br></pre></td></tr></table></figure><p>Recursion Tree:</p><p><img src="http://server.myspace-shack.com/d23/79fdb8c4-9d25-4992-bed1-065da5634775.png" alt=""></p><h3 id="1-3-Combination"><a href="#1-3-Combination" class="headerlink" title="1.3 Combination"></a>1.3 Combination</h3><p>Given two integers <em>n</em> and <em>k</em>, return all possible combinations of <em>k</em> numbers out of 1 … <em>n</em>.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4, k = 2</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Recursion Tree:</p><p><img src="http://server.myspace-shack.com/d23/189d9f82-964a-4bcd-bd33-aeefe35c3c18.png" alt=""></p><h3 id="2-Permutation及其变形"><a href="#2-Permutation及其变形" class="headerlink" title="2. Permutation及其变形"></a>2. Permutation及其变形</h3><h4 id="2-1-Permutaiton-输入无重复"><a href="#2-1-Permutaiton-输入无重复" class="headerlink" title="2.1 Permutaiton (输入无重复)"></a>2.1 Permutaiton (输入无重复)</h4><p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>写法一：visited</p><p><img src="http://server.myspace-shack.com/d23/62469540-7ded-48f4-ac19-71e341ebf771.png" alt=""></p><p>写法二：index-swap-swap（只能在input是array的况下使用）</p><p>Recursion Tree:</p><p><img src="http://server.myspace-shack.com/d23/1fe15417-3324-403e-9b6a-980190b8ff46.png" alt=""></p><h4 id="2-2-Permutation-input存在dupicate"><a href="#2-2-Permutation-input存在dupicate" class="headerlink" title="2.2 Permutation (input存在dupicate)"></a>2.2 Permutation (input存在dupicate)</h4><p><img src="http://server.myspace-shack.com/d23/4dc0816c-5440-45ab-9571-2a25660c8372.png" alt=""></p><h2 id="再次总结："><a href="#再次总结：" class="headerlink" title="再次总结："></a>再次总结：</h2><p>###关于<strong>Recursion</strong>一些自己的误区及纠正：</p><p>E.g. Recursion Tree:</p><p><img src="http://i68.tinypic.com/27xr0o5.png" alt=""></p><ol><li><p>关于Recursion中的global, 和local（局部）变量的理解</p><p>public void <strong>dfs(char[] str, int index, List<character> tmp, List&lt;List<string>&gt; res, int[] used)</string></character></strong></p><ul><li>recursion function中的argument都是global的—对于reference type data(tmp, res, used), 都是全局可变的，<strong>即—随着recursion tree traverse， recursion funciton 有时需要做内部更改（如：tmp, res, used）</strong> <strong>就像每个结点上的一个随身记事本</strong></li><li>在recursion function 内部定义的变量是local（局部）变量。<strong>只记录当前层上同一个父节点下children结点的状态</strong></li></ul><p>在recursion tree上的体现为：</p><p>—–如处理duplicate character时：需要定义一个hashSet, 去记录<strong>当前level(index)在同一个父节点</strong>下是否visited过某个character</p><p>例如：在L1层， 用一个hashSet 记录在<strong>该level上</strong>用到过的character b1</p><p><img src="http://server.myspace-shack.com/d23/b53e18df-71d1-4602-a691-17bb0601b51c.png" alt=""></p></li></ol><p>### </p><hr><table><thead><tr><th>ID</th><th>Name</th><th>Difficulty</th><th>P/F</th><th>Data Structure</th><th>Skills</th><th>Sepcial</th></tr></thead><tbody><tr><td>46</td><td>Permutations</td><td>M</td><td>1/1</td><td></td><td>(DFS) -Way1. <strong>In-place: index-swap-swap.</strong> -Way2. Extra Space: List&lt;&gt; tmp + int[] used</td><td>经典</td></tr><tr><td>47</td><td>PermutationII</td><td>M</td><td>1/1</td><td></td><td>如上Way 1: sort. Way2: hashset去重复</td><td>de-dup</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Greedy 总结</title>
      <link href="/2018/05/16/Greedy-%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/16/Greedy-%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Greedy-总结"><a href="#Greedy-总结" class="headerlink" title="Greedy 总结"></a>Greedy 总结</h1><p>题目中一般带有最小的，最少的。。。hint keyword</p><p>Greedy 对interval overlapping 问题</p><p>对起点sorting，找overlapping</p><ol start="56"><li><p>Merge Intervals</p></li><li><p>Meeting Rooms</p></li></ol><a id="more"></a><p>##LeetCode 253. Meeting Rooms II</p><p>Given an array of meeting time intervals consisting of start and end times <code>[[s1,e1],[s2,e2],...]</code> (si &lt; ei), find the minimum number of conference rooms required.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0, 30],[5, 10],[15, 20]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[7,10],[2,4]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p>time: O(nlogn)<br> space: O(n)</p><p>###问题分析：</p><ul><li>把每一个interval 按照start time 排序</li><li>把第一个interval加入minHeap, 代表我至少需要一个room with meeting ending at e1</li><li>遍历排序后的intervals：</li></ul><p>​        之后没遍历到的一个interval i，</p><ol><li>如果i’s start time &lt; 最早结束的room’s ending time, 那么它一定与其他room’s ending time 发生冲突， 所以要新开一个room with i’s ending time</li><li>如果i’s start time &gt; 最早结束的room’s ending time, 那么i meeting 可以用最早结束meeting的room，只需要update最早结束room的ending time to i’s ending time.</li></ol><p>​        </p><pre><code>//分析所需数据结构：//每次我们比较，我们都需要cur&apos;s meeting 和最早结束的room&apos;s ending time//用minHeap， O(1)得到最小ending time//注意： 我们每次真正在意的是之前heap中room&apos;s ending time, 所以只需要存ending time 就可以了//# of minimum room = minHeap.size()</code></pre><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minMeetingRooms(Interval[] intervals) &#123;</span><br><span class="line">        </span><br><span class="line">        if(intervals == null || intervals.length == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; a.start - b.start);</span><br><span class="line">        </span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; a - b);</span><br><span class="line">        </span><br><span class="line">        minHeap.offer(intervals[0].end);</span><br><span class="line">        </span><br><span class="line">        for(int i = 1; i &lt; intervals.length; i++)&#123;</span><br><span class="line">            if(intervals[i].start &lt; minHeap.peek())&#123; //overlaping, new room with i&apos;s ending time</span><br><span class="line">                minHeap.offer(intervals[i].end);</span><br><span class="line">            &#125;else&#123;//not conflict, just use this room, update room&apos;s ending time wiht i&apos;s ending time</span><br><span class="line">                Integer minEnd = minHeap.poll();</span><br><span class="line">                minHeap.offer(intervals[i].end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return minHeap.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Greedy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Heap 总结</title>
      <link href="/2018/05/14/Heap-%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/14/Heap-%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>什么时候最好用到PriorityQueue：</p><p>求最大值/最小值时： O(1)</p><p>待总结！！！</p><p>Leetcode </p><ol start="347"><li><p>Top K Frequent Elements</p></li><li><p>Merge k Sorted Lists</p></li><li><p>Kth Smallest Element in a Sorted Matrix （23题的马甲题）！！注意变形</p></li><li><p>Ugly Number II</p></li></ol><p>经典题：两个Heap去找输入流，array的median</p><ol start="295"><li>Find Median from Data Stream</li></ol>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>复习Cards</title>
      <link href="/2018/05/12/%E5%A4%8D%E4%B9%A0Cards/"/>
      <url>/2018/05/12/%E5%A4%8D%E4%B9%A0Cards/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 复习1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 复习1 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Stack, Queue, Heap题型总结</title>
      <link href="/2018/05/10/Stack-Queue-Heap%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/10/Stack-Queue-Heap%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Stack-Queue-Heap-题型总结"><a href="#Stack-Queue-Heap-题型总结" class="headerlink" title="Stack, Queue, Heap 题型总结"></a>Stack, Queue, Heap 题型总结</h1><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><h3 id="基础题："><a href="#基础题：" class="headerlink" title="基础题："></a>基础题：</h3><p>####LeetCode 232. Implement Queue using Stacks </p><p>题目意思： 用两个Stacks 实现Queue的功能： push(x), pop(), peek(), empty()</p><p>思路： stack1用作push(), </p><p>stack2 用作pop()时把Stack1中正序过来，然后 stack2.pop()</p><p>主要是pop的实现：</p><ol><li><p>if Stack2 is empty： transfer all stack1’s elements to stack2</p></li><li><p>endif; return stack2.pop()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class MyQueue &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    public MyQueue() &#123;</span><br><span class="line">        stack1 = new Stack&lt;&gt;();</span><br><span class="line">        stack2 = new Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Push element x to the back of queue. */</span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Removes the element from in front of queue and returns that element. */</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        if(stack2.isEmpty())&#123;</span><br><span class="line">            while(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Get the front element. */</span><br><span class="line">    public int peek() &#123;</span><br><span class="line">        if(stack2.isEmpty())&#123;</span><br><span class="line">            while(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns whether the queue is empty. */</span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        </span><br><span class="line">        return stack1.isEmpty() &amp;&amp; stack2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="题型二：Iterator类型"><a href="#题型二：Iterator类型" class="headerlink" title="题型二：Iterator类型"></a>题型二：Iterator类型</h3><h4 id="注意点：-主程序应该在hasNext还是在next-中实现？"><a href="#注意点：-主程序应该在hasNext还是在next-中实现？" class="headerlink" title="注意点： 主程序应该在hasNext还是在next 中实现？"></a>注意点： 主程序应该在hasNext还是在next 中实现？</h4><p>答案是： 最好是hasNext中实现</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h4 id="LeetCode-225-Implement-Stack-using-Queues"><a href="#LeetCode-225-Implement-Stack-using-Queues" class="headerlink" title="LeetCode 225. Implement Stack using Queues"></a>LeetCode 225. Implement Stack using Queues</h4><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>用Queue实现Stack的<strong>LIFO</strong>操作： push(x), pop(), peek(), empty()</p><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><ol><li>方法一： Deque: 双向队列 offerLast(x), pollLast(), peekLast()</li><li>方法二： Queue: 单向出口队列： push(x): queue.offer(x)之后，记得把x前面的挪到queue后面去</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//方法二</span><br><span class="line">class MyStack &#123;</span><br><span class="line">    </span><br><span class="line">    //单向队列</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    public MyStack() &#123;</span><br><span class="line">        queue = new LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Push element x onto stack. */</span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        for(int i = 0; i &lt; queue.size() - 1; i++)</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Removes the element on top of the stack and returns that element. */</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        return queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Get the top element. */</span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns whether the stack is empty. */</span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Heap </tag>
            
            <tag> Stack </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Two Pointer 问题总结</title>
      <link href="/2018/05/09/Two%20Pointer%20%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/09/Two%20Pointer%20%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Two-Pointer-问题总结"><a href="#Two-Pointer-问题总结" class="headerlink" title="Two Pointer 问题总结"></a>Two Pointer 问题总结</h1><h2 id="基础热身题型（必会题型）："><a href="#基础热身题型（必会题型）：" class="headerlink" title="基础热身题型（必会题型）："></a>基础热身题型（必会题型）：</h2><ol><li>LeetCode283.  Move Zeroes</li><li>LeetCode 26:  Remove Duplicates from Sorted Array</li></ol><a id="more"></a><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a>Two Sum</h4><ul><li>= target </li><li>&lt;= target</li><li>>target</li><li>unique pairs</li><li>closest to target</li><li>difference = target </li></ul><h3 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h3><ul><li>Quick Select </li><li>分成两个部分 </li><li>分成三个部分 </li></ul><h3 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h3><ul><li>排序</li><li>烙饼排序</li><li>(还有前面学的拓扑排序 ）</li></ul><hr><!-- more --> <p>Quick Select(QuickSort 中的partition部分)用到了two pointer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 在nums中的start 到end， 找到一个pivot，是的pivot左边大于pivot，左边小于pivot</span><br><span class="line">    //return pIndex;</span><br><span class="line">    public int partition(int[] nums, int start, int end)&#123;</span><br><span class="line"></span><br><span class="line">        int pivot = nums[end];</span><br><span class="line">        int pIndex = start;</span><br><span class="line"></span><br><span class="line">        for(int i = start; i &lt; end; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i] &gt;= pivot)&#123;</span><br><span class="line">                swap(nums, i, pIndex);</span><br><span class="line">                pIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(nums, pIndex, end);</span><br><span class="line"></span><br><span class="line">        return pIndex;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="1-Array中的Two-Pointer"><a href="#1-Array中的Two-Pointer" class="headerlink" title="1. Array中的Two Pointer"></a>1. Array中的Two Pointer</h1><h2 id="经典题型：-2-Sum-3-Sum"><a href="#经典题型：-2-Sum-3-Sum" class="headerlink" title="经典题型： 2 Sum + 3 Sum"></a>经典题型： 2 Sum + 3 Sum</h2><h3 id="相似点：-对于求2个变量如何组合的问题，-可以循环其中一个变量，-然后研究另外一个变量如何变化"><a href="#相似点：-对于求2个变量如何组合的问题，-可以循环其中一个变量，-然后研究另外一个变量如何变化" class="headerlink" title="相似点： 对于求2个变量如何组合的问题， 可以循环其中一个变量， 然后研究另外一个变量如何变化"></a>相似点： 对于求2个变量如何组合的问题， 可以循环其中一个变量， 然后研究另外一个变量如何变化</h3><h4 id="Two-Sum-——Unsorted-array"><a href="#Two-Sum-——Unsorted-array" class="headerlink" title="Two Sum:——Unsorted array"></a>Two Sum:——Unsorted array</h4><h5 id="思路：-HashMap"><a href="#思路：-HashMap" class="headerlink" title="思路： HashMap"></a>思路： HashMap</h5><p>complexity:</p><p>time: O(n)</p><p>space: O(n)</p><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure><h5 id="代码：-C"><a href="#代码：-C" class="headerlink" title="代码： C++"></a>代码： C++</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; diffIndex;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i&lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            // map存diff，index； 在map中找当前nums[i]</span><br><span class="line">            if(diffIndex.find(nums[i]) != diffIndex.end())</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(diffIndex[nums[i]]);</span><br><span class="line">                result.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            diffIndex[target - nums[i]] = i;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Two-Sum—-sorted-array"><a href="#Two-Sum—-sorted-array" class="headerlink" title="Two Sum— sorted array"></a>Two Sum— sorted array</h4><p>#####思路： Two pointer </p><p>complexity:</p><ul><li>time: O(n)</li><li>space: O(1)</li></ul><p>Given an array of integers that is already <strong>sorted in ascending order</strong>, find two numbers such that they add up to a specific target number.</p><p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</p><p><strong>Note:</strong></p><ul><li>Your returned answers (both index1 and index2) are not zero-based.</li><li>You may assume that each input would have <em>exactly</em> one solution and you may not use the <em>same</em> element twice.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: numbers = [2,7,11,15], target = 9</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.</span><br></pre></td></tr></table></figure><h5 id="代码：-Java"><a href="#代码：-Java" class="headerlink" title="代码： Java"></a>代码： Java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] numbers, int target) &#123;</span><br><span class="line">        </span><br><span class="line">        int left = 0, right = numbers.length - 1;</span><br><span class="line">        int[] res = new int[2];</span><br><span class="line">        </span><br><span class="line">        while(left &lt; right)&#123;</span><br><span class="line">            int sum = numbers[left] + numbers[right];</span><br><span class="line">            </span><br><span class="line">            if(sum == target)&#123;</span><br><span class="line">                res[0] = left + 1;</span><br><span class="line">                res[1] = right + 1;</span><br><span class="line">                return res;</span><br><span class="line">            &#125;else if(sum &gt; target)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-sum："><a href="#3-sum：" class="headerlink" title="3 sum："></a>3 sum：</h4><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><ul><li>根据2sum思路： nums[i] + nums[j] + nums[k] = 0</li><li>默认nums[i] &lt;= nums[j] &lt;= nums[k]; 所以先Sort array</li><li>固定nums[i], 在i之后找到关于nums[j], nums[k]的所有组合可能性</li><li>难点： 注意i， j,  k都要去重： /<em>去重技巧， nums[i] == nums[i - 1] 往前</em>/</li></ul><h5 id="代码：-Java-1"><a href="#代码：-Java-1" class="headerlink" title="代码： Java"></a>代码： Java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        </span><br><span class="line">        //Sort nums</span><br><span class="line">        //nums[i] + nums[j] + nums[k] =0</span><br><span class="line">        //固定第一个数字，从i后面找剩下两个大一点的数字的组合可能性</span><br><span class="line">        //注意要多i，和j, k 都同时除重</span><br><span class="line">        </span><br><span class="line">        //time complexity： O(nlogn + n^2)</span><br><span class="line">        //space: O(1)</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; nums.length - 2; i++)&#123;</span><br><span class="line">            /*去重技巧， nums[i] == nums[i - 1] 往前*/</span><br><span class="line">            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) //skip same result</span><br><span class="line">                continue;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            int left = i + 1;</span><br><span class="line">            int right = nums.length - 1;</span><br><span class="line">            int target = 0 - nums[i];</span><br><span class="line">            while(left &lt; right)&#123;</span><br><span class="line">                int sum = nums[left] + nums[right];</span><br><span class="line">                </span><br><span class="line">                if(sum == target)&#123;</span><br><span class="line">                    list.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    left++; //继续往内侧压缩，找其他可能性</span><br><span class="line">                    right--;</span><br><span class="line">                    /*去重技巧， nums[i] == nums[i - 1] 往前*/</span><br><span class="line">                    while(left &lt; right &amp;&amp; nums[left] == nums[left - 1]) //skip same result</span><br><span class="line">                        left++;</span><br><span class="line">                    while(left &lt; right &amp;&amp; nums[right] == nums[right + 1]) //skip same result</span><br><span class="line">                        right--;</span><br><span class="line">                    </span><br><span class="line">                &#125;else if(sum &gt; target)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return list;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3Sum-Closest"><a href="#3Sum-Closest" class="headerlink" title="3Sum Closest"></a>3Sum Closest</h4><p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 2, 1, -4], and target = 1.</span><br><span class="line"></span><br><span class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>类似于3Sum</p><ol><li>nums[i] + nums[left] + nums[right] —&gt;target</li><li>sort array, 再固定nums[i]， 对i 之后的做2Sum， 并计算bestSum</li></ol><p>Complexity:</p><ol><li>time:  O(n^2)</li><li>space: O(1)</li></ol><h4 id="代码：-Java-2"><a href="#代码：-Java-2" class="headerlink" title="代码： Java"></a>代码： Java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int threeSumClosest(int[] nums, int target) &#123;</span><br><span class="line">        </span><br><span class="line">        //-1, 1, 2, -4</span><br><span class="line">        //-4 -1 1 2</span><br><span class="line">        //      0 0</span><br><span class="line">        </span><br><span class="line">        // if(nums == null || nums.length == 0 || nums.length &lt; 3)</span><br><span class="line">        //     return 0;</span><br><span class="line">        </span><br><span class="line">        //Time complexity: O(n^2)</span><br><span class="line">        //space complexity: O(1)</span><br><span class="line">        类似于3Sum</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        int bestSum = nums[0] + nums[1] + nums[2];</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.length - 2; i++)&#123;</span><br><span class="line">        </span><br><span class="line">            int left = i + 1;</span><br><span class="line">            int right = nums.length - 1;</span><br><span class="line">            </span><br><span class="line">            while( left &lt; right)&#123;</span><br><span class="line">                sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                if(Math.abs(target - sum) &lt; Math.abs(target - bestSum))</span><br><span class="line">                    bestSum = sum;</span><br><span class="line">                </span><br><span class="line">                if(sum &gt; target)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return bestSum;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4Sum"><a href="#4Sum" class="headerlink" title="4Sum"></a>4Sum</h4><p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = <code>target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>.</p><p><strong>Note:</strong></p><p>The solution set must not contain duplicate quadruplets.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h5><p>类似3Sum， </p><ol><li>nums[i] + nums[j] + nums[left] + nums[right] = target</li><li>fixed nums[i], then fixed nums[j], find the sum of two integer possibles, </li><li>注意点： 要对i， j, left, right 同时去重。 去重技巧/*i &gt; 0 &amp;&amp; nums[i] == nums[i - 1])/</li></ol><p>Complexity:</p><ol><li>time: O(n^3)</li><li>space: O(1)</li></ol><h5 id="代码：-Java-3"><a href="#代码：-Java-3" class="headerlink" title="代码： Java"></a>代码： Java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;</span><br><span class="line">        </span><br><span class="line">        if(nums == null || nums.length &lt; 4)</span><br><span class="line">            return new ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; nums.length - 3; i++)&#123;</span><br><span class="line">            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1])</span><br><span class="line">                continue;</span><br><span class="line">            for(int j = i + 1; j &lt; nums.length - 2; j++)&#123;</span><br><span class="line">                </span><br><span class="line">                /*去重技巧：j != i + 1 &amp;&amp;  nums[j] == nums[j - 1]*/</span><br><span class="line">                if(j != i + 1  &amp;&amp; nums[j] == nums[j - 1])</span><br><span class="line">                    continue;</span><br><span class="line">                </span><br><span class="line">                int left = j + 1;</span><br><span class="line">                int right = nums.length - 1;</span><br><span class="line">                while(left &lt; right)&#123;</span><br><span class="line">                    int sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    if(sum == target)&#123;</span><br><span class="line">                        list.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                        while(left &lt; right &amp;&amp; nums[left] == nums[left - 1])</span><br><span class="line">                            left++;</span><br><span class="line">                        while(left &lt; right &amp;&amp; nums[right] == nums[right + 1])</span><br><span class="line">                            right--;</span><br><span class="line">                        </span><br><span class="line">                    &#125;else if(sum &gt; target)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-Linked-List上的Two-Pointer"><a href="#2-Linked-List上的Two-Pointer" class="headerlink" title="2. Linked List上的Two Pointer"></a>2. Linked List上的Two Pointer</h1><h2 id="1-slow-fast-指针"><a href="#1-slow-fast-指针" class="headerlink" title="1. slow, fast 指针"></a>1. slow, fast 指针</h2><p>特点： slow 走一步， fast走两步</p><p>用处： </p><ol><li>检测LinkedList 上有没有环</li></ol><h3 id="LeetCode-141-Linked-List-Cycle"><a href="#LeetCode-141-Linked-List-Cycle" class="headerlink" title="LeetCode 141. Linked List Cycle"></a>LeetCode 141. Linked List Cycle</h3><p> 题目意思： 检测Linked List是否有环</p><p>Follow Up: 只用O(1) space </p><p><img src="http://i65.tinypic.com/1z2ltav.png" alt="Screen Shot 2018-05-11 at 3.36.28 PM"></p><p><strong>有环， slow, fast一定在环上某一点相遇</strong></p><p>####要点： slow = head; fast = head; while loop直到找到slow == fast为止， while loop 结束，代表没找到，return false;</p><p><strong>注意点： while loop中的<u>入口条件</u>： slow != null &amp;&amp; fast != null &amp;&amp; fast.next != null</strong></p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        </span><br><span class="line">        //slow 指针走一步，fast指针走两步，如果有环，slow和fast一定会在环上相遇</span><br><span class="line">        </span><br><span class="line">        if(head == null)</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;  </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        //注意点： 如果涉及到fast.next.next一定要先判断fast.next != null</span><br><span class="line">         while(fast != null &amp;&amp; fast.next != null)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            if(slow == fast)</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-142-Linked-List-Cycle-II"><a href="#LeetCode-142-Linked-List-Cycle-II" class="headerlink" title="LeetCode 142: Linked List Cycle II"></a>LeetCode 142: Linked List Cycle II</h3><p>题目意思： 找到Linked List中环的<strong>起点</strong></p><p>要点： <strong>fast的速度是slow两倍， 所以fast走的距离是slow的两倍。</strong> 如果slow, fast 相遇在z点， 那么slow走的路程： a + b; 而fast走的路程是a + b + c + b。所以： 2*（a + b) = a + b + c + b, —&gt;很重要的结论：  <strong>a = c</strong>.</p><p>根据以上结论， 只需要在相遇点z处再设置一个slow2 = head, 那么下次slow == slow2的时候，就是环的起点。</p><p><img src="http://i68.tinypic.com/2po7hy0.png" alt=""></p><p>代码；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode detectCycle(ListNode head) &#123;</span><br><span class="line">        </span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        </span><br><span class="line">        while(fast != null &amp;&amp; fast.next != null)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            if(slow == fast)&#123;//一定有环</span><br><span class="line">                ListNode slow2 = head;</span><br><span class="line">                while(slow != slow2)&#123;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    slow2 = slow2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                return slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //没有环</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Two Pointer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java常用API+数据结构</title>
      <link href="/2018/05/09/Java%E5%B8%B8%E7%94%A8API+%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2018/05/09/Java%E5%B8%B8%E7%94%A8API+%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="根据Input-Size-V-S-Time-Complexity"><a href="#根据Input-Size-V-S-Time-Complexity" class="headerlink" title="根据Input Size V.S. Time Complexity"></a>根据Input Size V.S. Time Complexity</h1><p><img src="http://i65.tinypic.com/2zs49qv.png" alt=""></p><a id="more"></a><h1 id="Data-Type"><a href="#Data-Type" class="headerlink" title="Data Type"></a>Data Type</h1><h2 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h2><table><thead><tr><th style="text-align:center">return</th><th style="text-align:center">Method</th><th style="text-align:center">Usage</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">boolean</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Character.html#isLetter-char-" target="_blank" rel="noopener">isLetter</a>(char ch)</td><td style="text-align:center">Character.isLetter(‘a’)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">static char</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Character.html#toLowerCase-char-" target="_blank" rel="noopener">toLowerCase</a>(char ch)</td><td style="text-align:center">Character.toLowerCase(‘A’)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">static String</td><td style="text-align:center">toString(char c)</td><td style="text-align:center">Character.toString(‘a’)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">static boolean</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Character.html#isWhitespace-char-" target="_blank" rel="noopener">isWhitespace</a>(char ch)</td><td style="text-align:center">Character.isWhiteSpace(‘ ‘)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">static boolean</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Character.html#isDigit-char-" target="_blank" rel="noopener">isDigit</a>(char ch)</td><td style="text-align:center">Character.isDigit(‘5’)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">static boolean</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Character.html#isLetterOrDigit-char-" target="_blank" rel="noopener">isLetterOrDigit</a>(char ch)</td><td style="text-align:center">Character.isLetterOrDigit(‘a’)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><!-- more --> <h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><table><thead><tr><th style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" target="_blank" rel="noopener">String</a>[]</th><th style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#split-java.lang.String-" target="_blank" rel="noopener">split</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" target="_blank" rel="noopener">String</a> regex)</th><th style="text-align:center">str.split(“\\+ “)</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">int</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#indexOf-java.lang.String-" target="_blank" rel="noopener">indexOf</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" target="_blank" rel="noopener">String</a> str or char ch)</td><td style="text-align:center">str.indexOf(“ab”); str.indexOf(‘a’)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">int</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#lastIndexOf-int-" target="_blank" rel="noopener">lastIndexOf</a>(char);  <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#lastIndexOf-int-" target="_blank" rel="noopener">lastIndexOf</a>(String)</td><td style="text-align:center">str.lastIndexOf(‘a’);str.lastIndexOf(“ab”)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">String</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#trim--" target="_blank" rel="noopener">trim</a>()</td><td style="text-align:center">str.trim()</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">toLowerCase()</td><td style="text-align:center">str.toLowerCase()</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">String</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#replaceAll-java.lang.String-java.lang.String-" target="_blank" rel="noopener">replaceAll</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" target="_blank" rel="noopener">String</a> regex, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" target="_blank" rel="noopener">String</a> replacement)</td><td style="text-align:center">str.replaceAll(“[^a-zA-Z0-9]”,””)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">String</td><td style="text-align:center">format(String format,                             Object… args)</td><td style="text-align:center">String.format(“%d:%02d”, h, m)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">String</td><td style="text-align:center">replace(String target, String replacement)</td><td style="text-align:center">str.replace(“+”, “0”)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">startsWith(String prefix)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#startsWith-java.lang.String-int-" target="_blank" rel="noopener">startsWith</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" target="_blank" rel="noopener">String</a> prefix, int toffset)</td><td style="text-align:center"></td></tr></tbody></table><h1 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h1><table><thead><tr><th>Return</th><th>Method</th><th>Usage</th><th></th></tr></thead><tbody><tr><td>String</td><td>Integer.toString(5)</td><td></td><td></td></tr><tr><td>Integer</td><td>Integer.<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Integer.html#valueOf-java.lang.String-" target="_blank" rel="noopener">valueOf</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" target="_blank" rel="noopener">String</a> s)</td><td></td><td></td></tr><tr><td>Integer</td><td>Interger.parseInt(“12345”)</td><td></td></tr></tbody></table><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><table><thead><tr><th>Return</th><th>Method</th><th>Usage</th><th></th></tr></thead><tbody><tr><td>String</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/StringBuilder.html#toString--" target="_blank" rel="noopener">toString</a>()</td><td>sb.toString()</td><td></td></tr><tr><td></td><td>reverse()</td><td></td><td></td></tr><tr><td></td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/StringBuilder.html#delete-int-int-" target="_blank" rel="noopener">delete</a>(int start, int end)</td><td></td><td></td></tr><tr><td></td><td>deleteCharAt(int index)</td><td></td><td></td></tr><tr><td>char</td><td>charAt(int index)</td><td></td><td></td></tr><tr><td>StringBuilder</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/StringBuilder.html#insert-int-char-" target="_blank" rel="noopener">insert</a>(int offset, E c)</td><td></td><td></td></tr><tr><td></td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/StringBuilder.html#setLength-int-" target="_blank" rel="noopener">setLength</a>(int newLength)</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><table><thead><tr><th>Return</th><th>Method</th><th>Usage</th><th></th></tr></thead><tbody><tr><td>E</td><td>get(int index)</td><td></td><td></td></tr><tr><td>E</td><td>set(int index, E element)</td><td></td><td></td></tr><tr><td></td><td>remove(int index)</td><td></td></tr></tbody></table><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><table><thead><tr><th style="text-align:center">Return</th><th style="text-align:center">Method</th><th style="text-align:center">Usage</th><th></th></tr></thead><tbody><tr><td style="text-align:center">boolean</td><td style="text-align:center"><code>add(E e)</code></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/LinkedList.html#addFirst-E-" target="_blank" rel="noopener">addFirst</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/util/LinkedList.html" target="_blank" rel="noopener">E</a> e)</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">E</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/LinkedList.html#get-int-" target="_blank" rel="noopener">get</a>(int index)</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/LinkedList.html#getFirst--" target="_blank" rel="noopener">getFirst</a>()</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/LinkedList.html#getLast--" target="_blank" rel="noopener">getLast</a>()</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/LinkedList.html#peekFirst--" target="_blank" rel="noopener">peekFirst</a>()</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><code>peekLast()</code></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/LinkedList.html#removeFirst--" target="_blank" rel="noopener">removeFirst</a>()</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><code>removeLast()</code></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a>[]</td><td style="text-align:center">toArray()</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><table><thead><tr><th>Return</th><th>Method</th><th>Usage</th><th></th></tr></thead><tbody><tr><td>void</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Collections.html#swap-java.util.List-int-int-" target="_blank" rel="noopener">swap</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/util/List.html" target="_blank" rel="noopener">List</a>&lt;?&gt; list, int i, int j)</td><td>Collections.swap(list, i, j)</td><td></td></tr><tr><td>void</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Collections.html#reverse-java.util.List-" target="_blank" rel="noopener">reverse</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/util/List.html" target="_blank" rel="noopener">List</a>&lt;?&gt; list)</td><td>Collections.reverse(list)</td><td></td></tr><tr><td>void</td><td>sort(List<t> list,Comparator&lt;? super T&gt; c)</t></td><td>Collections.sort(list, new myComp);</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h1><table><thead><tr><th>Return</th><th>Method</th><th>Usage</th><th>Description</th></tr></thead><tbody><tr><td>static int</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Arrays.html#binarySearch-int:A-int-" target="_blank" rel="noopener">binarySearch</a>(int[] a, int key)</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Arrays.html#binarySearch-int:A-int-" target="_blank" rel="noopener">binarySearch</a>(arr, 5)</td><td>return the index of key or  <code>(-(*insertion point*) - 1)</code>.Insertion index(index of first larger than key)</td></tr><tr><td>static int</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Arrays.html#binarySearch-int:A-int-int-int-" target="_blank" rel="noopener">binarySearch</a>(int[] a, int fromIndex, int toIndex, int key)</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Arrays.html#binarySearch-int:A-int-int-int-" target="_blank" rel="noopener">binarySearch</a>(arr,0, 100, 5)</td><td>return the index of key or  <code>(-(*insertion point*) - 1)</code>.Insertion index(index of first larger than key)</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><hr><h1 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h1><p>##Stack</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">Return</th><th style="text-align:center">Method</th><th style="text-align:center">Usage</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">E</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Stack.html#push-E-" target="_blank" rel="noopener">push</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/util/Stack.html" target="_blank" rel="noopener">E</a> item)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">E</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Stack.html#pop--" target="_blank" rel="noopener">pop</a>()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">E</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Stack.html#peek--" target="_blank" rel="noopener">peek</a>()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">isEmpty()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">size()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure><pre><code>|—&gt;不可以为primitive element， 必须是reference element</code></pre><table><thead><tr><th></th><th>Method:  <em>Returns special value</em></th><th>Method:  <em>Throws exception</em></th><th>Descripttion</th></tr></thead><tbody><tr><td></td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html#offer-E-" target="_blank" rel="noopener">offer</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html" target="_blank" rel="noopener">E</a> e)</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html#add-E-" target="_blank" rel="noopener">add</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html" target="_blank" rel="noopener">E</a> e)</td><td></td></tr><tr><td></td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html#poll--" target="_blank" rel="noopener">poll</a>()</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html#remove--" target="_blank" rel="noopener">remove</a>()</td><td>Retrieves and removes the <strong>head of this queue.</strong></td></tr><tr><td></td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html#peek--" target="_blank" rel="noopener">peek</a>()</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Queue.html#element--" target="_blank" rel="noopener">element</a>()</td><td></td></tr><tr><td></td><td>isEmpty()</td><td>isEmpty()</td><td></td></tr><tr><td></td><td>size()</td><td>size()</td><td></td></tr><tr><td></td><td>addAll()</td><td>addAll()</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>OR</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;();</span><br></pre></td></tr></table></figure><p>queue是collection的子接口，表示的数据结构为队列（FIFO）</p><p><u>deque</u>是queue的子接口，是<strong>double-ended-queue</strong>的缩写，表示的数据结构为双端队列</p><table><thead><tr><th style="text-align:center">Return</th><th style="text-align:center">Method</th><th style="text-align:center">Usage</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">offerFirst(e)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">offerLast(e)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">pollFirst()</td><td style="text-align:center"></td><td style="text-align:center">检索+删除队列头元素， 若队列为空， 返回null</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">pollLast()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">peekFirst()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">peekLast()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">以下为会抛出异常操作</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">addFirst(e)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">addLast(e)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">removeFirst()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">removeLast()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">getFirst()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">getLast()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>collision—different key have same bucket</p><ul><li>Open hashing : Separate Chaining(Close Addressing) —use the linked list in the bucket to link the different k-v pairs</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">Return</th><th style="text-align:center">Method</th><th style="text-align:center">Usage</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">V</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/HashMap.html#get-java.lang.Object-" target="_blank" rel="noopener">get</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a> key)</td><td style="text-align:center">hashMap.get(key)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">value or default value</td><td style="text-align:center"><u>getOrDefault</u>(Object key, V defaultValue)</td><td style="text-align:center">hashMap.put(key, value)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">put(K key, V value)</td><td style="text-align:center">hashMap.put(key, value)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">containsKey(Object key)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Set&lt;Map.Entry&lt;K, V&gt;&gt;</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/HashMap.html#entrySet--" target="_blank" rel="noopener">entrySet</a>()</td><td style="text-align:center">获得了某个entry：entry.getKey(); entry.getValue()</td><td style="text-align:center">Returns a <a href="https://docs.oracle.com/javase/9/docs/api/java/util/Set.html" target="_blank" rel="noopener"><code>Set</code></a> view of the mappings contained in this map.</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/HashMap.html#remove-java.lang.Object-" target="_blank" rel="noopener">remove</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a> key)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/HashMap.html#remove-java.lang.Object-java.lang.Object-" target="_blank" rel="noopener">remove</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a> key, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a> value)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>Collection&lt;V&gt;</code></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/HashMap.html#values--" target="_blank" rel="noopener">values</a>()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Set<k></k></td><td style="text-align:center">keySet()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">V</td><td style="text-align:center">putIfAbsent(K key, V value)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>HashMap的遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(Map.Entry&lt;Integer, Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">int key = entry.getKey();</span><br><span class="line">int value = entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><table><thead><tr><th style="text-align:center">Return</th><th style="text-align:center">Method</th><th style="text-align:center">Usage</th><th style="text-align:center">Discription</th></tr></thead><tbody><tr><td style="text-align:center">boolean</td><td style="text-align:center">add(E e)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Set.html#contains-java.lang.Object-" target="_blank" rel="noopener">contains</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a> o)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Set.html#remove-java.lang.Object-" target="_blank" rel="noopener">remove</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a> o)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">isEmpty()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a>[]</td><td style="text-align:center">toArray()</td><td style="text-align:center"></td><td style="text-align:center">Returns an array containing all of the elements in this set.</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>什么时候最好用到PriorityQueue：</p><p>求最大值/最小值时： O(1)</p><p><img src="http://i68.tinypic.com/31667bq.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;ListNode&gt; minHeap = new PriorityQueue&lt;&gt;(lists.length, (a, b) -&gt; a.val - b.val);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;ListNode&gt; minHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; a.val - b.val);</span><br></pre></td></tr></table></figure><p>其中comparator要自定义，如果不是primitive type</p><table><thead><tr><th style="text-align:center">Return</th><th style="text-align:center">Method</th><th style="text-align:center">Usage</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">boolean</td><td style="text-align:center">offer(E e)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/PriorityQueue.html" target="_blank" rel="noopener">E</a></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/PriorityQueue.html#poll--" target="_blank" rel="noopener">poll</a>()</td><td style="text-align:center"></td><td style="text-align:center">Retrieves and removes the head of this queue, or returns <code>null</code> if this queue is empty.s</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><code>peek()</code></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">size()</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a>[]</td><td style="text-align:center"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/PriorityQueue.html#toArray--" target="_blank" rel="noopener">toArray</a>()</td><td style="text-align:center"></td><td style="text-align:center">Returns an array containing all of the elements in this queue.</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h2 id="TreeMap-Red-Black-tree，类似BST"><a href="#TreeMap-Red-Black-tree，类似BST" class="headerlink" title="TreeMap(Red-Black tree，类似BST)"></a>TreeMap(Red-Black tree，类似BST)</h2><p>什么时候使用TreeMap？</p><p>答案： 又想知道最小值/最大值，又想支持修改和<strong><u>Remove</u></strong> 都是O(logn)</p><table><thead><tr><th>Return</th><th>Method</th><th>Usage</th><th>Description</th></tr></thead><tbody><tr><td></td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/TreeMap.html#put-K-V-" target="_blank" rel="noopener">put</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/util/TreeMap.html" target="_blank" rel="noopener">K</a> key, <a href="https://docs.oracle.com/javase/9/docs/api/java/util/TreeMap.html" target="_blank" rel="noopener">V</a> value)</td><td></td><td></td></tr><tr><td>boolean</td><td>containsKey(Object key)</td><td></td><td></td></tr><tr><td>V</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/TreeMap.html#remove-java.lang.Object-" target="_blank" rel="noopener">remove</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a> key)</td><td>maxTreeSet.first()</td><td></td></tr><tr><td><strong>Set&lt;Map.Entry&lt;K, V&gt;&gt;</strong></td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/TreeMap.html#entrySet--" target="_blank" rel="noopener">entrySet</a>()</td><td></td><td></td></tr><tr><td><strong>Map.Entry&lt;K, V&gt;</strong></td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/TreeMap.html#firstEntry--" target="_blank" rel="noopener">firstEntry</a>()</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="TreeSet-Red-Black-tree，类似BST"><a href="#TreeSet-Red-Black-tree，类似BST" class="headerlink" title="TreeSet  (Red-Black tree，类似BST)"></a>TreeSet  (Red-Black tree，类似BST)</h2><ul><li><p>contains, add, <strong><u>Remove</u></strong>,  都是O(logn)</p></li><li><p>支持按照<strong>特定方式排序</strong> （要自定义comparator)</p><p>具有PriorityQueue： O(logn) getMax/getMin</p><p>也具有BST search: O(logn) serach</p></li></ul><table><thead><tr><th>Return</th><th>Method</th><th>Usage</th><th>Description</th></tr></thead><tbody><tr><td><strong>boolean</strong></td><td>add(E e)</td><td></td><td></td></tr><tr><td>boolean</td><td>contains(Object o)</td><td></td><td></td></tr><tr><td>E</td><td>first()</td><td>O(logn) getMax/getMin</td><td></td></tr><tr><td>E</td><td>pollFirst()</td><td>删除tree顶部元素</td><td></td></tr><tr><td>boolean</td><td>remove(Object o)</td><td></td><td></td></tr><tr><td>E</td><td><code>floor(E e)</code></td><td>O（logn)找到target的左侧最大(相等)Element</td><td>Returns the greatest element in this set &lt;= the given element, or <code>null</code> if there is no such element.</td></tr><tr><td>E</td><td><a href="https://docs.oracle.com/javase/9/docs/api/java/util/TreeSet.html#ceiling-E-" target="_blank" rel="noopener">ceiling</a>(<a href="https://docs.oracle.com/javase/9/docs/api/java/util/TreeSet.html" target="_blank" rel="noopener">E</a> e)</td><td>O(logn)找到target右侧最小(相等）Element</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>###Make TreeMap/TreeSet, HashMap/HashSet can handle Dups 小技巧：</p><p>针对TreeMap/TreeSet or HashMap/HashSet 中出现要考虑存“重复值”的的解决技巧：</p><ul><li><p><strong>自定义comparator</strong>: 如果遇到要存重复值–nums[a] == nums[b]</p><p>—可以考虑TreeMap/TreeSet中<strong><em><u>改存相应的index</u></em></strong> (因为一遍过的idx具有唯一性)</p><p>—How to write customized comparator?</p><p>通过分析题意： 比如重复值出现（nums[a] == nums[b] ?), 思考一下你想每次poll出来的到底是靠右的idx, 还是靠左的idx?<br>—》如果想要poll出来靠右的idx: 那么值相等时， idx 大的那个优先（在顶部）！即— b - a;<br>—》如果想要poll出来靠左的idx: 那么值相等时， idx 小的那个优先（在顶部）！即— a - b;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example;</span><br><span class="line"></span><br><span class="line">//类似minTreeSet:</span><br><span class="line">Comparator&lt;Integer&gt; comparator = (a, b) -&gt; nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b;</span><br><span class="line">TreeSet&lt;Integer&gt; minTreeSet = new TreeSet&lt;&gt;(comparator);</span><br><span class="line"></span><br><span class="line">//maxTreeSet:</span><br><span class="line">TreeSet&lt;Integer&gt; maxTreeSet = new TreeSet&lt;&gt;(comparator.reversed());</span><br></pre></td></tr></table></figure></li><li><p>相关练习习题：</p></li></ul><p>LeetCode: 480. Sliding Widnow Median</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Sliding Window 总结</title>
      <link href="/2018/05/07/Sliding-Window-%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/07/Sliding-Window-%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Slide-Window-滑动窗口-Hash"><a href="#Slide-Window-滑动窗口-Hash" class="headerlink" title="Slide Window 滑动窗口 + Hash"></a>Slide Window 滑动窗口 + Hash</h1><h3 id="什么样的题目适合用slide-window"><a href="#什么样的题目适合用slide-window" class="headerlink" title="什么样的题目适合用slide window"></a>什么样的题目适合用slide window</h3><ol><li>找符合某种condition 的subtring </li></ol><p>相似题目：</p><ol><li>Minimum window substring</li><li>Longest Substring without Repeating Characters</li><li>Longest Substring with at most 2 Distinct Characters</li><li>Longest Substring with at most k Distinct Characters</li></ol><a id="more"></a><h4 id="题型：找符合某种condition-的subtring"><a href="#题型：找符合某种condition-的subtring" class="headerlink" title="题型：找符合某种condition 的subtring"></a>题型：找符合某种condition 的subtring</h4><hr><h4 id="LeetCode-3-Longest-Substring-Without-Repeating-Characters"><a href="#LeetCode-3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="LeetCode 3. Longest Substring Without Repeating Characters"></a>LeetCode 3. Longest Substring Without Repeating Characters</h4><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><p><strong>Examples:</strong></p><p>Given <code>&quot;abcabcbb&quot;</code>, the answer is <code>&quot;abc&quot;</code>, which the length is 3.</p><p>Given <code>&quot;bbbbb&quot;</code>, the answer is <code>&quot;b&quot;</code>, with the length of 1.</p><p>Given <code>&quot;pwwkew&quot;</code>, the answer is <code>&quot;wke&quot;</code>, with the length of 3. Note that the answer must be a <strong>substring</strong>, <code>&quot;pwke&quot;</code> is a <em>subsequence</em>and not a substring.</p><p><strong>题目意思： 找符合“no repeat”条件的substring</strong></p><p>技巧摘要： </p><ol><li>Two Pointer （start， i）— 决定substring的长度 len = i - start + 1</li><li>HashMap: 存string中每个character的index， 持续保持更新</li><li>conditional variable： no repeat</li></ol><p>解法一：beat： 31% 用 hashMap： 存char, Latest updated char’s index </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        if(s == null || s.length() == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">        int start = 0; </span><br><span class="line">        int len = 0;</span><br><span class="line">        //hashMap: char, char&apos;s lastes updated index</span><br><span class="line">        </span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; s.length(); i++)&#123;</span><br><span class="line">            if(hashMap.containsKey(s.charAt(i)))&#123;</span><br><span class="line">            //start pointer只能往前走： case： pwwkewp</span><br><span class="line">                start = Math.max(start, hashMap.get(s.charAt(i)) + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新或增加hashMap中的index</span><br><span class="line">            hashMap.put(s.charAt(i), i);</span><br><span class="line">            len = Math.max(len, i - start + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 优化：beat 91% </p><p>与解法一思想一样，只是 用hashtable: </p><p>int[] hash = new int[256];  //最多有256个字符</p><p>initialize foreach hash[i] = -1;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        if(s == null || s.length() == 0)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        //p w e w k e p</span><br><span class="line">        //注意点： start, i 只能forward</span><br><span class="line">        //hash: char : char&apos;s lastest updated index        </span><br><span class="line">        int[] hash = new int[256];</span><br><span class="line">        for(int i = 0; i &lt; 256; i++)</span><br><span class="line">            hash[i] = -1;</span><br><span class="line">        </span><br><span class="line">        int start = 0;</span><br><span class="line">        int max = 0;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; s.length(); i++)&#123;</span><br><span class="line">            if(hash[s.charAt(i)] != -1)&#123;</span><br><span class="line">                start = Math.max(start, hash[s.charAt(i)] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            hash[s.charAt(i)] = i;</span><br><span class="line">            max = Math.max(max, i - start + 1); //i 每往前forward一次, 都要从新计算maxLength</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="159-Longest-Substring-with-At-Most-Two-Distinct-Characters"><a href="#159-Longest-Substring-with-At-Most-Two-Distinct-Characters" class="headerlink" title="159. Longest Substring with At Most Two Distinct Characters"></a>159. Longest Substring with At Most Two Distinct Characters</h4><p>Given a string <strong>s</strong> , find the length of the longest substring <strong>t</strong>  that contains <strong>at most</strong> 2 distinct characters.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;eceba&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: t is &quot;ece&quot; which its length is 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;ccaabbb&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: t is &quot;aabbb&quot; which its length is 5.</span><br></pre></td></tr></table></figure><p>题目意思： 找到符合“at most 2 distinct character” 的Substring</p><p> 和LeetCode 3 类似，难点在于怎么处理contidition variable = “at most 2 distinct character”</p><p>技巧摘要： </p><ol><li>Two Pointer （start， i）— 决定substring的长度 len = i - start + 1</li><li>HashMap: 存string中每个character的index， 持续保持更新</li><li>conditional variable： at most 2 distinct character</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstringTwoDistinct(String s) &#123;</span><br><span class="line">        </span><br><span class="line">        if(s == null || s.length() == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        int start = 0;</span><br><span class="line">        int max = 0;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; s.length(); i++)&#123;</span><br><span class="line">            //处理conditional： at most 2 distinct character</span><br><span class="line">            if(hashMap.size() &lt; 2)&#123;</span><br><span class="line">                hashMap.put(s.charAt(i), i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if(hashMap.size() == 2)&#123;</span><br><span class="line">                if(hashMap.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                    hashMap.put(s.charAt(i), i);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    int leftMost = s.length();</span><br><span class="line">                    for(int num: hashMap.values())&#123;</span><br><span class="line">                        leftMost = Math.min(leftMost, num);</span><br><span class="line">                    &#125;</span><br><span class="line">                    //保证hashMap中元素最多两个</span><br><span class="line">                    hashMap.remove(s.charAt(leftMost));</span><br><span class="line">                    start = leftMost + 1;</span><br><span class="line">                    hashMap.put(s.charAt(i), i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            max = Math.max(max, i - start + 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        return max;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> String </tag>
            
            <tag> Two Pointer </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DFS 模板 + 相关问题</title>
      <link href="/2018/05/07/DFS%E6%A8%A1%E6%9D%BF+%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2018/05/07/DFS%E6%A8%A1%E6%9D%BF+%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="DFS-模板-相关问题"><a href="#DFS-模板-相关问题" class="headerlink" title="DFS 模板 + 相关问题"></a>DFS 模板 + 相关问题</h1><a id="more"></a><h2 id="DFS-BackTracking"><a href="#DFS-BackTracking" class="headerlink" title="DFS + BackTracking"></a>DFS + BackTracking</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void dfs(...) </span><br><span class="line">&#123;</span><br><span class="line">    // Step 1： 结束递归的条件</span><br><span class="line">    if (...) &#123;</span><br><span class="line">        ..... // 把“当前结果” 加入 “结果集容器” 中</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Step 2: 继续递归，里面可能有回溯，也可能没有</span><br><span class="line">    //---used for backtracking： 如果需要回溯， 先保存当前状态</span><br><span class="line">    if (...) &#123;</span><br><span class="line"></span><br><span class="line">        ... // 在容器中保存当前数据</span><br><span class="line">        dfs() </span><br><span class="line">        ... // 在容器中删除上面保存的数据（注：这种情况下就称为回溯，很明显它是dfs的一个步骤）</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //----backtracking如果需要回溯， reset</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###难点</p><ol><li>寻找dfs结束条件</li><li>继续dfs的条件</li></ol><h4 id="79-Word-Search"><a href="#79-Word-Search" class="headerlink" title="79. Word Search"></a>79. Word Search</h4><p>Given a 2D board and a word, find if the word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given word = &quot;ABCCED&quot;, return true.</span><br><span class="line">Given word = &quot;SEE&quot;, return true.</span><br><span class="line">Given word = &quot;ABCB&quot;, return false.</span><br></pre></td></tr></table></figure><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><ol><li><p>遍历board所有cell，因为每个cell都可以作为起点</p></li><li><p>DFS中： 寻找DFS终止条件</p><p>2.1 越界： 该起点不行—&gt;return false</p><p>2.2 当前cell不是我要找的Character： 该起点不行—&gt; return false</p><p>2.3 避开了以上出口条件： 没越界，起点是要找单字， 且是<strong>最后一个单字</strong> —&gt;该起点整句找到， return true</p></li><li><p>如果避开以上， 说明没找到整句，以该坐标为起点， 继续四个方向找Index + 1的单字</p><p>3.1 注意去重：方法一： Mark board； 方法二： 另用一个visited二维数组</p><p>​    3.1.1  尝试4个方向前， mark  该坐标为visited， 记得保存当前状态，作为reset</p></li><li><p>explore 4 direction</p></li><li><p>reset board （backtracking）</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">        </span><br><span class="line">        if(board == null || board.length == 0 || board[0].length == 0 || word == null || word.length() == 0)</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        //尝试所有的cell，记得reset board</span><br><span class="line">        for(int i = 0; i &lt; board.length; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; board[0].length; j++)&#123;</span><br><span class="line">                if(dfsExist(board, word, 0, i, j))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return false;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public boolean dfsExist(char[][] board, String word, int index, int x, int y)&#123;</span><br><span class="line">        if(x &lt; 0 || y &lt; 0 | x &gt;= board.length || y &gt;= board[0].length)</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        if(word.charAt(index) != board[x][y])</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        if(index == word.length() - 1)</span><br><span class="line">            return true;</span><br><span class="line">        </span><br><span class="line">        char tmp = board[x][y]; //保存当前状态，用作以后reset</span><br><span class="line">        board[x][y] = &apos;#&apos;; //mark as visited</span><br><span class="line">        </span><br><span class="line">        boolean res = dfsExist(board, word, index + 1, x, y + 1) || dfsExist(board, word, index + 1, x, y - 1) </span><br><span class="line">            || dfsExist(board, word, index + 1, x + 1,  y ) || dfsExist(board, word, index + 1, x - 1,  y );</span><br><span class="line">        </span><br><span class="line">        board[x][y] = tmp; //backtracking： reset board</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java基础知识总结----集合，框架</title>
      <link href="/2018/05/05/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93----%E9%9B%86%E5%90%88%EF%BC%8C%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/05/05/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93----%E9%9B%86%E5%90%88%EF%BC%8C%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础知识总结—集合，框架"><a href="#Java基础知识总结—集合，框架" class="headerlink" title="Java基础知识总结—集合，框架"></a>Java基础知识总结—集合，框架</h1><p><img src="https://i1.wp.com/javabydeveloper.com/wp-content/uploads/2016/06/Collection-Framework-hierarchy.png" alt="集合，框架"></p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection:"></a>Collection:</h2><h4 id="—List-有序-元素存入集合的顺序和取出的顺序一致-，元素都有索引。元素可以重复。"><a href="#—List-有序-元素存入集合的顺序和取出的顺序一致-，元素都有索引。元素可以重复。" class="headerlink" title="—List: 有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。"></a>—List: 有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。</h4><h4 id="—Set-无序-存入和取出顺序有可能不一致-，不可以存储重复元素。必须保证元素唯一性。"><a href="#—Set-无序-存入和取出顺序有可能不一致-，不可以存储重复元素。必须保证元素唯一性。" class="headerlink" title="—Set: 无序(存入和取出顺序有可能不一致)，不可以存储重复元素。必须保证元素唯一性。"></a>—Set: 无序(存入和取出顺序有可能不一致)，不可以存储重复元素。必须保证元素唯一性。</h4><a id="more"></a><h3 id="常用方法：（增查删改）"><a href="#常用方法：（增查删改）" class="headerlink" title="常用方法：（增查删改）"></a>常用方法：（增查删改）</h3><ul><li>添加：<ul><li>add(object)：添加一个元素</li><li>addAll(Collection) ：添加一个集合中的所有元素。</li></ul></li><li>删除<ul><li>clear()：将集合中的元素全删除，清空集合。</li><li>remove(obj) ：删除集合中指定的对象。注意：删除成功，集合的长度会改变。</li><li>removeAll(collection) ：删除部分元素。部分元素和传入Collection一致。</li></ul></li><li>判断：<ul><li>boolean contains(obj) ：集合中是否包含指定元素 。</li><li>boolean containsAll(Collection) ：集合中是否包含指定的多个元素。</li><li>boolean containsAll(Collection) ：集合中是否包含指定的多个元素。</li></ul></li><li>获取：<ul><li>int size()：集合中有几个元素。</li></ul></li><li>取交集<ul><li>boolean  retainAll(Collection) ：对当前集合中保留和指定集合中的相同的元素。如果两个集合元素相同，返回flase；如果retainAll修改了当前集合，返回true。</li></ul></li><li>获取集合中所有元素<ul><li>Iterator  iterator()：迭代器 </li></ul></li><li>将集合变成数组：<ul><li>toArray(); </li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = coll.iterator();//获取容器中的迭代器对象，至于这个对象是是什么不重要。这对象肯定符合一个规则Iterator接口。</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Collection coll = new ArrayList();</span><br><span class="line"></span><br><span class="line">coll.add(&quot;abc0&quot;);</span><br><span class="line"></span><br><span class="line">coll.add(&quot;abc1&quot;);</span><br><span class="line"></span><br><span class="line">coll.add(&quot;abc2&quot;);</span><br><span class="line"></span><br><span class="line">//--------------方式1----------------------</span><br><span class="line"></span><br><span class="line">Iterator it = coll.iterator();</span><br><span class="line"></span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(it.next());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//---------------方式2用此种----------------------</span><br><span class="line"></span><br><span class="line">for(Iterator it = coll.iterator();it.hasNext(); )&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(it.next());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h4 id="Collection-接口之—-List接口："><a href="#Collection-接口之—-List接口：" class="headerlink" title="Collection 接口之— List接口："></a>Collection 接口之— List接口：</h4><h4 id="List本身是Collection接口的子接口，具备了Collection的所有方法。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。"><a href="#List本身是Collection接口的子接口，具备了Collection的所有方法。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。" class="headerlink" title="List本身是Collection接口的子接口，具备了Collection的所有方法。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。"></a><strong>List本身是Collection接口的子接口，具备了Collection的所有方法</strong>。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。</h4><h4 id="List：有序-元素存入集合的顺序和取出的顺序一致-，元素都有索引。元素可以重复。"><a href="#List：有序-元素存入集合的顺序和取出的顺序一致-，元素都有索引。元素可以重复。" class="headerlink" title="List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。"></a>List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。</h4><p>|–ArrayList：底层的数据结构是数组,线程不同步，ArrayList替代了Vector，查询元素的速度非常快。</p><p>|–LinkedList：底层的数据结构是链表，线程不同步，增删元素的速度非常快。</p><p>|–Vector：底层的数据结构就是数组，线程同步的，Vector无论查询和增删都巨慢。</p><p>1，添加：</p><p>add(index,element) ：在指定的索引位插入元素。</p><p>addAll(index,collection) ：在指定的索引位插入一堆元素。</p><p>2，删除：</p><p>remove(index) ：删除指定索引位的元素。 返回被删的元素。</p><p>3，获取：</p><p>Object get(index) ：通过索引获取指定元素。</p><p><strong>int indexOf(obj) ：</strong>获取指定元素第一次出现的索引位，如果该元素不存在返回-1；</p><p> 所以，通过-1，可以判断一个元素是否存在。</p><p>int lastIndexOf(Object o) ：反向索引指定元素的位置。</p><p>List subList(start,end) ：获取子列表。</p><p>4，修改：</p><p>Object set(index,element) ：对指定索引位进行元素的修改。</p><p>5，获取所有元素：</p><p>ListIterator listIterator()：list集合特有的迭代器。</p><p>List集合支持对元素的增、删、改、查。</p><h4 id="Collection接口之—LinkedList-接口"><a href="#Collection接口之—LinkedList-接口" class="headerlink" title="Collection接口之—LinkedList 接口"></a>Collection接口之—LinkedList 接口</h4><p><strong>LinkedList</strong>：<strong>的特有方法。</strong></p><p>addFirst();</p><p>addLast();</p><p>在jdk1.6以后。</p><p><strong>offerFirst();</strong></p><p><strong>offerLast();</strong></p><p>getFirst():获取链表中的第一个元素。如果链表为空，抛出NoSuchElementException;</p><p>getLast();</p><p>在jdk1.6以后。</p><p><strong>peekFirst();</strong>获取链表中的第一个元素。如果链表为空，返回null。</p><p><strong>peekLast();</strong></p><p>removeFirst()：获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，抛出NoSuchElementException</p><p>removeLast();</p><p>在jdk1.6以后。</p><p><strong>pollFirst();</strong>获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，返回null。</p><p><strong>pollLast();</strong></p><h4 id="Collection接口之—Set接口"><a href="#Collection接口之—Set接口" class="headerlink" title="Collection接口之—Set接口"></a>Collection接口之—Set接口</h4><p>Set接口中的方法和Collection中方法一致的。<strong>Set接口取出方式只有一种，迭代器。</strong></p><p>|–HashSet：底层数据结构是哈希表，线程是不同步的。无序，高效；</p><p>HashSet集合保证元素唯一性：通过元素的hashCode方法，和equals方法完成的。</p><p>当元素的hashCode值相同时，才继续判断元素的equals是否为true。</p><p>如果为true，那么视为相同元素，不存。如果为false，那么存储。</p><p>如果hashCode值不同，那么不判断equals，从而提高对象比较的速度。</p><p>​      |–LinkedHashSet：有序，hashset的子类。</p><p>|–TreeSet：对Set集合中的元素的进行指定顺序的排序。不同步。TreeSet底层的数据结构就是二叉树</p><p>TreeSet:</p><p>用于对Set集合进行元素的指定顺序排序，排序需要依据元素自身具备的比较性。</p><p>如果元素不具备比较性，在运行时会发生ClassCastException异常。</p><p>所以需要元素实现Comparable接口，强制让元素具备比较性，复写compareTo方法。</p><p>依据compareTo方法的返回值，确定元素在TreeSet数据结构中的位置。</p><p>TreeSet方法保证元素唯一性的方式：就是参考比较方法的结果是否为0，如果return 0，视为两个对象重复，不存。</p><p>注意：在进行比较时，如果判断元素不唯一，比如，同姓名，同年龄，才视为同一个人。</p><p>在判断时，需要分主要条件和次要条件，当主要条件相同时，再判断次要条件，按照次要条件排序。</p><p>TreeSet集合排序有两种方式，Comparable和Comparator区别：</p><p>1：让元素自身具备比较性，需要元素对象实现Comparable接口，覆盖compareTo方法。</p><p>2：让集合自身具备比较性，需要定义一个实现了Comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给TreeSet集合的构造函数。</p><p>第二种方式较为灵活。</p><h2 id="Map集合："><a href="#Map集合：" class="headerlink" title="Map集合："></a>Map集合：</h2><h5 id="–Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。"><a href="#–Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。" class="headerlink" title="|–Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。"></a>|–Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。</h5><h4 id="–HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable"><a href="#–HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable" class="headerlink" title="|–HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable."></a>|–HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable.</h4><h4 id="–TreeMap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。"><a href="#–TreeMap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。" class="headerlink" title="|–TreeMap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。"></a>|–TreeMap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。</h4><p>Map集合存储和Collection有着很大不同：</p><p>Collection一次存一个元素；Map一次存一对元素。</p><p>Collection是单列集合；Map是双列集合。</p><p>Map中的存储的一对元素：一个是键，一个是值，键与值之间有对应(映射)关系。</p><p>特点：要保证map集合中键的唯一性。</p><p>1，添加。</p><p> <strong>put</strong>(key,value)：当存储的键相同时，新的值会替换老的值，并将老值返回。如果键没有重复，返回null。</p><p>void putAll(Map);</p><p>2，删除。</p><p>void clear()：清空</p><p>value remove(key) ：删除指定键。</p><p>3，判断。</p><p>boolean <strong>isEmpty</strong>()：</p><p>boolean <strong>containsKey</strong>(key)：是否包含key</p><p>boolean <strong>containsValue</strong>(value) ：是否包含value</p><p>4，取出。</p><p>int size()：返回长度</p><p>value <strong>get</strong>(key) ：通过指定键获取对应的值。如果返回null，可以判断该键不存在。当然有特殊情况，就是在hashmap集合中，是可以存储null键null值的。</p><p>Collection <strong>values</strong>()：获取map集合中的所有的值。</p><p>5，想要获取map中的所有元素：</p><p>原理：map中是没有迭代器的，collection具备迭代器，只要将map集合转成Set集合，可以使用迭代器了。之所以转成set，是因为map集合具备着键的唯一性，其实set集合就来自于map，set集合底层其实用的就是map的方法。</p><p>把map集合转成set的方法：</p><p>Set <strong>keySet</strong>();</p><p>Set <strong>entrySet</strong>();//取的是键和值的映射关系</p><p>Entry就是Map接口中的内部接口；</p><p>为什么要定义在map内部呢？entry是访问键值关系的入口，是map的入口，访问的是map中的键值对。</p><hr><p>取出map集合中所有元素的方式一：keySet()方法。</p><p>可以将map集合中的键都取出存放到set集合中。对set集合进行迭代。迭代完成，再通过get方法对获取到的键进行值的获取。</p><h4 id="使用Collection，-Map的技巧："><a href="#使用Collection，-Map的技巧：" class="headerlink" title="使用Collection， Map的技巧："></a>使用Collection， Map的技巧：</h4><p>看到Array就是数组结构，有角标，查询速度很快。</p><p>看到link就是链表结构：增删速度快，而且有特有方法。addFirst； addLast； removeFirst()； removeLast()； getFirst()；getLast()；</p><p>看到hash就是哈希表，就要想要哈希值，就要想到唯一性，就要想到存入到该结构的中的元素必须覆盖hashCode，equals方法。</p><p>看到tree就是二叉树，就要想到<strong>排序</strong>，就想要用到比较。</p><p>比较的两种方式：</p><p>一个是Comparable：覆盖compareTo方法；</p><p>一个是Comparator：覆盖compare方法。</p><p>LinkedHashSet，LinkedHashMap:这两个集合可以保证哈希表有存入顺序和取出顺序一致，保证哈希表有序</p><p>####集合什么时候用？</p><p>当存储的是一个元素时，就用Collection。当存储对象之间存在着映射关系时，就使用Map集合。</p><p><u>保证唯一，就用Set</u>。不保证唯一，就用List。</p><p>#####Collections：它的出现给集合操作提供了更多的功能。这个类不需要创建对象，内部提供的都是静态方法。</p><p>####Collection 和 Collections的区别：</p><p>Collections是个java.util下的类，是针对集合类的一个<strong>工具类</strong>,提供一系列静态方法,实现对集合的查找、排序、替换、线程安全化（将非同步的集合转换成同步的）等操作。</p><p>Collection是个java.util下的接口，它是各种集合结构的父接口，继承于它的接口主要有Set和List,提供了关于集合的一些操作,如插入、删除、判断一个元素是否其成员、遍历等。</p><p>文章转载自： <a href="http://www.cnblogs.com/bigorangehasc/p/8646091.html" target="_blank" rel="noopener">http://www.cnblogs.com/bigorangehasc/p/8646091.html</a></p>]]></content>
      
      
      <categories>
          
          <category> LearnJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Typora</title>
      <link href="/2018/05/05/Typora%E9%94%AE%E7%9B%98%E4%BE%A0/"/>
      <url>/2018/05/05/Typora%E9%94%AE%E7%9B%98%E4%BE%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora-从此请叫我键盘侠"><a href="#Typora-从此请叫我键盘侠" class="headerlink" title="Typora:从此请叫我键盘侠"></a>Typora:从此请叫我键盘侠</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. cd hexoFolder</span><br><span class="line">2. $ hexo new &quot;My New Post&quot;</span><br><span class="line">3. 修改tags和categories</span><br><span class="line">4. 在本地服务器上检测： hexo s --debug</span><br><span class="line">5. 传到GitHub：</span><br><span class="line"></span><br><span class="line"> $hexo g</span><br><span class="line"> $hexo d</span><br><span class="line"> </span><br><span class="line">快捷键大全：</span><br><span class="line"></span><br><span class="line">http://joehill.me/2015/07/27/2015-07-27-Markdown-Typora/</span><br><span class="line"></span><br><span class="line">http://www.flypeom.site/documentation/2017/09/02/Typora%E7%AE%80%E4%BB%8B%E5%8F%8AMarkdown%E8%AF%AD%E6%B3%95%E7%B2%BE%E8%AE%B2/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LearnJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>刷题中问题总结</title>
      <link href="/2018/05/05/Java/"/>
      <url>/2018/05/05/Java/</url>
      
        <content type="html"><![CDATA[<ol><li><p><strong>while循环什么时候退出？</strong></p><p>先分析题意，找到退出条件conditions, 然后while循环里的statement就是：<strong>^(conditions)</strong></p><p>De-Morgan’s Law:</p><ol><li>^(A &amp;&amp; B) —&gt; ^A || ^B</li><li>^(A || B)  —&gt; ^A &amp;&amp; ^B</li></ol></li><li><p>对于一个Sorted Array出现的问题</p></li></ol><p>立马联想到：</p><ul><li>Binary Search</li><li>while loop + two pointers: 谁小移动谁</li></ul><p><a href="https://www.geeksforgeeks.org/union-and-intersection-of-two-sorted-arrays-2/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/union-and-intersection-of-two-sorted-arrays-2/</a></p>]]></content>
      
      
      <categories>
          
          <category> LearnJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Learn to build personal web</title>
      <link href="/2018/05/05/LeetCode/"/>
      <url>/2018/05/05/LeetCode/</url>
      
        <content type="html"><![CDATA[<p>我就想随便写点啥</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p></blockquote><figure class="highlight plain"><figcaption><span>_.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="noopener">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.compact([0, 1, false, 2, &apos;&apos;, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LearnJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/05/05/hello-world/"/>
      <url>/2018/05/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
